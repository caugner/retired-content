---
title: Kiểu dữ liệu và cấu trúc dữ liệu trong Javascript
slug: Web/JavaScript/Data_structures
translation_of: Web/JavaScript/Data_structures
---
<div>{{jsSidebar("More")}}</div>

<p>Tất cả các ngôn ngữ lập trình đều có cấu trúc dữ liệu dựng sẵn, nhưng mỗi ngôn ngữ thường có những kiểu cấu trúc dữ liệu khác nhau. Bài viết này sẽ cố gắng liệt kê những kiểu dữ liệu dựng sẵn trong Javascript và những thuộc tính của chúng. Chúng có thể được dùng để xây dựng những kiểu cấu trúc dữ liệu khác. Khi có thể, rút ra so sánh với những ngôn ngữ khác.</p>

<h2 id="Kiểu_động">Kiểu động</h2>

<p>JavaScript là một ngôn ngữ <em>định kiểu yếu</em> hay <em>động</em>. Điều đó nghĩa là không cần phải khai báo kiểu của các biến trước khi dùng. Kiểu sẽ được xác định tự động trong khi chương trình được thực thi. Điều đó cũng có nghĩa là một biến có thể chứa giá trị của các kiểu dữ liệu khác nhau:</p>

<pre class="brush: js notranslate">let foo = 42;    // foo là một số
foo     = 'bar'; // foo bây giờ là một chuỗi
foo     = true;  // foo bây giờ là một boolean
</pre>

<h2 id="Các_kiểu_Dữ_liệu_và_kiểu_Cấu_trúc">Các kiểu Dữ liệu và kiểu Cấu trúc</h2>

<p>Tiêu chuẩn ECMAScript mới nhất xác định chín kiểu:</p>

<ul>
 <li>Sáu kiểu Dữ liệu {{Glossary("Primitive", "sơ khai")}} (primitive), có thể kiểm tra với toán tử <a href="/en-US/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a>:

  <ul>
   <li>{{Glossary("Undefined", "Kiểu undefined")}}: <code>typeof instance === "undefined"</code></li>
   <li>{{Glossary("Boolean", "Kiểu Boolean")}}: <code>typeof instance === "boolean"</code></li>
   <li>{{Glossary("Number", "Kiểu số")}}: <code>typeof instance === "number"</code></li>
   <li>{{Glossary("String", "Kiểu chuỗi")}}: <code>typeof instance === "string"</code></li>
   <li>{{Glossary("BigInt", "Kiểu số BigInt")}}: <code>typeof instance === "bigint"</code></li>
   <li>{{Glossary("Symbol", "Kiểu Symbol")}}: <code>typeof instance === "symbol"</code></li>
  </ul>
 </li>
 <li>{{Glossary("null", "Kiểu null")}}: <code>typeof instance === "object"</code>. Một kiểu {{Glossary("Primitive", "sơ khai")}} mà giá trị của nó có thêm một vai trò đặc biệt: nếu object không kế thừa từ đối tượng nào khác, <code>null</code> sẽ được hiển thị ở cuối <a href="/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">chuỗi Prototype</a></li>
 <li>{{Glossary("Object", "Object")}}: <code>typeof instance === "object"</code>. Kiểu phi dữ liệu nhưng có cấu trúc cho các đối tượng <a href="/en-US/docs/Learn/JavaScript/Objects#The_Constructor">được khởi tạo</a> và được dùng như cấu trúc dữ liệu: new <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">Object</a>, new <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>, new <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>, new <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>, new <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>, new <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a>, new <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a> hay bất kỳ đối tượng nào được tạo ra với <a href="/en-US/docs/Web/JavaScript/Reference/Operators/new">từ khóa new</a>.</li>
 <li>Kiểu phi dữ liệu {{Glossary("Function", "Function")}}, mặc dù khi gọi với typeof nó có nhãn riêng: <code>typeof instance === "function"</code>. Giá trị trả về từ typeof này là một nhãn đặc biệt cho các function, cho dù constructor của Function phát sinh từ Object constructor.</li>
</ul>

<p>Lưu ý: vai trò có giá trị duy nhất của toán tử <code>typeof</code> là dùng để kiểm tra các kiểu Dữ liệu (sơ khai). Nếu bạn muốn kiểm tra các kiểu Cấu trúc phát sinh từ Object, <code>typeof</code> sẽ chẳng có ích gì vì nó sẽ luôn trả về <code>"object"</code>. Cách đúng đắn để kiểm tra một Object thuộc loại nào là dùng từ khóa <a href="/en-US/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof</a>. Tuy nhiên, ngay cả với cách này cũng có một vài ngoại lệ.</p>

<h2 id="Giá_trị_sơ_khai">Giá trị sơ khai</h2>

<p>Tất cả các kiểu trừ đối tượng đều được xác định giá trị bất biến (giá trị không có khả năng thay đổi). Ví dụ (và không như ngôn ngữ C), các chuỗi là bất biến. Ta gọi chúng là "giá trị sơ khai" ("primitive").</p>

<h3 id="Kiểu_boolean">Kiểu boolean</h3>

<p>Kiểu boolean mang hai giá trị logic là: <code>true</code>, và <code>false</code>. Xem thêm {{Glossary("Boolean")}} và {{jsxref("Boolean")}}.</p>

<h3 id="Kiểu_null">Kiểu null</h3>

<p>Có duy nhất một giá trị: <code>null</code>. Xem {{jsxref("null")}} và {{Glossary("Null")}} để biết thêm chi tiết.</p>

<h3 id="Kiểu_undefined">Kiểu undefined</h3>

<p>Một biến chưa được gán giá trị có giá trị <code>undefined</code>. Xem {{jsxref("undefined")}} và {{Glossary("Undefined")}} để biết thêm chi tiết.</p>

<h3 id="Kiểu_số_Number">Kiểu số Number</h3>

<p>Theo tiêu chuẩn ECMAScript, chỉ có duy nhất một kiểu số: the <a href="http://en.wikipedia.org/wiki/Double_precision_floating-point_format">double-precision 64-bit binary format IEEE 754 value</a> (có giá trị từ -(2<sup>53</sup> -1) đến 2<sup>53</sup> -1). <strong>Không có kiểu số nguyên</strong>. Ngoài việc có thể chứa giá trị dấu phẩy động, kiểu số có ba giá trị biểu tượng: <code>+Infinity</code>, <code>-Infinity</code>, and <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> (not-a-number).</p>

<p>Để kiểm tra lớn hơn hay nhỏ hơn <code>+/-Infinity</code>, bạn có thể xem {{jsxref("Number.MAX_VALUE")}} hoặc {{jsxref("Number.MIN_VALUE")}} và bất đầu từ ECMAScript 6, bạn cũng có thể kiểm tra một số có nằm trong khoảng double-precision floating-point bằng cách dùng {{jsxref("Number.isSafeInteger()")}} cũng như {{jsxref("Number.MAX_SAFE_INTEGER")}} và {{jsxref("Number.MIN_SAFE_INTEGER")}}. Ngoài phạm vi này, một số trong Javascript không còn an toàn nữa.</p>

<p>Có một số nguyên duy nhất có hai đại diện: 0 được đại diện bởi -0 và +0. ("0" là một bí danh của +0). Trong thực tế, điều này hầu như không có tác động. Ví dụ <code>+0 === -0</code> là <code>true</code>. Tuy nhiên, có thể nhân thấy điều này khi chia một số cho không:</p>

<pre class="brush: js notranslate">&gt; 42 / +0
Infinity
&gt; 42 / -0
-Infinity
</pre>

<p>Mặc dù một số thường chỉ đại diện cho giá trị của nó, JavaScript cung cấp <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" title="en/JavaScript/Reference/Operators/Bitwise_Operators">một vài toán tử nhị phân</a>. Chúng có thể được sử dụng như một chuỗi boolean bằng cách dùng <a class="external" href="http://en.wikipedia.org/wiki/Mask_%28computing%29">bit masking</a>. Điều này thường được xem như là một cách tệ, tuy nhiên, JavaScript không cung cấp bất kỳ phương tiện nào khác để trình bày một tập hợp các boolean (như một mảng các boolean hay một đối tượng với các thuộc tính boolean). Bit masking cũng có xu hướng làm mã khó đọc, hiểu, và duy trì hơn. Nó có thể cấn thiết trong một môi trường rất hạn chế, giống như khi cố gắng để đối phó với hạn chế lưu trữ lưu trữ cục bộ hoặc trong trường hợp nặng khi mỗi chút so với đếm mạng. Kỹ thuật này chỉ nên được xem xét khi nó là biện pháp cuối cùng có thể được thực hiện để tối ưu hóa kích thước.</p>

<h3 id="Kiểu_số_BigInt">Kiểu số BigInt</h3>

<p>Kiểu {{jsxref("BigInt")}} là một kiểu giá trị số sơ khai trong JavaScript, đại diện cho các giá trị số nguyên với độ chính xác (precision) bất kỳ. Với <code>BigInt</code>, bạn có thể lưu và tính toán trên các số nguyên lớn mà nó có thể lớn hơn cả giới hạn an toàn của kiểu <code>Number</code>.</p>

<p>Một số <code>BigInt</code> được tạo ra bằng cách thêm <code>n</code> vào cuối giá trị literal số nguyên hoặc bằng cách sử dụng constructor.</p>

<p>Bạn có thể lấy giá trị nguyên an toàn lớn nhất của kiểu <code>Number</code> bằng cách sử dụng constant {{jsxref("Number.MAX_SAFE_INTEGER")}}. Với sự ra đời của kiểu <code>BigInt</code>, giờ đây bạn có thể tính toán với những con số còn lớn hơn {{jsxref("Number.MAX_SAFE_INTEGER")}}.</p>

<p>Trong ví dụ sau, khi tăng dần giá trị {{jsxref("Number.MAX_SAFE_INTEGER")}}, bạn vẫn nhận được kết qua như mong muốn với <code>BigInt</code>:</p>

<pre class="brush: js notranslate">&gt; const x = 2n ** 53n;
9007199254740992n
&gt; const y = x + 1n;
9007199254740993n</pre>

<p>Bạn có thể sử dụng các toán tử <code>+</code>, <code>*</code>, <code>-</code>, <code>**</code>, và <code>%</code> với <code>BigInt</code> như với <code>Number</code>. Một số <code>BigInt</code> không hoàn toàn bằng (===) một số <code>Number</code>, nhưng có thể bằng khi ép kiểu (==).</p>

<p>Số <code>BigInt</code> hành xử giống với <code>Number</code> khi được chuyển đổi kiểu về <code>Boolean</code>: <code>if</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>Boolean</code>, <code>!</code>.</p>

<p>Số <code>BigInt</code> không thể dùng chung với số <code>Number</code> để tính toán. Khi đó, lỗi {{jsxref("TypeError")}} sẽ xảy ra.</p>

<h3 id="Kiểu_chuỗi">Kiểu chuỗi</h3>

<p>Kiểu {{jsxref("Global_Objects/String", "chuỗi")}} được dùng để biểu diễn dữ liệu dạng văn bản. Nó là một dãy "các phần tử" số nguyên 16-bit. Mỗi phần tử có một vị trí trong chuỗi. Phần tử đầu tiên có chỉ số 0, tiếp theo là 1, ... . Độ dài của chuỗi là số phần tử của nó.</p>

<p>Không giống với những ngôn ngữ như C, Chuỗi trong Javascript là bất biến. Nghĩa là một khi chuỗi được tạo thì không thể chỉnh sửa. Tuy nhiên, vẫn có thể tạo một chuỗi mới dựa vào các thao tác trên chuỗi cũ. Ví dụ:</p>

<ul>
 <li>Tạo một chuỗi con của chuỗi ban đầu bằng cách ghép từng ký tự hoặc dùng {{jsxref("String.substr()")}}.</li>
 <li>Nối hai chuỗi bằng toán tử (<code>+</code>) hoặc hàm {{jsxref("String.concat()")}}.</li>
</ul>

<h4 id="Cẩn_thận_với_việc_lưu_mọi_thứ_bằng_chuỗi_trong_code_của_bạn!">Cẩn thận với việc "lưu mọi thứ bằng chuỗi" trong code của bạn!</h4>

<p>Chuỗi có thể được dùng để biểu diễn dữ liệu với cấu trúc phức tạp. Điều này mang tới một vài lợi ích ngắn hạn:</p>

<ul>
 <li>Rất dễ để xây dựng một chuỗi bằng phép nối.</li>
 <li>Dễ debug (những gì bạn thấy khi in luôn là tất cả những thứ có trong chuỗi).</li>
 <li>Chuỗi là mẫu số chung của rất nhiều API (<a href="/en-US/docs/Web/API/HTMLInputElement" title="HTMLInputElement">nhập</a>, <a href="/en-US/docs/Storage" title="Storage">local storage</a> values, {{ domxref("XMLHttpRequest") }} phản hồi khi dùng <code>responseText</code>, ...) và điều này có thể khiến việc chỉ làm việc với chuỗi được yêu thích.</li>
</ul>

<p>Chuỗi có thể biểu diễn bất kì kiểu dữ liệu nào. Những đây không được xem là một ý hay. Ví dụ, đối với một separator, có thể bắt trước một chuỗi (trong khi một mảng sẽ thích hợp hơn). Thật không may, khi separator được dùng trong một "danh sách" các phần tử, danh sách bị hỏng. Một escape character có thể được chọn, ..... Tất cả những điều này yêu cầu một quy ước và tạo ra gánh nặng bảo trì không cần thiết.</p>

<p>Chỉ nên dùng chuỗi để lưu trữ dữ liệu văn bản. Khi biểu diễn một cấu trúc phức tạp, phân tích chuỗi thành các cấu trúc dữ liệu với mức trừu tưỡng cao hơn.</p>

<h3 id="Kiểu_Symbol">Kiểu Symbol</h3>

<p>Kiểu Symbol là một kiểu mới trong Javascript tiêu chuẩn ECMAScript 6. Mỗi Symbol là một giá trị sơ khai <strong>đơn nhất</strong> và <strong>bất biến</strong> và có thể được dùng như một khóa của một Object (xem bên dưới). Trên một số ngôn ngữ lập trình, Symbol còn được gọi là "atom" (nguyên tử). Ta cũng có thể so sánh với các enumeration (enum) trong C. Xem {{Glossary("Symbol")}} và {{jsxref("Symbol")}} để biết thêm chi tiết.</p>

<h2 id="Đối_tượng">Đối tượng</h2>

<p>Trong khoa học máy tính, một đối tượng là một giá trị trong bộ nhớ được tham chiếu bởi một {{Glossary("Identifier", "định danh")}}.</p>

<h3 id="Thuộc_tính">Thuộc tính</h3>

<p>Trong Javascript, đối tượng có thể được xem là tập hợp các thuộc tính. Với <a href="/en-US/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Object_literals">object literal syntax</a>, một tập hợp hữu hạn các thuộc tính được khởi tạo; sau đó thuộc tính có thể được thêm hoặc loại bỏ. Giá trị thuộc tính thuộc bất kỳ kiểu dữ liệu, bao gồm những đối tượng khác (kể cả chính đối tượng đó), điều này cho phép xây những những cấu trúc dữ liệu phức tạp. Thuộc định được định danh bằng khóa. Một khóa phải là một chuỗi hoặc một Symbol.</p>

<p>Có hai loại thuộc tính với các đặc điểm nhất định: Chứa dữ liệu và accessor.</p>

<h4 id="Thuộc_tính_chứa_dữ_liệu">Thuộc tính chứa dữ liệu</h4>

<p>Liên kết một khóa với một giá trị có các đặc điểm sau:</p>

<p>Các đặc điểm của thuộc tính chứa dữ liệu</p>

<table class="standard-table">
 <tbody>
  <tr>
   <th>Đặc điểm</th>
   <th>Kiểu</th>
   <th>Mô tả</th>
   <th>Giá trị mặc định</th>
  </tr>
  <tr>
   <td>[[Value]]</td>
   <td>Bất kỳ</td>
   <td>Giá trị của thuộc tính.</td>
   <td>undefined</td>
  </tr>
  <tr>
   <td>[[Writable]]</td>
   <td>Boolean</td>
   <td>Nếu là <code>false</code>, thuộc tính [[Value]] không thể thay đổi.</td>
   <td>false</td>
  </tr>
  <tr>
   <td>[[Enumerable]]</td>
   <td>Boolean</td>
   <td>Nếu là <code>true</code>, khóa của giá trị có thể được liệt kê bằng vòng lặp <a href="/en-US/docs/Web/JavaScript/Reference/Statements/for...in">for...in</a>.</td>
   <td>false</td>
  </tr>
  <tr>
   <td>[[Configurable]]</td>
   <td>Boolean</td>
   <td>Nếu là <code>false</code>, thuộc tính không thể bị xóa cũng như không thể thay đổi các đặc điểm của nó.</td>
   <td>false</td>
  </tr>
 </tbody>
</table>

<h4 id="Accessor">Accessor</h4>

<p>Liên kết một khóa với một hoặc hai hàm accessor (get và/hoặc set):</p>

<table class="standard-table">
 <caption>Attributes of an accessor property</caption>
 <tbody>
  <tr>
   <th>Đặc điểm</th>
   <th>Loại</th>
   <th>Mô tả</th>
   <th>Giá trị mặc định</th>
  </tr>
  <tr>
   <td>[[Get]]</td>
   <td>Hàm hoặc undefined</td>
   <td>Hàm được gọi không đối số và trả về giá trị mỗi khi có truy cập tới thuộc tính. Xem <a href="/en-US/docs/Web/JavaScript/Reference/Operators/get"><code>get</code></a>.</td>
   <td>undefined</td>
  </tr>
  <tr>
   <td>[[Set]]</td>
   <td>Hàm hoặc undefined</td>
   <td>Hàm được gọi với một đối số mỗi khi thuộc tính được gán một giá trị. Xem <a href="/en-US/docs/Web/JavaScript/Reference/Operators/set"><code>set</code></a>.</td>
   <td>undefined</td>
  </tr>
  <tr>
   <td>[[Enumerable]]</td>
   <td>Boolean</td>
   <td>Nếu là <code>true</code>, khóa của giá trị có thể được liệt kê bằng vòng lặp <a href="/en-US/docs/Web/JavaScript/Reference/Statements/for...in">for...in</a>.</td>
   <td>false</td>
  </tr>
  <tr>
   <td>[[Configurable]]</td>
   <td>Boolean</td>
   <td>Nếu là <code>false</code>, thuộc tính không thể bị xóa cũng như không thể thay đổi các đặc điểm của nó.</td>
   <td>false</td>
  </tr>
 </tbody>
</table>

<h3 id="Đối_tượng_thông_thường_và_hàm">Đối tượng "thông thường" và hàm</h3>

<p>Mội đối tượng là một bảng các khóa và giá trị. Khóa là một chuỗi và giá trị có thể là bất kỳ thứ gì. Điều này khiến đối tượng phù hợp với <a class="external" href="https://vi.wikipedia.org/wiki/B%E1%BA%A3ng_b%C4%83m">hashmaps</a>.</p>

<p>Hàm là một đối tượng với khả năng có thể gọi.</p>

<h3 id="Đối_tượng_Date">Đối tượng Date</h3>

<p>Để biểu diễn một thời điểm hay ngày tháng, Lựa chọn tốt nhất là sử dụng <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a>.</p>

<h3 id="Tập_hợp_có_thứ_tự_Mảng_và_mảng_đã_định_kiểu">Tập hợp có thứ tự: Mảng và mảng đã định kiểu</h3>

<p><a href="/en-US/docs/JavaScript/Reference/Global_Objects/Array" title="Array">Mảng</a> là một đối tượng có một quan hệ đặc biệt giữa các thuộc tính có khóa nguyên và thuộc tính 'length'. Thêm vào đó, mảng thừa kế các thuộc tính của <code>Array.prototype</code> cung cấp một số ít các hàm xeur lý danh sách. Ví dụ, <code><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" title="en/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a></code> (tìm giá trị trên một mảng) hay <code><a href="/en-US/docs/JavaScript/Reference/Global_Objects/Array/push" title="en/JavaScript/Reference/Global_Objects/Array/push">push</a></code> (thêm một phần tử vào cuối danh sach), .... Điều này biến mảng trở thành ứng cử viên hoàn hào cho danh sách hoặc tập hợp.</p>

<p><a href="/en-US/docs/Web/JavaScript/Typed_arrays">Mảng đã định kiểu</a> là loại mới trong ECMAScript 6 và biểu diễn dữ liệu nhị phân như một mảng. Bảng sau đây giúp bạn so sánh với kiểu dữ liệu trong C:</p>

<p>{{page("/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray", "TypedArray_objects", "", 0, 3)}}</p>

<h3 id="Keyed_collections_Maps_Sets_WeakMaps_WeakSets">Keyed collections: Maps, Sets, WeakMaps, WeakSets</h3>

<p>These data structures take object references as keys and are introduced in ECMAScript Edition 6. {{jsxref("Set")}} and {{jsxref("WeakSet")}} represent a set of objects, while {{jsxref("Map")}} and {{jsxref("WeakMap")}} associate a value to an object. The difference between Maps and WeakMaps is that in the former, object keys can be enumerated over. This allows garbage collection optimizations in the latter case.</p>

<p>One could implement Maps and Sets in pure ECMAScript 5. However, since objects cannot be compared (in the sense of "less than" for instance), look-up performance would necessarily be linear. Native implementations of them (including WeakMaps) can have look-up performance that is approximately logarithmic to constant time.</p>

<p>Usually, to bind data to a DOM node, one could set properties directly on the object or use <code>data-*</code> attributes. This has the downside that the data is available to any script running in the same context. Maps and WeakMaps make it easy to privately bind data to an object.</p>

<h3 id="Structured_data_JSON">Structured data: JSON</h3>

<p>JSON (JavaScript Object Notation) is a lightweight data-interchange format, derived from JavaScript but used by many programming languages. JSON builds universal data structures. See {{Glossary("JSON")}} and {{jsxref("JSON")}} for more details.</p>

<h3 id="More_objects_in_the_standard_library">More objects in the standard library</h3>

<p>JavaScript has a standard library of built-in objects. Please have a look at the <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects">reference</a> to find out about more objects.</p>

<h2 id="Determining_types_using_the_typeof_operator">Determining types using the <code>typeof</code> operator</h2>

<p>The <code>typeof</code> operator can help you to find the type of your variable. Please read the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">reference page</a> for more details and edge cases.</p>

<h2 id="Specifications">Specifications</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Initial definition.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-8', 'Types')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-ecmascript-data-types-and-values', 'ECMAScript Data Types and Values')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="See_also">See also</h2>

<ul>
 <li><a class="link-https" href="https://github.com/nzakas/computer-science-in-javascript/">Nicholas Zakas collection of common data structure and common algorithms in JavaScript.</a></li>
 <li><a href="https://github.com/monmohan/DataStructures_In_Javascript" title="https://github.com/monmohan/DataStructures_In_Javascript">Search Tre(i)es implemented in JavaScript</a></li>
</ul>
