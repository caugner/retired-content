---
title: Cú pháp lập trình
slug: Web/JavaScript/Guide/cu-phap-lap-trinh
translation_of: Web/JavaScript/Guide/Grammar_and_types
---
<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}</div>

<p class="summary">Phần này nói về các cú pháp cơ bản của ngôn ngữ JavaScript, các cách khai báo biến, các loại dữ liệu và chính tả (literal).</p>

<h2 id="Cơ_bản">Cơ bản</h2>

<p>Cú pháp của JavaScript (JS) phần lớn được vay mượn từ Java, nhưng JS cũng chịu ảnh hưởng từ cú pháp của các ngôn ngữ lập trình khác như Awk, Perl và Python.</p>

<p>JavaScript là ngôn ngữ lập trình sử dụng chuẩn kí tự <strong>Unicode</strong> và khi viết cũng cần phải lưu ý phân biệt chữ HOA và chữ thường (<strong>case-sensitive). </strong>Điều này có nghĩa là các từ như Früh (trong tiếng Đức có nghĩa là "sớm" - early) có thể được sử dụng đặt tên cho biến.</p>

<pre>let Früh = "foobar"
</pre>

<p>In JavaScript, instructions are called {{Glossary("Statement", "statements")}} and are separated by a semicolon (;).</p>

<p>Dấu chấm phẩy (;) chỉ cần thiết nếu trên cùng một dòng có từ hai câu lệnh trở lên. Trường hợp câu lệnh nằm riêng một dòng thì không cần dấu chấm phẩy.</p>

<p><em>ECMAScript cũng có những nguyên tắc để tự động thêm dấu chấm phẩy (<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Automatic_semicolon_insertion">ASI</a>) để đánh dấu kết thúc một dòng lệnh. (Để biết thêm, xem tài liệu tham khảo chi tiết tại đây: JavaScript's <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar">lexical grammar</a>.)</em></p>

<p>Thực tế thì nên luôn luôn thêm một dấu chấm phẩy vào cuối mỗi câu lệnh, thậm chí khi điều này là không bắt buộc. Việc làm này sẽ giúp tránh bớt bug.</p>

<p>Các đoạn mã Javascript sẽ được đọc từ trái qua phải và được chuyển thể thành một chuỗi các input elements bao gồm: <em>tokens, control characters, line terminators, comments</em> hoặc {{glossary("whitespace")}}. (Spaces, tabs, và các ký tự đánh dấu dòng mới được xem là whitespace.)</p>

<h2 id="Comments">Comments</h2>

<p>Cú pháp của<strong> comments</strong> thì ... giống với C++ và một số ngôn ngữ lập trình khác:</p>

<pre class="brush: js">// a one line comment &lt;-- đây là cách comment trên 1 dòng

/* this is a longer, cho những dòng dài hoặc nhiều dòng
   multi-line comment. hãy sử dụng kiểu comment này
 */

/* You can't, however /* nest comments */ SyntaxError */ &lt;-- Không nên lồng comment trong comment, như đoạn comment này sẽ gây ra lỗi vì "/*" được mở bên trong comment trước đó không có hiệu lực đối với từ SyntaxError nên dấu đóng comment "*/" sẽ gây ra lỗi cú pháp. </pre>

<p>Comments hoạt động như whitespace, và sẽ bị bỏ qua trong quá trình script chạy.</p>

<p class="brush: js"><em><strong>Note:</strong> Bạn có thể thấy loại cú pháp comment này trong một số file javascript <strong>#!/usr/bin/env node</strong>.</em></p>

<p class="brush: js"><em>Đây là cú pháp <strong>hashbang comment</strong>, và là một comment đặc biệt sử dụng để chỉ định đường dẫn đến một Javascript interpreter cụ thể có nhiệm vụ sẽ chạy đoạn script. Xem chi tiết <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Hashbang_comments">Hashbang comments</a>.</em></p>

<h2 id="Khai_báo_biến">Khai báo biến</h2>

<p>Có 3 kiểu khai báo biến trong JavaScript.</p>

<dl>
 <dt>{{jsxref("Statements/var", "var")}}</dt>
 <dd>Khai báo một biến, và tùy ý bạn có hoặc không khởi tạo giá trị cho nó.</dd>
 <dt>{{jsxref("Statements/let", "let")}}</dt>
 <dd>Khai báo một block-scoped, hoặc biến local, chỉ có thể truy cập được trong block bao quanh nó.</dd>
 <dt>
 <pre>function foo() {
  var x = 10;
  if (true) {
   let x = 20; // x ở đây được khai báo lại nhưng khi ra khỏi block-scoped nó sẽ nhận lại giá trị bên trên là 10
   console.log(x); // in ra 20
  }
   console.log(x); // in ra 10
}</pre>
 </dt>
 <dt>{{jsxref("Statements/const", "const")}}</dt>
 <dd>Khai báo một hằng block-scoped, read-only.</dd>
</dl>

<h3 id="Biến">Biến</h3>

<p>Bạn sử dụng biến như là tên tượng trưng cho các giá trị trong chương trình. Tên của biến được gọi là {{Glossary("Identifier", "identifier")}}, tuân theo những quy tắc nhất định.</p>

<p>Tên biến phải bắt đầu bằng một 'chữ cái', kí tự gạch dưới (<code>_</code>), hoặc kí tự dollar (<code>$</code>). Các ký tự tiếp theo cũng có thể là các chữ số <code>0-9</code>.  Vì JavaScript là case sensitive, các chữ các bao gồm các ký tự từ "<code>A</code>" đến "<code>Z</code>" (viết hoa) và "<code>a</code>" đến "<code>z</code>" (viết thường).</p>

<p>Bạn có thể sử dụng chuẩn ISO 8859-1 hoặc các kí tự Unicode như å và ü trong tên biến, thậm chí cả các kí tự dạng <a href="/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#String_literals">Unicode escape sequences</a>.</p>

<p>Ví dụ: <code>Number_hits</code>, <code>temp99</code>, and <code>_name</code>.</p>

<h3 id="Declaring_variables">Declaring variables</h3>

<p>Có hai cách khai báo biến:</p>

<ul>
 <li>Sử dụng từ khóa {{jsxref("Statements/var", "var")}}. Ví dụ <code>var x = 42</code>. Cú pháp này dùng khai báo cả 2 loại biến <strong>local </strong>và <strong>global</strong>, tùy thuộc vào ngữ cảnh thực thi.</li>
 <li>Sử dụng từ khóa  {{jsxref("Statements/const", "const")}} hoặc  {{jsxref("Statements/let", "let")}}. Ví dụ <code>let y = 13</code>. Cú pháp này dùng khai báo biến local nhưng chỉ có phạm vi trong block-scoped. (Xem <a href="https://wiki.developer.mozilla.org/vi/docs/Web/JavaScript/Guide/cu-phap-lap-trinh$edit#Variable_scope">Variable scope</a> bên dưới).</li>
</ul>

<p>Bạn cũng có thể khai báo biến mà không dùng các từ khóa trên, ví dụ <code>x = 42</code>. Điều này sẽ tạo ra một biến <strong><a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#Description">undeclared global</a></strong> variable. Nó sẽ tạo nên một warning trong JavaScript. Undeclared variables có thể dẫn đến các hành vi không mong muốn. Nên khuyến cáo không nên sử dụng chúng.</p>

<h3 id="Evaluating_variables">Evaluating variables</h3>

<p>Một biến được khai báo với cú pháp <code>var</code> hoặc <code>let</code> mà không gán giá trị, sẽ có giá trị mặc định là {{jsxref("undefined")}}.</p>

<p>Truong trường hợp truy cập đến một biến chưa được khai báo, thì exception {{jsxref("ReferenceError")}} sẽ được thrown:</p>

<pre>var a;
console.log('The value of a is ' + a); // The value of a is undefined

console.log('The value of b is ' + b); // The value of b is undefined
var b;
// This one may puzzle you until you read 'Variable hoisting' below

console.log('The value of c is ' + c); // Uncaught ReferenceError: c is not defined

let x;
console.log('The value of x is ' + x); // The value of x is undefined

console.log('The value of y is ' + y); // Uncaught ReferenceError: y is not defined
let y; </pre>

<p>Bạn có thể sử dụng <code>undefined</code>  để xét xem một biến có đang mang giá trị không. Dưới đây là một ví dụ, biến <code>input</code> chưa được gán giá trị, nên biến <code>input</code> lúc này mang giá trị mặc định <code>undefined</code> vậy câu điều kiện <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/if...else" title="en-US/docs/JavaScript/Reference/Statements/if...else">if</a></code> là <code>return true</code> và không chạy vào <code>else</code>.</p>

<pre class="brush: js">var input;
if(input === undefined){
  doThis();
} else {
  doThat();
}
</pre>

<p>Giá trị <code>undefined</code> tương đương với <code>fasle</code> khi sử dụng trong bối cảnh boolean, như ví dụ dưới đây, chương trình sẽ chạy function <code>myFunction</code> vì element <code>myArray[0]</code>là <code>undefined</code> trả về <code>false</code>.</p>

<pre class="brush: js">var myArray = [];
if (!myArray[0]) {
  myFunction();
}

function myFunction() {
  alert('return false');
}
</pre>

<p>Khi biến có giá trị = <code>undefined </code>thực hiện phép toán với biến có giá trị cụ thể hoặc hằng số sẽ cho ra giá trị  = <code>NaN</code> (not a number). </p>

<pre class="brush: js">var a;
a + 2 = NaN</pre>

<p><code>Null</code> khác với <font face="consolas, Liberation Mono, courier, monospace"><span style="background-color: rgba(220, 220, 220, 0.5);">Undefined</span></font>. Khi biến có giá trị {{jsxref("null")}}, biến sẽ mang giá trị 0 trong các phép toán (numeric) và <code>false</code> trong các ngữ cảnh boolean. Ví dụ:</p>

<pre class="brush: js">var n = null;
console.log(n * 32); // Will log 0 to the console
</pre>

<h3 id="Variable_scope">Variable scope</h3>

<p>Khi bạn khai báo một biến bên ngoài function, biến đó được gọi là <em>global </em>variable, bởi vì biến đó sẽ có hiệu lực đến bất kì đoạn code nào khác trong document hiện tại. Khi bạn khai báo một biến bên trong một function, nó gọi là <em>local </em>variable, vì nó chỉ có thể dùng được trong phạm vi function đó.</p>

<p>Javascript trước phiên bản ECMAScript 6 không có định nghĩa  <a href="/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#Block_statement" title="en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#Block_statement">block statement</a> scope; thay vào đó, một biến được khai báo trong một block được xem là có giá trị local đối với function (hoặc global scope) mà block đó cư trú.</p>

<p>Ví dụ sau đây sẽ log ra <code>5</code>, vì scope của <code>x</code> là global context (hoặc function context nếu đoạn code này là một phần của function khác). Scope của <code>x</code> không bị giới hạn vào block câu lệnh <code>if</code> trực tiếp gần nhất.</p>

<pre class="brush: js">if (true) {
  var x = 5;
}
console.log(x);  // 5
</pre>

<p>Điều này đã thay đổi khi sử dụng kiểu khai báo <code>let</code> được giới thiệu trong ECMAScript 6.</p>

<pre class="brush: js">if (true) {
  let y = 5;
}
console.log(y);  // ReferenceError: y is not defined (y bị giới hạn trực tiếp trong block chứa nó)
</pre>

<h3 id="Variable_hoisting">Variable hoisting</h3>

<p>Một thứ không bình thường khác về các biến trong JavaScript là bạn có thể tham chiếu đến một biến tại vị trí phía trước câu lệnh khai báo. Khái niệm này gọi là <strong>hoisting</strong>; các biến trong JavaScript ở khía cạnh nào đó sẽ được "hoisted" (treo) hoặc lifted (nâng) vào vị trí trên cùng của câu lệnh hoặc hàm gần nó nhất. Tuy nhiên, các variables bị hoisted này sẽ trả về giá trị <code>undefined</code>. Nên cho dù bạn khai báo và khởi tạo sau khi bạn sử dụng hoặc tham chiếu đến biến này, thì trước đó nó vẫn trả về <code>undefined</code>.</p>

<pre class="brush: js">/**
 * Example 1
 */
console.log(x); // undefined
var x = 3;
console.log(x); // 3

/**
 * Example 2
 */
// will return a value of undefined
var myvar = "my value";

(function() {
  console.log(myvar); // undefined vì bên dưới có dòng khai báo var myvar, điều này làm biến myvar bị hoisting và nhận giá trị mới là undefined (giá trị 'my value' lúc này không còn hiệu lực vì biến đã bị hoisting)
  var myvar = "local value";
})();
</pre>

<p>Ví dụ bên trên có thể được biểu đạt theo cách khác như sau:</p>

<pre class="brush: js">/**
 * Example 1
 */
var x;
console.log(x === undefined); // logs "true"
x = 3;

/**
 * Example 2
 */
var myvar = "my value";

(function() {
  var myvar;
  console.log(myvar); // undefined
  myvar = "local value";
})();
</pre>

<p>Vì vấn đề hoisting này, tất cả các câu lệnh khai báo biến với <code>var</code> bên trong một function nên được đặt gần với đầu của function nhất có thể. Làm điều này giúp gia tăng độ rõ ràng của code (trường hợp dùng <code>var</code> như trong ví dụ 2 ở trên sẽ gây ra hoisting).</p>

<h3 id="Function_hoisting">Function hoisting</h3>

<p>Trong trường hợp của các function, chỉ các function được tạo theo kiểu function declaration là bị hoisted, còn function được tạo theo kiểu function expression thì không. Khác với variable hoisting, hoisted function không trả về giá trị mặc định <code>undefined</code>. Ví dụ:</p>

<pre class="brush: js">/* Function declaration */

foo(); // "bar"

function foo() {
  console.log('bar');
}


/* Function expression */

baz(); // TypeError: baz is not a function

var baz = function() {
  console.log('bar2');
};</pre>

<h3 id="Biến_toàn_cục_global_variables">Biến toàn cục (global variables)</h3>

<p>Các global variables trên thực tế là những properties của global object. Trong các web page, global object chính là <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/API/Window" title="The Window interface represents a window containing a DOM document; the document property points to the DOM document loaded in that window."><code>window</code></a>, nên bạn có thể set và truy cập đến các global variables bằng cách sử dụng cú pháp <code>window.<em>variable</em></code><em>.</em></p>

<p>Hệ quả  là, bạn có thể truy cập đến các global variables được khai báo trong một window hoặc frame từ một window hoặc frame khác, bằng cách chỉ định rõ tên của window hoặc frame. Ví dụ, nếu một biến có tên <font face="consolas, Liberation Mono, courier, monospace"><span style="background-color: rgba(220, 220, 220, 0.5);">phoneNumber</span></font> được khai báo trong một document, bạn có thể tham chiếu đến biến này từ một <font face="consolas, Liberation Mono, courier, monospace"><span style="background-color: rgba(220, 220, 220, 0.5);">iframe</span></font> như là <code>parent.phoneNumber</code>.</p>

<h3 id="Constants">Constants</h3>

<p>Bạn có thể tạo các hằng số read-only với từ khóa {{jsxref("Statements/const", "const")}}. Cú pháp đặt tên cho hằng cũng giống như biến, tên hằng phải bắt đầu bằng một chữ cái, hoặc dấu gạch dưới <code>_</code>, hoặc dấu dollar <code>$</code>, và có thể bao gồm mọi ký tự chữ, số, hoặc dấu gạch dưới.</p>

<pre class="brush: js">const PI = 3.14;
</pre>

<p>Một hằng số đã khai báo không thể thay đổi giá trị thông qua việc gán lại giá trị hoặc không thể bị khai báo lại trong khi đoạn script đang chạy. Và bắt buộc phải được gán giá trị ngay khi khởi tạo.</p>

<p>Các nguyên tắc về scope cho các hằng số cũng giống như cách các biến block-scoped như <code>let</code> hoạt động.</p>

<p>Bạn không thể khai báo một hằng số với tên trùng với tên function hoặc biến trong cùng một scope. Ví dụ:</p>

<pre class="example-bad brush: js">// THIS WILL CAUSE AN ERROR
function f() {};
const f = 5;

// THIS WILL CAUSE AN ERROR ALSO
function f() {
  const g = 5;
  var g;

  //statements
}
</pre>

<p>Tuy nhiên, khi gán một object vào một hằng, thì các thuộc tính của object đó là not protected, nên câu lệnh dưới đây sẽ được thực thi mà không lỗi.</p>

<pre>const MY_OBJECT = {'key': 'value'};
MY_OBJECT.key = 'otherValue';</pre>

<p>Cũng tương tự, các nội dung trong một mảng cũng là not protected, nên câu lệnh dưới đây sẽ được thực thi mà không lỗi.</p>

<pre>const MY_ARRAY = ['HTML','CSS'];
MY_ARRAY.push('JAVASCRIPT');
console.log(MY_ARRAY); //logs ['HTML','CSS','JAVASCRIPT'];</pre>

<h2 id="Cấu_trúc_dữ_liệu_và_kiểu_dữ_liệu">Cấu trúc dữ liệu và kiểu dữ liệu</h2>

<h3 id="Kiểu_dữ_liệu">Kiểu dữ liệu</h3>

<p>Tiêu chuẩn mới nhất của ECMAScript định nghĩa 8 kiểu dữ liệu:</p>

<ul>
 <li>Bảy kiểu dữ liệu nguyên thủy {{Glossary("Primitive", "primitives")}}:
  <ol>
   <li>{{Glossary("Boolean")}}. <code>true</code> và <code>false</code>.</li>
   <li>{{Glossary("null")}}. Một từ khóa đạc biệt biểu thị giá trị null. Vì JavaScript là case-sensitive, <code>null</code> sẽ không giống với <code>Null</code>, <code>NULL</code>, hoặc bất kỳ biến thể khác.</li>
   <li>{{Glossary("undefined")}}. Một thuộc tính top-level mà giá trị của nó là không xác định.</li>
   <li>{{Glossary("Number")}}. Một số nguyên (integer) hoặc số thực dấu chấm động (floating point number) <code>42</code> or <code>3.14159</code>.</li>
   <li>{{Glossary("BigInt")}}. An integer with arbitrary precision. For example: <code>9007199254740992n</code>.</li>
   <li>{{Glossary("String")}}. Một chuỗi các ký tự đại diện cho một giá trị văn bản. Ví dụ: "Howdy".</li>
   <li>{{Glossary("Symbol")}} (new in ECMAScript 6). Một kiểu dữ liệu mà các instance của nó là duy nhất và bất biến.</li>
  </ol>
 </li>
 <li>Và {{Glossary("Object")}}</li>
</ul>

<p>Mặc dù những kiểu dữ liệu này tương đối ít, chúng cho phép bạn có thể thể hiện những hàm rất hữu dụng. {{jsxref("Object", "Objects")}} và {{jsxref("Function", "functions")}} là những phần tử nền tảng khác của JavaScript. Bạn có thể xem object như là những vùng chứa được đặt tên (named container) để phục vụ cho các giá trị, và các hàm là những quy trình thủ tục để đoạn script của bạn thi hành.</p>

<h3 id="Chuyển_đổi_kiểu_dữ_liệu">Chuyển đổi kiểu dữ liệu</h3>

<p>JavaScript là dynamically typed language. Điều đó có nghĩa bạn không cần phải chỉ định kiểu dữ liệu của biến khi bạn khai báo biến, và kiểu dữ liệu được tự động chuyển đổi khi cần thiết trong quá trình đoạn script được thực thi.</p>

<p>Cho nên, ví dụ, bạn có thể định nghĩa một biến như sau:</p>

<pre class="brush: js">var answer = 42;
</pre>

<p>Và sau đó, bạn có thể gán cùng một biến này với một giá trị chuỗi, ví dụ:</p>

<pre class="brush: js">answer = "Thanks for all the fish...";
</pre>

<p>Bởi vì JavaScript là dynamically typed, việc gán giá trị này sẽ không gây ra lỗi.</p>

<h3 id="Các_số_và_toán_tử">Các số và toán tử '+'</h3>

<p>Trong các biểu thức (expression) có sự liên quan giữa các giá trị numeric và string với toán tử  <code>+</code>, JavaScript sẽ chuyển đổi giá trị số sang chuỗi. Ví dụ:</p>

<pre class="brush: js">x = "The answer is " + 42 // "The answer is 42"
y = 42 + " is the answer" // "42 is the answer"
</pre>

<p>Với tất cả mọi loại toán tử khác, JavaScript sẽ không chuyển đổi giá trị numeric sang string. Ví dụ:</p>

<pre class="brush: js">"37" - 7 // 30
"37" + 7 // "377"
</pre>

<h3 id="Chuyển_từ_kiểu_chuỗi_string_sang_kiểu_số_number">Chuyển từ kiểu chuỗi (string) sang kiểu số (number)</h3>

<p>Tong trường hợp một giá trị biểu thị một số nhưng lại được lưu trong bộ nhớ như là một chuỗi, có các phương thức để chuyển đổi.</p>

<ul>
 <li id="parseInt()_and_parseFloat()">{{jsxref("parseInt", "parseInt()")}}</li>
 <li>{{jsxref("parseFloat", "parseFloat()")}}</li>
</ul>

<p><code>parseInt</code> sẽ chỉ trả về các số nguyên, nên mục đích của nó là làm giảm bớt giá trị cho các số decimals. Thêm nữa, một thực hành tốt nhất cho <code>parseInt</code> là luôn luôn thêm vào nó tham số radix. Tham số radix được dùng để chỉ định hệ số học nào sẽ được sử dụng.</p>

<pre>parseInt('101', 2) // 5</pre>

<p>Một phương thức khác để nhận được giá trị số từ một chuỗi là dùng toán tử <code>+</code> </p>

<pre class="brush: js">"1.1" + "1.1" = "1.11.1"
(+"1.1") + (+"1.1") = 2.2
// Note: the parentheses are added for clarity, not required.</pre>

<h2 id="Literals">Literals</h2>

<p>Literals (nguyên văn), đại diện cho các giá trị trong JavaScript. Đây là những giá trị cố định - không phải biến - mà bạn cung cấp một cách <em>litterally </em>trong script của bạn. Phần này mô tả những kiểu literals sau đây:</p>

<ul>
 <li>{{anch("Array literals")}}</li>
 <li>{{anch("Boolean literals")}}</li>
 <li>{{anch("Floating-point literals")}}</li>
 <li>{{anch("Integers")}}</li>
 <li>{{anch("Object literals")}}</li>
 <li>{{anch("String literals")}}</li>
</ul>

<h3 id="Array_literals">Array literals</h3>

<p>Một array literal là một danh sách của không hoặc nhiều biểu thức, mỗi biểu thức trong đó đại diện cho một phần tử của mảng (array element), được bao bọc trong dấu ngoặc vuông (<code>[]</code>). Khi bạn tạo một mảng bằng cách dùng array literal, nó được khởi tạo với những giá trị cụ thể như là các element của mảng, và <code>length</code> của mảng là số lượng đối số (argument).</p>

<p>Ví dụ sau tạo ra mảng <code>coffees</code> với 3 phần tử và một <code>length</code> của 3:</p>

<pre class="brush: js">var coffees = ["French Roast", "Colombian", "Kona"];
</pre>

<p><strong>Note: </strong>Một array literal là một kiểu của object initializer. Xem <a href="/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Using_object_initializers" title="en-US/docs/JavaScript/Guide/Working with Objects#Using Object Initializers">Using Object Initializers</a>.</p>

<p>Nếu một mảng được tạo ra sử dụng một literal trong một top-level script, JavaScript sẽ interpret mảng mỗi lần nó đánh giá biểu thức có chứa array literal. Ngoài ra, một literal được sử dụng trong một hàm sẽ được tạo ra mỗi lần function được gọi.</p>

<p><strong>Note: </strong>Các array literals cũng là các <code>Array</code> objects. Xem {{jsxref("Array")}} and <a href="/en-US/docs/Web/JavaScript/Guide/Indexed_collections">Indexed collections</a> để biết chi tiết về <code>Array</code> objects.</p>

<h4 id="Dấu_phẩy_dư_trong_các_array_literals">Dấu phẩy dư trong các array literals</h4>

<p>Bạn không cần phải xác định mọi phần tử trong một array literal. Nếu bạn đặt 2 dấu phẩy trên cùng một hàng, mảng sẽ tạo ra một phần tử mang giá trị <code>undefined</code>. Ví dụ sau tạo ra mảng <code>fish</code>.</p>

<pre class="brush: js">var fish = ["Lion", , "Angel"];
</pre>

<p>Mảng này gồm 2 phần tử có giá trị và một phần tử rỗng (<code>fish[0]</code> là "Lion", <code>fish[1]</code> là <code>undefined</code>, và <code>fish[2]</code> là "Angel").</p>

<p>Nếu bạn thêm một dấu phẩy theo sau (trailing comma) phần tử cuối cùng của mãng, dấu phẩy này sẽ bị bỏ qua. Trong ví dụ sau, <code>length</code> của mảng là 3. Không có <code>myList[3]</code>. Tất cả dấu phẩy khác trong danh sách ngầm chỉ định là một phần tử mới. (<strong>Note:</strong> trailing commas có thể xem là lỗi đối với các trình duyệt cũ và tốt nhất là nên xóa chúng đi).</p>

<pre class="brush: js">let myList = ['home', , 'school', ];
</pre>

<p>Trong ví dụ bên dưới, <code>length</code> của mảng là 4, <code>myList[0]</code> và <code>myList[2]</code> bị thiếu.</p>

<pre class="brush: js">var myList = [ , 'home', , 'school'];
</pre>

<p>Trong ví dụ dưới, <code>length</code> của mảng là 4, <code>myList[1]</code> và <code>myList[3]</code> bị thiếu. <strong>Chỉ có dấu phẩy cuối cùng bị bỏ qua.</strong></p>

<pre class="brush: js">var myList = ['home', , 'school', , ];
</pre>

<p>Hiểu được hành vi của cac dấu phẩy thêm này rất quan trọng để hiểu được JavaScript như là một ngôn ngữ. Tuy nhiên, khi viết code của riêng bạn, bạn nên khai báo một cách rõ ràng các phần tử bị thiếu (missing elements) là <code>undefined</code>. Làm vậy sẽ gia tăng độ rõ ràng cho code và dễ bảo trì sau này.</p>

<h3 id="Boolean_literals">Boolean literals</h3>

<p>Kiểu Boolean có 2 giá trị literal: <code>true</code> và<code>false</code>.</p>

<p><strong>Cẩn thận:</strong> Đừng nhầm lẫn giá trị Boolean nguyên thủy <code>true</code> và <code>false</code> với true và fales của {{jsxref("Boolean")}} object. Boolean object là một lớp bao bên ngoài kiểu dữ liệu Boolean nguyên thủy. Xem {{jsxref("Boolean")}} để biết thêm.</p>

<h3 id="Numeric_literals">Numeric literals</h3>

<p>Kiểu dữ liệu {{jsxref("Number")}} và {{jsxref("BigInt")}} có thể được biểu diễn bằng hệ decimal (hệ 10), hệ hexadecimal (hệ 16), octal (hệ 8) và binary (base 2 - hệ nhị phân).</p>

<ul>
 <li>Một <em>decimal</em> numeric literal là một dãy liên tục của các chữ số mà không dẫn đầu bởi số <code>0</code> (zero).</li>
 <li>Ký tự số <code>0</code> (zero) dẫn đầu trên một numeric literal, hoặc <code>0o</code> (hoặc <code>0O</code>) ám chỉ rằng nó nằm trong hệ <em>octal. Octal numerics chỉ gồm các ký tự số từ </em><code>0</code>-<code>7</code>.</li>
 <li><code>0x</code> (hoặc <code>0X</code>) ám chỉ kiểu dữ liệu <em>hexadecimal </em>numeric. Hexadecimal numerics có thể gồm các ký tự số (<code>0</code>-<code>9</code>) và các chữ cái <code>a-f</code> và <code>A-F</code>. (Việc viết hoa chữ cái sẽ không làm thay đối giá trị của nó. Vì vậy <code>0xa</code> = <code>0xA</code> = <code>10</code> và <code>0xf</code> = <code>0xF</code> = <code>15</code>).</li>
 <li>Một ký tự <code>0b</code> (hoặc <code>0B</code>) dẫn đầu ám chỉ hệ nhị phân <em>binary </em>numeric literal. Binary numerics chỉ có thể bao gồm ký tự <code>0</code> và <code>1</code>.</li>
</ul>

<p>Một số ví dụ của numeric literals:</p>

<pre class="eval">0, 117, -345, 123456789123456789n             (decimal, base 10)
015, 0001 -0o77, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, -0xF1A7, 0x123456789ABCDEFn  (hexadecimal, "hex" or base 16)
0b11, 0b0011, -0b11, 0b11101001010101010101n  (binary, base 2)
</pre>

<p>Chi tiết xem thêm tại: <a href="/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Numeric_literals">Numeric literals in the Lexical grammar reference</a>.</p>

<h3 id="Floating-point_literals">Floating-point literals</h3>

<p>Một floating-point literal (literal số thực dấu chấm động) có thể có các bộ phận sau:</p>

<ul>
 <li>Một số nguyên hệ 10 decimal integer (có thể thêm vào trước "<code>+</code>" hoặc "<code>-</code>"),</li>
 <li>Một dấu chấm hệ 10 ("<code>.</code>"), </li>
 <li>Một phần thập phân (một số hệ 10 khác),</li>
 <li>Một số mũ.</li>
</ul>

<p>Bộ phận số mũ là một ký tự "<code>e</code>" hoặc "<code>E</code>", theo sau nó là một số nguyên integer (số nguyên integer này có thể có thêm phía trước là dấu "<code>+</code>" hoặc "<code>-</code>"). Một floating-point literal phải có ít nhất một ký tự số, và hoặc là một dấu chấm hệ 10 hoặc là ký tự "<code>e</code>" (hoặc "<code>E</code>"). Tóm lại, cú pháp như sau:</p>

<pre class="eval">[(+|-)][digits][.digits][(E|e)[(+|-)]digits]
</pre>

<p>Ví dụ: </p>

<pre class="eval">3.1415926
-.123456789
-3.1E+12
.1e-23
</pre>

<h3 id="Object_literals">Object literals</h3>

<p>Một object literal là một danh sách của không hoặc nhiều cặp property names và associated values (tên thuộc tính và giá trị được liên kết) của một một object, bao bọc bởi cặp dấu ngoặc nhọn (<code>{}</code>).</p>

<p>Lưu ý đừng sử dụng một object literal ngay tại vị trí bắt đầu của một câu lệnh! Điều này sẽ dẫn đến một lỗi (hoặc nó sẽ thực thi theo cách bạn không mong muốn), vì dấu mở ngoặc nhọn <code>{</code> sẽ được interpreted như là bắt đầu của một block.</p>

<p>Ví dụ dưới đây là một ví dụ của object literal. Phần tử đầu tiên của object <code>car</code> định nghĩa là một thuộc tính (property), <code>myCar</code>, và được gán giá trị kiểu chuỗi là "<code>myCar</code>", phần tử thứ 2, thuộc tính <code>getCar</code>, ngay lập tức được gán giá trị là kết quả trả về của việc gọi hàm <code>(CarTypes("Honda"));</code> phần tử thứ 3, thuộc tính <code>special</code>, sử dụng một biến đã tồn tại (<code>sales</code>).</p>

<pre class="brush: js">var Sales = "Toyota";

function CarTypes(name) {
  if (name == "Honda") {
    return name;
  } else {
    return "Sorry, we don't sell " + name + ".";
  }
}

var car = { myCar: "Saturn", getCar: CarTypes("Honda"), special: Sales };

console.log(car.myCar);   // Saturn
console.log(car.getCar);  // Honda
console.log(car.special); // Toyota
</pre>

<p>Thêm nữa, bạn có thể sử dụng cả kiểu số hoặc chữ để đặt tên cho thuộc tính của object, hoặc bạn có thể lồng một object bên trong một object khác. Ví dụ:</p>

<pre class="brush: js">var car = { manyCars: {a: "Saab", "b": "Jeep"}, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
</pre>

<p>Các tên thuộc tính của object có thể là bất kỳ chuỗi nào, bao gồm cả chuỗi rỗng <code>''</code>. Nếu tên thuộc tính không phải là một JavaScript <a href="/en-US/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Variables">identifier</a> hợp lệ, hoặc nó là số, thì nó phải được bao bọc trong các dấu nháy.</p>

<p>Các tên thuộc tính mà không phải là các identifier hợp lệ không thể được truy cập đến như các thuộc tính thông thường là dùng dấu chấm (<code>.</code>), nhưng <em>có thể</em> được truy cập đến và set giá trị bằng cặp dấu ngoặc vuông giống mảng ("<code>[]</code>").</p>

<pre class="brush: js">var unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!"
}
console.log(unusualPropertyNames."");   // SyntaxError: Unexpected string
console.log(unusualPropertyNames[""]);  // An empty string
console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
console.log(unusualPropertyNames["!"]); // Bang!</pre>

<p>Please note:</p>

<pre class="brush: js">var foo = {a: "alpha", 2: "two"};
console.log(foo.a);    // alpha
console.log(foo[2]);   // two
//console.log(foo.2);  // Error: missing ) after argument list
//console.log(foo[a]); // Error: a is not defined
console.log(foo["a"]); // alpha
console.log(foo["2"]); // two
</pre>

<h4 id="Enhanced_Object_literals">Enhanced Object literals</h4>

<p>Trong ES2015, các object literals được mở rộng từ đó hỗ trợ thêm việc cài đặt các prototype tại construction, shorthand cho việc gán biến <code>foo: foo</code>, các phương thức defining, make <code>super</code> calls, và xử lý các tên thuộc tính với các biểu thức. Cùng nhau, những thứ này cũng mang object listerals và khai báo <code>class</code> đến gần nhau hơn, và cho phép các thiết kế object-based để đạt được lợi ích từ một số tiện nghi giống nhau.</p>

<pre>var obj = {
    // __proto__
    __proto__: theProtoObj,
    // Shorthand for ‘handler: handler’
    handler,
    // Methods
    toString() {
     // Super calls
     return 'd ' + super.toString();
    },
    // Computed (dynamic) property names
    [ 'prop_' + (() =&gt; 42)() ]: 42
};</pre>

<h3 id="RegExp_literals">RegExp literals</h3>

<p>Một regex literal (được định nghĩa chi tiết <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">sau đây</a>) là một mô hình mẫu bao bọc giữa các dấu xuyệt <code>/</code>. Ví dụ:</p>

<pre>var re = /ab+c/;</pre>

<h3 id="String_literals">String literals</h3>

<p>Một string literal là không có hoặc có nhiều ký tự bao bọc trong dấu (<code>"</code>) hoặc (<code>'</code>). Một chuỗi (string) phải được giới hạn trong cặp dấu cùng loại; hoặc là cùng nháy đơn hoặc là cùng nháy kép. Ví dụ:</p>

<ul>
 <li><code>"foo"</code></li>
 <li><code>'bar'</code></li>
 <li><code>"1234"</code></li>
 <li><code>"one line \n another line"</code></li>
 <li><code>"John's cat"</code></li>
</ul>

<p>Bạn có thể gọi các phương thức của {{jsxref("String")}} object lên một giá trị string nguyên văn (string literal) - JavaScript tự động chuyển đổi string literal sang một String object tạm, gọi phương thức để chạy, chạy xong hủy bỏ String object tạm đó. Bạn cũng có thể sử dụng thuộc tính <code>String.length</code> với một string literal:</p>

<pre class="brush: js">console.log("John's cat".length)
// Will print the number of symbols in the string including whitespace.
// In this case, 10.
</pre>

<p>Trong ES2015, <em>template literals</em> cũng được đưa vào sử dụng. Template literals bao bọc trong dấu back-tick (<code>`</code>) (<a href="http://en.wikipedia.org/wiki/Grave_accent" rel="noopener">dấu huyền</a>) thay vì dấu nháy đơn hay nháy kép.</p>

<p>Các template strings cung cấp cú pháp đặc biệt (synctactic sugar) để xây dựng các chuỗi (string). (Điều này tương tự với đặc điểm nội suy chuỗi string interpolation trong Perl, Python, v.v...)</p>

<p>Tùy trường hợp, một thẻ tag có thể được thêm vào để cho phép việc xây dựng chuỗi được tùy chỉnh, tránh injection attacks, hoặc xây dựng nên những cấu trúc dữ liệu higher-level từ các nội dung của chuỗi.</p>

<pre>// Basic literal string creation
// `In JavaScript '\n' is a line-feed.`

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`

// String interpolation
var name = 'Bob', time = 'today';
`Hello ${name}, how are you ${time}?`

// Construct an HTTP request prefix used to interpret the replacements and construction
POST`http://foo.org/bar?a=${a}&amp;b=${b}
     Content-Type: application/json
     X-Credentials: ${credentials}
     { "foo": ${foo},
       "bar": ${bar}}`(myOnReadyStateChangeHandler);
</pre>

<p>Bạn nên sử dụng các string literals đơn thuần nếu không cần thiết phải sử dụng đến String object. Xem {{jsxref("String")}} để biết chi tiết về <code>String</code> objects.</p>

<h4 id="Sử_dụng_các_ký_tự_đặc_biệt_trong_chuỗi">Sử dụng các ký tự đặc biệt trong chuỗi</h4>

<p>Ngoài các ký tự thông thường, bạn cũng có thể thêm vào các ký tự đặc biệt trong chuỗi, ví dụ:</p>

<pre class="brush: js">"one line \n another line"
</pre>

<p>Bảng dưới đây liệt kê danh sách các ký tự đặc biệt có thể sử dụng trong các chuỗi JavaScript.</p>

<table class="standard-table">
 <caption>Table: JavaScript special characters</caption>
 <thead>
  <tr>
   <th scope="col">Character</th>
   <th scope="col">Meaning</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>\0</code></td>
   <td>Null Byte</td>
  </tr>
  <tr>
   <td><code>\b</code></td>
   <td>Backspace - Khoảng cách</td>
  </tr>
  <tr>
   <td><code>\f</code></td>
   <td>Form feed -</td>
  </tr>
  <tr>
   <td><code>\n</code></td>
   <td>New line - Dòng mới</td>
  </tr>
  <tr>
   <td><code>\r</code></td>
   <td>Carriage return</td>
  </tr>
  <tr>
   <td><code>\t</code></td>
   <td>Tab - Tab một tab</td>
  </tr>
  <tr>
   <td><code>\v</code></td>
   <td>Vertical tab - Tab dọc</td>
  </tr>
  <tr>
   <td><code>\'</code></td>
   <td>Apostrophe or single quote - trích dẫn đơn</td>
  </tr>
  <tr>
   <td><code>\"</code></td>
   <td>Double quote - ngoặc kép.</td>
  </tr>
  <tr>
   <td><code>\\</code></td>
   <td>Backslash character</td>
  </tr>
  <tr>
   <td><code>\<em>XXX</em></code></td>
   <td>The character with the Latin-1 encoding specified by up to three octal digits <em>XXX</em> between 0 and 377. For example, \251 is the octal sequence for the copyright symbol.</td>
  </tr>
  <tr>
  </tr>
  <tr>
   <td><code>\x<em>XX</em></code></td>
   <td>The character with the Latin-1 encoding specified by the two hexadecimal digits <em>XX</em> between 00 and FF. For example, \xA9 is the hexadecimal sequence for the copyright symbol.</td>
  </tr>
  <tr>
  </tr>
  <tr>
   <td><code>\u<em>XXXX</em></code></td>
   <td>The Unicode character specified by the four hexadecimal digits <em>XXXX</em>. For example, \u00A9 is the Unicode sequence for the copyright symbol. See {{anch("Unicode escape sequences")}}.</td>
  </tr>
 </tbody>
</table>

<h4 id="Escaping_characters">Escaping characters</h4>

<p>Đối với các ký tự không có trong bảng trên, dấu backslash <code>\</code> được thêm vào trước sẽ bị bỏ qua, nhưng cách dùng này đã không còn nữa và nên được tránh dùng.</p>

<p>Bạn có thể chèn vào một dấu ngoặc kép bên trong một chuỗi bằng cách đặt phía trước nó một dấu backslash <code>\</code>. Điều này tức là escaping dấu trích dẫn. Ví dụ:</p>

<pre class="brush: js">var quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
</pre>

<p>Kết quả của đoạn code trên là:</p>

<pre class="eval">He read "The Cremation of Sam McGee" by R.W. Service.
</pre>

<p>Để thêm một dấu backslash thật sự vào trong chuỗi, bạn phải escape dấu backslash đó. Ví dụ, để gán dường dẫn file <code>c:\temp</code> vào một chuỗi:</p>

<pre class="brush: js">var home = "c:\\temp";
</pre>

<p>Bạn cũng có thể escape các line breaks bằng cách đặt vào trước chúng một dấu backslash. Backslash và line break đều sẽ được remove khỏi giá trị của chuỗi.</p>

<pre class="brush: js">var str = "this string \
is broken \
across multiple\
lines."
console.log(str);   // this string is broken across multiplelines.
</pre>

<p>Mặc dù JavaScript không có cú pháp "heredoc", bạn có thể gần đạt được điều này bằng cách thêm vào một linebreak escape và một escaped linebreak ở cuối mỗi dòng:</p>

<pre class="brush: js">var poem =
"Roses are red,\n\
Violets are blue.\n\
I'm schizophrenic,\n\
And so am I."
</pre>

<h2 id="Thông_tin_thêm">Thông tin thêm</h2>

<p>Chương này tập trung vào cú pháp cơ bản cho các việc khai báo và các kiểu dữ liệu. Để biết rõ hơn về cấu trúc ngôn ngữ JavaScript, xem các chương tiếp theo trong bộ hướng dẫn này:</p>

<ul>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling">Control flow and error handling</a></li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration">Loops and iteration</a></li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions">Functions</a></li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">Expressions and operators</a></li>
</ul>

<p>Trong chương tiếp theo, chúng ta sẽ tìm hiểu về control flow constructs và error handling.</p>

<p>{{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}</p>
