---
title: Biểu thức và toán tử
slug: Web/JavaScript/Guide/Expressions_and_Operators
translation_of: Web/JavaScript/Guide/Expressions_and_Operators
---
<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>

<p class="summary">Chương này mô tả biểu thức và toán tử của JavaScript, bao gồm toán tử gán, toán tử so sánh, arithmetic, thao tác bit, toán tử luận lý, chuỗi, toán tử ba ngôi và nhiều hơn nữa.</p>

<p>Để xem danh sách đầy đủ và chi tiết các toán tử và biểu thức, mời truy cập vào <a href="/en-US/docs/Web/JavaScript/Reference/Operators">reference</a>.</p>

<h2 id="Toán_tử">Toán tử</h2>

<p>JavaScript có các loại toán tử như sau. Phần này mô tả về các toán tử và có bao gồm thông tin về thứ tự ưu tiên của chúng.</p>

<ul>
 <li><a href="#Toán_tử_gán">Toán tử gán</a></li>
 <li><a href="#Toán_tử_so_sánh">Toán tử so sánh</a></li>
 <li><a href="#Toán_tử_số_học">Toán tử số học</a></li>
 <li><a href="#Bitwise">Toán tử thao tác bit</a></li>
 <li><a href="#Logical">Toán tử luận lý</a></li>
 <li><a href="#String">Toán tử chuỗi</a></li>
 <li><a href="#Conditional">Toán tử điều kiện (ba ngôi)</a></li>
 <li><a href="#Comma">Toán tử phẩy</a></li>
 <li><a href="#Unary">Toán tử một ngôi</a></li>
 <li><a href="#Relational">Toán tử quan hệ</a></li>
</ul>

<p>JavaScript có cả toán tử <em>hai ngôi</em> và<em>một ngôi</em>, và một toán tử đặc biệt ba ngôi, toán tử quan hệ. Toán tử hai ngôi yêu cầu hai toán hạng, một toán hạng ở trước và một toán hạng ở sau toán tử:</p>

<pre class="syntaxbox"><em>toán_hạng_1</em> <em>toán_tử</em> <em>toán_hạng_2</em>
</pre>

<p>Chẳng hạn, <code>3+4</code> hoặc <code>x*y</code>.</p>

<p>Toán tử một ngôi yêu cầu một toán tử, ở trước hoặc ở sau toán tử:</p>

<pre class="syntaxbox"><em>toán_tử</em> <em>toán_hạng</em>
</pre>

<p>hoặc</p>

<pre class="syntaxbox"><em>toán_hạng</em> <em>toán_tử</em>
</pre>

<p>Chẳng hạn, <code>x++</code> hoặc <code>++x</code>.</p>

<h3 id="Toán_tử_gán"><a id="Assignment" name="Assignment">Toán tử gán</a></h3>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators">Toán tử gán</a> gán giá trị cho toán hạng bên trái nó dựa theo giá trị của toán hạng bên phải nó. Toná tử gán đơn giản là toán tử bằng (<code>=</code>), gán giá trị cho toán hạng bên trái nó bằng giá trị của toán hạng bên phải nó. Vậy, <code>x = y</code> tức là gán giá trị của <code>y</code> cho <code>x</code>.</p>

<p>Ngoài ra còn có các toán tử gán kết hợp được liệt kê trong bảng dưới:</p>

<table class="standard-table">
 <caption>Toán tử gán kết hợp</caption>
 <thead>
  <tr>
   <th>Tên</th>
   <th>Viết tắt</th>
   <th>Ý nghĩa</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Assignment">Toán tử gán</a></td>
   <td><code>x = y</code></td>
   <td><code>x = y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Addition_assignment">Cộng xong rồi gán</a></td>
   <td><code>x += y</code></td>
   <td><code>x = x + y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Subtraction_assignment">Trừ xong rồi gán</a></td>
   <td><code>x -= y</code></td>
   <td><code>x = x - y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Multiplication_assignment">Nhân xong rồi gán</a></td>
   <td><code>x *= y</code></td>
   <td><code>x = x * y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Division_assignment">Chia xong rồi gán</a></td>
   <td><code>x /= y</code></td>
   <td><code>x = x / y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Remainder_assignment">Chia lấy dư xong rồi gán</a></td>
   <td><code>x %= y</code></td>
   <td><code>x = x % y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Exponentiation_assignment">Luỹ thừa rồi gán</a>{{experimental_inline}}</td>
   <td><code>x **= y</code></td>
   <td><code>x = x ** y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Left_shift_assignment">Dịch bit trái rồi gán</a></td>
   <td><code>x &lt;&lt;= y</code></td>
   <td><code>x = x &lt;&lt; y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Right_shift_assignment">Dịch bit phải rồi gán</a></td>
   <td><code>x &gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Unsigned_right_shift_assignment">Dịch phải kiểu unsigned rồi gán</a></td>
   <td><code>x &gt;&gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Bitwise_AND_assignment">AND bit rồi gán</a></td>
   <td><code>x &amp;= y</code></td>
   <td><code>x = x &amp; y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Bitwise_XOR_assignment">XOR bit rồi gán</a></td>
   <td><code>x ^= y</code></td>
   <td><code>x = x ^ y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Bitwise_OR_assignment">OR bit rồi gán</a></td>
   <td><code>x |= y</code></td>
   <td><code>x = x | y</code></td>
  </tr>
 </tbody>
</table>

<h4 id="Phân_rã">Phân rã</h4>

<p>Với phép gán phức tạp hơn, cú pháp <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">phân rã rồi gán</a> là một biểu thức JavaScript cho phép phân tách dữ liệu từ mảng hoặc object sử dụng cú pháp sao chép cấu trúc của mảng hoặc object literal.</p>

<pre class="brush: js">var foo = ['one', 'two', 'three'];

// không dùng phân rã
var one   = foo[0];
var two   = foo[1];
var three = foo[2];

// dùng phân rã
var [one, two, three] = foo;</pre>

<h3 id="Toán_tử_so_sánh"><a name="Comparison">Toán tử so sánh</a></h3>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">Toán tử so sánh</a> so sánh toán hạng của nó và trả về giá trị luận lý dựa theo tính đúng sai của phép so sánh. Toán hạng có thể thuộc là số, chuỗi, luận lý, hoặc object. Chuỗi được so sánh theo thứ tự từ điển, qua giá trị mã Unicode. Trong nhiều trường hợp, nếu hai toán hạng không cùng kiểu, JavaScript sẽ tự động ép kiểu sao cho phù hợp. Hành vi này thường xảy ra khi so sánh dữ liệu kiểu số. Duy có hai toán tử so sánh, bao gồm <code>===</code> và <code>!==</code>, không tự động ép kiểu mà sẽ so sánh bằng chính xác. Bảng sau mô tả các toán tử so sánh bao gồm cả code mẫu:</p>

<pre class="brush: js">var var1 = 3;
var var2 = 4;
</pre>

<table class="standard-table">
 <caption>Toán tử so sánh</caption>
 <thead>
  <tr>
   <th scope="col">Toán tử</th>
   <th scope="col">Mô tả</th>
   <th scope="col">Ví dụ trả về true/th&gt;</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality">Bằng</a> (<code>==</code>)</td>
   <td>Trả về <code>true</code> nếu các toán hạng bằng nhau.</td>
   <td><code>3 == var1</code>
    <p><code>"3" == var1</code></p>
    <code>3 == '3'</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Inequality">Không bằng</a> (<code>!=</code>)</td>
   <td>Trả về <code>true</code> nếu các toán hạng không bằng nhau.</td>
   <td><code>var1 != 4<br>
    var2 != "3"</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity">Bằng chính xác</a> (<code>===</code>)</td>
   <td>Trả về <code>true</code> nếu các toán hạng bằng nhau và cùng kiểu. Xem thêm tại {{jsxref("Object.is")}} và <a href="/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" title="/en-US/docs/Web/JavaScript/Guide/Sameness">sameness in JS</a>.</td>
   <td><code>3 === var1</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Nonidentity">Không bằng chính xác</a> (<code>!==</code>)</td>
   <td>Trả về <code>true</code> nếu các toán hạng không bằng nhau, hoặc khác kiểu.</td>
   <td><code>var1 !== "3"<br>
    3 !== '3'</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Greater_than_operator">Lớn hơn</a> (<code>&gt;</code>)</td>
   <td>Trả về <code>true</code> nếu toán hạng bên trái lớn hơn toán hạng bên phải.</td>
   <td><code>var2 &gt; var1<br>
    "12" &gt; 2</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Greater_than_or_equal_operator">Lớn hơn hoặc bằng</a> (<code>&gt;=</code>)</td>
   <td>Trả về <code>true</code> nếu toán hạng bên trái lớn hơn hoặc bằng toán hạng bên phải.</td>
   <td><code>var2 &gt;= var1<br>
    var1 &gt;= 3</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than_operator">Nhỏ hơn</a> (<code>&lt;</code>)</td>
   <td>Trả về <code>true</code> nếu toán hạng bên trái nhỏ hơn toán hạng bên phải.</td>
   <td><code>var1 &lt; var2<br>
    "2" &lt; 12</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Less_than_or_equal_operator">Nhỏ hơn hoặc bằng</a> (<code>&lt;=</code>)</td>
   <td>Trả về <code>true</code> nếu toán hạng bên trái ?nhỏ hơn hoặc bằng toán hạng bên phải.</td>
   <td><code>var1 &lt;= var2<br>
    var2 &lt;= 5</code></td>
  </tr>
 </tbody>
</table>

<div class="note">
<p><strong>Lưu ý: </strong>(<strong>=&gt;</strong>) không phải là toán tử, mà là cú pháp của <a href="/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Hàm mũi tên</a>.</p>
</div>

<h3 id="Toán_tử_số_học"><a name="Arithmetic">Toán tử số học</a></h3>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators">Toán tử số học</a> nhận giá trị kiểu số (cả literal lẫn biến) là toán hạng của nó và trả về một giá trị kiểu số. Các toán tử số học thông thường là toán tử cộng (<code>+</code>), trừ (<code>-</code>), nhân (<code>*</code>), và chia (<code>/</code>). Những toán tử này hoạt động tương tự như trong các ngôn ngữ lập trình khác khi xử lý với số thực dấu phẩy động (nói chung, ?phép chia cho 0 sẽ trả về {{jsxref("Infinity")}}). Ví dụ:</p>

<pre class="brush: js">1 / 2; // 0.5
1 / 2 == 1.0 / 2.0; // this is true
</pre>

<p>Ngoài những toán tử số học thông thường (+, -, * /), JavaScript cung cấp thêm các toán tử số học được liệt kê trong bảng sau:</p>

<table class="fullwidth-table">
 <caption>Toán tử số học</caption>
 <thead>
  <tr>
   <th scope="col">Toán tử</th>
   <th scope="col">Mô tả</th>
   <th scope="col">Ví dụ</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder">Chia lấy dư</a> (<code>%</code>)</td>
   <td>Toán tử hai ngôi. Trả về phần nguyên trong phép chia của hai toán hạng.</td>
   <td>12 % 5 trả về 2.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment">Tăng</a> (<code>++</code>)</td>
   <td>Toán tử một ngôi. Cộng thêm một đơn vị cho toán hạng. Nếu dùng như tiền tố (<code>++x</code>), trả về giá trị sau khi cộng thêm một; nếu dùng như hậu tố (<code>x++</code>), trả về giá trị trước khi cộng thêm một.</td>
   <td>Nếu <code>x</code> bằng 3, rồi <code>++x</code> sẽ thiết lập giá trị của <code>x</code> lên 4 và trả về 4, trong khi <code>x++</code> trả về 3 và sau đó mới thiết lập giá trị của <code>x</code> lên 4.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Decrement">Giảm</a> (<code>--</code>)</td>
   <td>Toán tử một ngôi. Trừ đi một đơn vị cho toán hạng. Giá trị trả về tương tự như toán tử tăng.</td>
   <td>Nếu <code>x</code> bằng 3, rồi <code>--x</code> sẽ thiết lập giá trị của <code>x</code> về 2 và trả về 2, trong khi <code>x--</code> trả về 3 và sau đó mới thiết lập giá trị của <code>x</code> về 2.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_negation">Phủ định một ngôi</a> (<code>-</code>)</td>
   <td>Toán tử một ngôi. Trả về giá trị phủ định của toán hạng.</td>
   <td>Nếu <code>x</code> bằng 3, thì <code>-x</code> trả về -3.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus">Cộng một ngôi</a> (<code>+</code>)</td>
   <td>Toán tử một ngôi. Ép kiểu toán hạng về dạng số học, nếu kiểu của toán hạng đó không phải là số.</td>
   <td><code>+"3"</code> trả về <code>3</code>.<br>
    <code>+true</code> trả về <code>1.</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Exponentiation">Toán tử luỹ thừa</a> (<code>**</code>) {{experimental_inline}}</td>
   <td>Tính toán giá trị <code>cơ số</code> theo <code>luỹ thừa</code> số mũ, tức là, <code>cơ số<sup>số mũ</sup></code></td>
   <td><code>2 ** 3</code> trả về <code>8</code>.<br>
    <code>10 ** -1</code> trả về <code>0.1</code>.</td>
  </tr>
 </tbody>
</table>

<h3 id="Toán_tử_thao_tác_bit"><a id="Bitwise" name="Bitwise">Toán tử thao tác bit</a></h3>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">Toán tử thao tác bit</a> coi toán hạng của nó là một tập 32 bit (gồm 0 và 1), thay vì là kiểu thập phân, thập lục phân, hay bát phân. Chẳng hạn, số thập phân 9 được biểu diễn trong hệ nhị phân là 1001. Toán tử thao tác bit xử lý phép toán dựa theo dạng biểu diễn nhị phân ấy, nhưng trả về giá trị kiểu số thông thường trong JavaScript.</p>

<p>Bảng tóm tắt các toán tử thao tác bit của JavaScript.</p>

<table class="standard-table">
 <caption>Toán tử thao tác bit</caption>
 <thead>
  <tr>
   <th scope="col">Toán tử</th>
   <th scope="col">Cách dùng</th>
   <th scope="col">Mô tả</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_AND">Toán tử AND bit</a></td>
   <td><code>a &amp; b</code></td>
   <td>trả về a one in each bit position for which the corresponding bits of both operands are ones.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_OR">Toán tử OR bit</a></td>
   <td><code>a | b</code></td>
   <td>trả về a zero in each bit position for which the corresponding bits of both operands are zeros.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_XOR">Toán tử XOR bit</a></td>
   <td><code>a ^ b</code></td>
   <td>trả về a zero in each bit position for which the corresponding bits are the same.<br>
    [trả về a one in each bit position for which the corresponding bits are different.]</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT">Toán tử NOT bit</a></td>
   <td><code>~ a</code></td>
   <td>Inverts the bits of its operand.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Left_shift">Dịch trái</a></td>
   <td><code>a &lt;&lt; b</code></td>
   <td>Shifts <code>a</code> in binary representation <code>b</code> bits to the left, shifting in zeros from the right.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Right_shift">Dịch phải giữ nguyên dấu</a></td>
   <td><code>a &gt;&gt; b</code></td>
   <td>Shifts <code>a</code> in binary representation <code>b</code> bits to the right, discarding bits shifted off.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Unsigned_right_shift">Dịch phải với 0</a></td>
   <td><code>a &gt;&gt;&gt; b</code></td>
   <td>Shifts <code>a</code> in binary representation <code>b</code> bits to the right, discarding bits shifted off, and shifting in zeros from the left.</td>
  </tr>
 </tbody>
</table>

<h4 id="Bitwise_Logical_Operators" name="Bitwise_Logical_Operators">Toán tử luận lý bit</h4>

<p>Về lý thuyết, cơ chế hoạt động của toán tử luận lý bit được giải thích như sau:</p>

<ul>
 <li>Toán hạng được chuyển đổi về dạng số nguyên 32-bit và biểu diễn bằng một dãy bit (0 và 1). Số dài hơn 32 bit sẽ bị cắt đi một số bit. Chẳng hạn, số nguyên sau đây, dài hơn 32 bit sẽ được chuyển đổi về dạng số nguyên 32 bit:
  <pre>Trước: 11100110111110100000000000000110000000000001
Sau:               10100000000000000110000000000001</pre>
 </li>
 <li>Mỗi bit của toán hạng thứ nhất sẽ dóng với bit tương ứng của toán hạng thứ hai.</li>
 <li>Toán tử sẽ áp dụng với từng cặp bit và trả.</li>
</ul>

<p>Chẳng hạn, biểu diễn nhị phân của 9 là 1001, và biểu diễn nhị phân của 15 là 1111. Vậy nếu áp dụng toán tử luận lý bit vào các giá trị này, thì kết quả trả về sẽ được như trong bảng sau:</p>

<table class="standard-table">
 <caption>Ví dụ về toán tử thao tác bit</caption>
 <thead>
  <tr>
   <th scope="col">Biểu thức</th>
   <th scope="col">Kết quả</th>
   <th scope="col">Mô tả nhị phân</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>15 &amp; 9</code></td>
   <td><code>9</code></td>
   <td><code>1111 &amp; 1001 = 1001</code></td>
  </tr>
  <tr>
   <td><code>15 | 9</code></td>
   <td><code>15</code></td>
   <td><code>1111 | 1001 = 1111</code></td>
  </tr>
  <tr>
   <td><code>15 ^ 9</code></td>
   <td><code>6</code></td>
   <td><code>1111 ^ 1001 = 0110</code></td>
  </tr>
  <tr>
   <td><code>~15</code></td>
   <td><code>-16</code></td>
   <td><code>~</code><code>00000000...</code><code>00001111 = </code><code>1111</code><code>1111</code><code>...</code><code>11110000</code></td>
  </tr>
  <tr>
   <td><code>~9</code></td>
   <td><code>-10</code></td>
   <td><code>~</code><code>00000000</code><code>...</code><code>0000</code><code>1001 = </code><code>1111</code><code>1111</code><code>...</code><code>1111</code><code>0110</code></td>
  </tr>
 </tbody>
</table>

<p>Chú ý: tất cả 32 bit được đảo ngược bởi toán tử luận lý NOT có bit trái nhất đặt thành 1 để biểu diễn số âm (biểu diễn bù hai). <code>~x</code> thực thi ra cùng một kết quả như <code>-x - 1</code>.</p>

<h4 id="Bitwise_Shift_Operators" name="Bitwise_Shift_Operators">Toán tử dịch bit</h4>

<p>Toán tử dịch bit nhận hai toán hạng: toán hạng thứ nhất là số lượng bit được dịch, còn toán hạng thứ hai chỉ ra vị trí bit để bắt đầu dịch. Hướng dịch bit phụ thuộc vào toán tử được sử dụng.</p>

<p>Toán tử dịch bit chuyển đổi toán hạng của nó thành dạng số nguyên 32-bit và trả về kết quả cùng kiểu với toán hạng bên trái.</p>

<p>Toán tử dịch bit được liệt kê theo danh sách sau.</p>

<table class="fullwidth-table">
 <caption>Toán tử dịch bit</caption>
 <thead>
  <tr>
   <th scope="col">Toán tử</th>
   <th scope="col">Mô tả</th>
   <th scope="col">Ví dụ</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#&lt;&lt;_(Left_shift)">Dịch trái</a><br>
    (<code>&lt;&lt;</code>)</td>
   <td>Dịch toán hạng thứ nhất theo một lượng bằng toán hạng thứ hai sang trái. Các bit dịch trái bị tràn sẽ bị loại bỏ. Các bit 0 được dịch vào từ bên phải.</td>
   <td><code>9&lt;&lt;2</code> trả về 36, bởi vì 1001 dịch 2 bit sang trái sẽ thành 100100, tương ứng với 36.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#>>_(Sign-propagating_right_shift)">Dịch phải bit giữ nguyên dấu</a> (<code>&gt;&gt;</code>)</td>
   <td>Dịch toán hạng thứ nhất theo một lượng bằng toán hạng thứ hai sang phải. Các bit dịch phải bị tràn sẽ bị loại bỏ. Bản sao của bit trái nhất được dịch vào từ trái.</td>
   <td><code>9&gt;&gt;2</code> trả về 2, bởi vì 1001 dịch 2 bit sang phải sẽ thành 10, tương ứng với 2. Tương tự, <code>-9&gt;&gt;2</code> trả về -3, bởi vì dấu vẫn được giữ nguyên.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#>>>_(Zero-fill_right_shift)">Dịch phải bit với 0</a> (<code>&gt;&gt;&gt;</code>)</td>
   <td>Dịch toán hạng thứ nhất theo một lượng bằng toán hạng thứ hai sang phải. Các bit dịch phải bị tràn sẽ bị loại bỏ. Bit 0 được dịch vào từ trái sang.</td>
   <td><code>19&gt;&gt;&gt;2</code> trả về 4, bởi vì 10011 dịch 2 bit sang phải sẽ thành 100, tương ứng với 4. Với số không âm, toán tử này tương tự với dịch phải giữ nguyên dấu.</td>
  </tr>
 </tbody>
</table>

<h3 id="Toán_tử_luận_lý"><a id="Logical" name="Logical">Toán tử luận lý</a></h3>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators">Toán tử logic</a> thường được dùng với giá trị Boolean (kiểu logic); khi đó, chúng trả về giá trị Boolean. Tuy nhiên, toán tử <code>&amp;&amp;</code> và <code>||</code> thực tế trả về giá trị của một trong những toán hạng xác định, nên nếu hai toán tử này được dùng với giá trị không phải kiểu Boolean, chúng có thể trả về một giá trị không phải Boolean. Toán tử logic được mô tả trong bảng dưới.</p>

<table class="fullwidth-table">
 <caption>Toán tử logic</caption>
 <thead>
  <tr>
   <th scope="col">Toán tử</th>
   <th scope="col">Cách dùng</th>
   <th scope="col">Mô tả</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_AND">Logic AND</a><code> </code>(<code>&amp;&amp;</code>)</td>
   <td><code>expr1 &amp;&amp; expr2</code></td>
   <td>Trả về <code>expr1</code> nếu nó có thể biến đổi thành <code>false</code>; ngược lại, trả về <code>expr2</code>. Như vậy, khi dùng với giá trị Boolean, <code>&amp;&amp;</code> trả về <code>true</code> nếu cả hai toán hạng đều là true; ngược lại, trả về <code>false</code>.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_OR">Logic OR </a>(<code>||</code>)</td>
   <td><code>expr1 || expr2</code></td>
   <td>Trả về <code>expr1</code> nếu nó có thể biến đổi thành <code>true</code>; ngược lại, trả về <code>expr2</code>. Vì vậy, khi dùng với giá trị Boolean, <code>||</code> trả về <code>true</code> nếu cả hai toán hạng đều là true; nếu cả hai false, trả về <code>false</code>.</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_NOT">Logic NOT </a>(<code>!</code>)</td>
   <td><code>!expr</code></td>
   <td>Trả về <code>false</code> nếu toán hạng đứng ngay sau nó có thể biến đổi thành <code>true</code>; ngược lại, trả về <code>true</code>.</td>
  </tr>
 </tbody>
</table>

<p>Ví dụ về các biểu thức có thể biến đổi thành <code>false</code> là những biểu thức khi thực thi trả về null, 0, NaN, chuỗi rỗng (""), hoặc undefined.</p>

<p>Sau đây là các ví dụ cho toán tử <code>&amp;&amp;</code> (luận lý AND).</p>

<pre class="brush: js">var a1 =  true &amp;&amp; true;     // t &amp;&amp; t trả về true
var a2 =  true &amp;&amp; false;    // t &amp;&amp; f trả về false
var a3 = false &amp;&amp; true;     // f &amp;&amp; t trả về false
var a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f trả về false
var a5 = 'Cat' &amp;&amp; 'Dog';    // t &amp;&amp; t trả về Dog
var a6 = false &amp;&amp; 'Cat';    // f &amp;&amp; t trả về false
var a7 = 'Cat' &amp;&amp; false;    // t &amp;&amp; f trả về false
</pre>

<p>Sau đây là các ví dụ cho toán tử || (luận lý OR).</p>

<pre class="brush: js">var o1 =  true || true;     // t || t trả về true
var o2 = false || true;     // f || t trả về true
var o3 =  true || false;    // t || f trả về true
var o4 = false || (3 == 4); // f || f trả về false
var o5 = 'Cat' || 'Dog';    // t || t trả về Cat
var o6 = false || 'Cat';    // f || t trả về Cat
var o7 = 'Cat' || false;    // t || f trả về Cat
</pre>

<p>Sau đây là các ví dụ cho toán tử ! (luận lý NOT).</p>

<pre class="brush: js">var n1 = !true;  // !t trả về false
var n2 = !false; // !f trả về true
var n3 = !'Cat'; // !t trả về false
</pre>

<h4 id="Short-Circuit_Evaluation" name="Short-Circuit_Evaluation">Thực thi đoản-mạch</h4>

<p>Vì các biểu thức luận lý được thực thi từ trái sang phải, ta có thể dùng chúng để thử tính "đoán-mạch" qua các quy định sau:</p>

<ul>
 <li><code>false</code> &amp;&amp; <em>bất cứ gì</em> là thực thi đoản-mạch ra false.</li>
 <li><code>true</code> || <em>bất cứ gì</em> là thực thi đoản-mạch ra true.</li>
</ul>

<p>Quy định luận lý đảm bảo rằng các thực thi trên luôn đúng. Chú ý phần <em>bất cứ gì</em> trong các biểu thức trên không được thực thi, bởi vậy sẽ không xảy ra bất cứ tác dụng phụ nào.</p>

<h3 id="Toán_tử_chuỗi"><a id="String" name="String">Toán tử chuỗi</a></h3>

<p>Ngoài toán tử so sánh, có thể dùng để so sánh chuỗi, toán tử ghép (+) ghép hai giá trị chuỗi lại với nhau, trả về một chuỗi mới là hợp của hai chuỗi cũ.</p>

<p>Chẳng hạn,</p>

<pre class="brush: js">console.log('my ' + 'string'); // console logs the string "my string".</pre>

<p>Toán tử gán rút gọn += cũng có thể dùng để ghép chuỗi.</p>

<p>Chẳng hạn,</p>

<pre class="brush: js">var mystring = 'alpha';
mystring += 'bet'; // "alphabet" sẽ ghép với giá trị này trước khi gán vào mystring.</pre>

<h3 id="Toán_tử_điều_kiện_(ba_ngôi)"><a id="Conditional" name="Conditional">Toán tử điều kiện (ba ngôi)</a></h3>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">Toán tử điều kiện</a> là toán tử duy nhất của JavaScript cần tới ba toán hạng. Kết quả có thể là một trong hai giá trị tuỳ theo điều kiện. Cú pháp:</p>

<pre class="syntaxbox"><em>điều_kiện</em> ? <em>giá_trị_1</em> : <em>giá_trị_2</em>
</pre>

<p>Nếu <code>điều_kiện</code> trả về true, toán tử có giá trị <code>giá_trị_1</code>. Ngược lại toán tử có giá trị <code>giá_trị_2</code>. Bạn có thể dùng toán tử điều kiện ở bất cứ đâu như một toán tử bình thường.</p>

<p>Chẳng hạn,</p>

<pre class="brush: js">var status = (age &gt;= 18) ? 'adult' : 'minor';
</pre>

<p>Đoạn code này gán giá trị "adult" cho biến <code>status</code> nếu <code>age</code> lớn hơn hoặc bằng 18. Ngược lại, nó gán giá trị "minor" cho <code>status</code>.</p>

<h3 id="Comma_operator" name="Comma_operator"><a name="Comma">Toán tử dấu phẩy</a></h3>

<p>Toán tử <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator">dấu phẩy</a> (<code>,</code>) đơn thuần tính toán cả hai giá trị toán hạng của nó và trả về giá trị của toán hạng cuối. Toán tử này được dùng chủ yếu trong vòng lặp <code>for</code>, để cho phép cập nhật nhiều biến cùng lúc sau mỗi lần thực hiện vòng lặp.</p>

<p>Chẳng hạn, nếu <code>a</code> là một mảng 2-chiều với 10 phần tử mỗi chiều, đoạn code sau dùng toán tử dấu phẩy để cập nhật hai biến cùng một lúc. Console in ra giá trị của các phần tử nằm trong đường chéo:</p>

<pre class="brush: js">var x = [0,1,2,3,4,5,6,7,8,9]
var a = [x, x, x, x, x];

for (var i = 0, j = 9; i &lt;= j; i++, j--)
  console.log('a[' + i + '][' + j + ']= ' + a[i][j]);
</pre>

<h3 id="Toán_tử_một_ngôi"><a id="Unary" name="Unary">Toán tử một ngôi</a></h3>

<p>Toán tử một ngôi là phép toán chỉ có duy nhất một toán hạng.</p>

<h4 id="delete" name="delete"><code>delete</code></h4>

<p>Toán tử <code><a href="/en-US/docs/Web/JavaScript/Reference/Operators/delete">delete</a></code> xoá một object, một thuộc tính của object, hoặc một phần tử ở chỉ mục xác định trong mảng. Cú pháp là:</p>

<pre class="brush: js">delete objectName;
delete objectName.property;
delete objectName[index];
delete property; // chỉ được khi cài trong lệnh with
</pre>

<p>Với <code>objectName</code> là tên của object, <code>property</code> là thuộc tính đang tồn tại, và <code>index</code> là giá trị nguyên của chỉ mục tương ứng với vị trí của thuộc tính trong mảng.</p>

<p>Dạng thứ tư chỉ hoạt động khi được cài trong lệnh <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/with">with</a></code>, để xoá một thuộc tính khỏi object.</p>

<p>Bạn có thể dùng toán tử <code>delete</code> để xoá biến được khởi tạo ngầm nhưng không thể xoá được các biến được khởi tạo bằng lệnh <code>var</code>.</p>

<p>Nếu toán tử <code>delete</code> thành công, nó đặt thuộc tính hoặc phần tử đó thành <code>undefined</code>. Toán tử <code>delete</code> trả về <code>true</code> nếu phép toán khả thi; nó trả về <code>false</code> nếu phép toán bất khả thi.</p>

<pre class="brush: js">x = 42;
var y = 43;
myobj = new Number();
myobj.h = 4;    // tạo thuộc tính h
delete x;       // trả về true (có thể xoá nếu khởi tạo ngầm)
delete y;       // trả về false (không thể xoá nếu khởi tạo bằng var)
delete Math.PI; // trả về false (không thể xoá thuộc tính tiền định nghĩa)
delete myobj.h; // trả về true (có thể xoá thuộc tính người dùng định nghĩa)
delete myobj;   // trả về true (có thể xoá nếu khợi tạo ngầm)
</pre>

<h5 id="Xoá_phần_tử_mảng">Xoá phần tử mảng</h5>

<p>Khi bạn xoá một phần tử của mảng, chiều dài mảng không bị ảnh hưởng. Chẳng hạn, nếu bạn xoá <code>a[3]</code>, <code>a[4]</code> vẫn là <code>a[4]</code> và <code>a[3]</code> là undefined.</p>

<p>Khi toán tử <code>delete</code> loại bỏ một phần tử khỏi mảng, phần tử đó không còn tồn tại trong mảng. Trong ví dụ sau, <code>trees[3]</code> đã được loại bỏ bởi <code>delete</code>. Tuy nhiên, <code>trees[3]</code> vẫn có thể được trỏ tới và trả về <code>undefined</code>.</p>

<pre class="brush: js">var trees = ['redwood', 'bay', 'cedar', 'oak', 'maple'];
delete trees[3];
if (3 in trees) {
  // sẽ không chạy vào đây
}
</pre>

<p>Nếu bạn muốn kiểm tra sự tồn tại của một phần tử trong mảng nhưng có giá trị là undefined, hãy dùng từ khoá <code>undefined</code> thay cho toán tử <code>delete</code>. Trong ví dụ tiếp sau đây, <code>trees[3]</code> được gán giá trị <code>undefined</code>, nhưng phần tử của mảng vẫn tồn tại:</p>

<pre class="brush: js">var trees = ['redwood', 'bay', 'cedar', 'oak', 'maple'];
trees[3] = undefined;
if (3 in trees) {
  // sẽ chạy vào đây
}
</pre>

<h4 id="typeof" name="typeof"><code>typeof</code></h4>

<p>Toán tử <a href="/en-US/docs/Web/JavaScript/Reference/Operators/typeof"><code>typeof</code></a> có thể dùng theo cả hai cách dưới đây:</p>

<pre class="syntaxbox">typeof operand
typeof (operand)
</pre>

<p>Toán tử <code>typeof</code> trả về một chuỗi ký tự thể hiện kiểu của toán hạng. <code>operand</code> có thể là chuỗi ký tự, biến, từ khoá, hoặc object cần xác định kiểu. Không bắt buộc phải thêm dấu ngoặc tròn.</p>

<p>Giả sử bạn có các biến sau:</p>

<pre class="brush: js">var myFun = new Function('5 + 2');
var shape = 'round';
var size = 1;
var foo = ['Apple', 'Mango', 'Orange'];
var today = new Date();
</pre>

<p>Toán tử <code>typeof</code> trả về kết quả lần lượt cho từng biến:</p>

<pre class="brush: js">typeof myFun;       // trả về "function"
typeof shape;       // trả về "string"
typeof size;        // trả về "number"
typeof foo;         // trả về "object"
typeof today;       // trả về "object"
typeof doesntExist; // trả về "undefined"
</pre>

<p>Với từ khoá <code>true</code> và <code>null</code>, toán tử <code>typeof</code> trả về kết quả sau:</p>

<pre class="brush: js">typeof true; // trả về "boolean"
typeof null; // trả về "object"
</pre>

<p>Với số hoặc chuỗi ký tự, toán tử <code>typeof</code> trả về kết quả sau:</p>

<pre class="brush: js">typeof 62;            // trả về "number"
typeof 'Hello world'; // trả về "string"
</pre>

<p>Với giá trị thuộc tính, toán tử <code>typeof</code> trả về kiểu dữ liệu mà thuộc tính đó bao hàm:</p>

<pre class="brush: js">typeof document.lastModified; // trả về "string"
typeof window.length;         // trả về "number"
typeof Math.LN2;              // trả về "number"
</pre>

<p>Với phương thức hoặc hàm, toán tử <code>typeof</code> trả về kết quả như sau:</p>

<pre class="brush: js">typeof blur;        // trả về "function"
typeof eval;        // trả về "function"
typeof parseInt;    // trả về "function"
typeof shape.split; // trả về "function"
</pre>

<p>Với các object tiền định nghĩa, toán tử <code>typeof</code> trả về kết quả như sau:</p>

<pre class="brush: js">typeof Date;     // trả về "function"
typeof Function; // trả về "function"
typeof Math;     // trả về "object"
typeof Option;   // trả về "function"
typeof String;   // trả về "function"
</pre>

<h4 id="void" name="void"><code>void</code></h4>

<p>Toán tử <a href="/en-US/docs/Web/JavaScript/Reference/Operators/void"><code>void</code> operator</a> có thể dùng theo cả hai cách dưới đây:</p>

<pre class="syntaxbox">void (expression)
void expression
</pre>

<p>Toán tử <code>void</code> xác định biểu thực cần thực hiện mà không trả về giá trị nào. <code>expression</code> là một biểu thức JavaScript cần thực hiện. Dấu ngoặc tròn bao quanh expression là không bắt buộc, nhưng sẽ rất phong cách nếu dùng chúng.</p>

<p>Bạn có thể dùng toán tử <code>void</code> để xác định biểu thức cần thực thi trong một siêu liên kết. Biểu thức sẽ được thực hiện nhưng không văn bản hiện tại sẽ không tải lại tại chỗ.</p>

<p>Đoạn code sau tạo ra một siêu liên kết không thực hiện bất cứ điều gì khi có người dùng nhấn vào. Khi người dùng nhấn vào, <code>void(0)</code> thực hiện thành <code>undefined</code>, vốn không có hiệu ứng gì trong JavaScript.</p>

<pre class="brush: html">&lt;a href="javascript:void(0)"&gt;Click here to do nothing&lt;/a&gt;
</pre>

<p>Đoạn code sẽ tiến hành hoàn tất mẫu đơn khi người dùng bấm vào siêu liên kết.</p>

<pre class="brush: html">&lt;a href="javascript:void(document.form.submit())"&gt;
Click here to submit&lt;/a&gt;</pre>

<h3 id="Toán_tử_quan_hệ"><a name="Relational">Toán tử quan hệ</a></h3>

<p>Toán tử quan hệ so sánh các toán hạng của nó và trả về giá trị <code>Boolean</code> tuỳ thuộc phép so sánh có true hay không.</p>

<h4 id="in"><code>in</code></h4>

<p>Toán tử <a href="/en-US/docs/Web/JavaScript/Reference/Operators/in"><code>in</code></a> trả về <code>true</code> nếu thuộc tính nhất định có trong object nhất định. Cú pháp là:</p>

<pre class="brush: js">propNameOrNumber in objectName
</pre>

<p>với <code>propNameOrNumber</code> là chuỗi ký tự hoặc số đại diện cho tên của thuộc tính hoặc chỉ mục mảng, và <code>objectName</code> là tên của object.</p>

<p>Các ví dụ dưới đây chỉ ra vài cách dùng toán tử <code>in</code>.</p>

<pre class="brush: js">// Arrays
var trees = ['redwood', 'bay', 'cedar', 'oak', 'maple'];
0 in trees;        // trả về true
3 in trees;        // trả về true
6 in trees;        // trả về false
'bay' in trees;    // trả về false (bạn phải xác định được chỉ mục của mảng,
                   // không phải giá trị tại vị trí chỉ mục đó)
'length' in trees; // trả về true (length là một thuộc tính của Array)

// object dựng sẵn
'PI' in Math;          // trả về true
var myString = new String('coral');
'length' in myString;  // trả về true

// object tự tạo
var mycar = { make: 'Honda', model: 'Accord', year: 1998 };
'make' in mycar;  // trả về true
'model' in mycar; // trả về true
</pre>

<h4 id="instanceof" name="instanceof"><code>instanceof</code></h4>

<p>Toán tử <a href="/en-US/docs/Web/JavaScript/Reference/Operators/instanceof"><code>instanceof</code></a> trả về <code>true</code> nếu một object nhất định có kiểu của object nhất định. Cú pháp là:</p>

<pre class="syntaxbox">objectName instanceof objectType
</pre>

<p>với <code>objectName</code> là tên của object để so sánh với <code>objectType</code>, và <code>objectType</code> là kiểu của object, như là {{jsxref("Date")}} hay {{jsxref("Array")}}.</p>

<p>Dùng <code>instanceof</code> khi bạn cần xác nhận kiểu của một object trong runtime (thời gian chạy). Chẳng hạn, khi bắt ngoại lệ, bạn có thể tìm tới từng ngoại lệ riêng biện tuỳ thuộc vào kiểu ngoại lệ được quăng (throw) ra.</p>

<p>Chẳng hạn, đoạn code dưới đây dùng <code>instanceof</code> để xác định xem liệu <code>theDay</code> có phải là một <code>Date</code> object hay không. Bởi vì <code>theDay</code> là một <code>Date</code> object, các lệnh trong sau điều kiện <code>if</code> được thực thi.</p>

<pre class="brush: js">var theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // lệnh sẽ được thực thi
}
</pre>

<h3 id="Thứ_tự_thực_hiện_toán_tử">Thứ tự thực hiện toán tử</h3>

<p><em>Thứ tự thực hiện</em> của toán tử xác định thứ tự thực hiện trong một biểu thức. Bạn có thể vượt quyền ưu tiên bằng cách dùng dấu ngoặc tròn.</p>

<p>Bảng sau chỉ ra thứ tự thực hiện toán tử, từ cao nhất tới thấp nhất.</p>

<table class="standard-table">
 <caption>Thứ tự thực hiện các toán tử</caption>
 <thead>
  <tr>
   <th scope="col">?Loại toán tử</th>
   <th scope="col">Individual operators</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>member</td>
   <td><code>. []</code></td>
  </tr>
  <tr>
   <td>gọi / tạo mới instance</td>
   <td><code>() new</code></td>
  </tr>
  <tr>
   <td>phủ định/tăng</td>
   <td><code>! ~ - + ++ -- typeof void delete</code></td>
  </tr>
  <tr>
   <td>nhân/chia</td>
   <td><code>* / %</code></td>
  </tr>
  <tr>
   <td>cộng/trừ</td>
   <td><code>+ -</code></td>
  </tr>
  <tr>
   <td>dịch bit</td>
   <td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
  </tr>
  <tr>
   <td>quan hệ</td>
   <td><code>&lt; &lt;= &gt; &gt;= in instanceof</code></td>
  </tr>
  <tr>
   <td>bằng</td>
   <td><code>== != === !==</code></td>
  </tr>
  <tr>
   <td>bitwise-and</td>
   <td><code>&amp;</code></td>
  </tr>
  <tr>
   <td>bitwise-xor</td>
   <td><code>^</code></td>
  </tr>
  <tr>
   <td>bitwise-or</td>
   <td><code>|</code></td>
  </tr>
  <tr>
   <td>logical-and</td>
   <td><code>&amp;&amp;</code></td>
  </tr>
  <tr>
   <td>logical-or</td>
   <td><code>||</code></td>
  </tr>
  <tr>
   <td>điều kiện</td>
   <td><code>?:</code></td>
  </tr>
  <tr>
   <td>gán</td>
   <td><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=</code></td>
  </tr>
  <tr>
   <td>?dấu phẩy</td>
   <td><code>,</code></td>
  </tr>
 </tbody>
</table>

<p>Bảng thứ tự thực hiện chi tiết hơn có thể tìm được trong <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">JavaScript Reference</a>.</p>

<h2 id="Biểu_thức">Biểu thức</h2>

<p><em>Biểu thức</em> là đơn vị code hợp lệ mà giải được ra một giá trị.</p>

<p>Mọi biểu thức đúng cú pháp đều trả về vài giá trị nào đó nhưng về mặt lý thuyết, có hai kiểu biểu thức: kèm tác dụng phụ (chẳng hạn: những biểu thức gán giá trị cho biến nào đó) và những biểu thức thực hiện gì đấy rồi trả về giá trị.</p>

<p>Biểu thức <code>x = 7</code> là ví dụ cho kiểu thứ nhất. Biểu thức này dùng <em>toán tử =</em> để gán giá trị cho biến <code>x</code>. Tự biểu thức trả về 7.</p>

<p>Đoạn code <code>3 + 4</code> là ví dụ cho kiểu biểu thức thứ hai. Biểu thức này dùng toán tử + để thêm bốn vào ba mà không gán kết quả, bảy, cho một biến nào.<br>
 <br>
 JavaScript có các loại biểu thức sau đây:</p>

<ul>
 <li>Số học: tính toán thành một số, chẳng hạn 3.14159. (Thường dùng với <a href="#Arithmetic">toán tử số học</a>.)</li>
 <li>Chuỗi ký tự: tính toán thành một chuỗi ký tự, chẳng hạn, "Fred" hoặc "234". (Thường dùng với <a href="#String">toán tử chuỗi</a>.)</li>
 <li>Logic: tính toán thành true hoặc false. (Thường đi cùng với <a href="#Logical">toán tử luận lý</a>.)</li>
 <li>Biểu thức nguyên thuỷ: Từ khoá căn bản và biểu thức chung trong JavaScript.</li>
 <li>Biểu thức vế-trái: Giá trị bên trái là đích của phép gán.</li>
</ul>

<h3 id="Biểu_thức_nguyên_thuỷ">Biểu thức nguyên thuỷ</h3>

<p>Từ khoá căn bản và biểu thức chung trong JavaScript.</p>

<h4 id="this" name="this"><code>this</code></h4>

<p>Dùng từ khoá <a href="/en-US/docs/Web/JavaScript/Reference/Operators/this"><code>this</code></a> để trỏ đến object hiện tại. Tổng quát, <code>this</code> trỏ tới object đang gọi trong một phương thức. Có thể dùng <code>this</code> cùng với dấu chấm hoặc dấu ngoặc vuông:</p>

<pre class="syntaxbox">this['propertyName']
this.propertyName
</pre>

<p>Giả sử hàm <code>validate</code> xác thực thuộc tính <code>value</code> của object, truyền vào cận trên và cận dưới của nó:</p>

<pre class="brush: js">function validate(obj, lowval, hival) {
  if ((obj.value &lt; lowval) || (obj.value &gt; hival))
    console.log('Invalid Value!');
}
</pre>

<p>Bạn có thể gọi <code>validate</code> trong mỗi bộ xử lý sự kiện <code>onChange</code> trong form, dùng <code>this</code> để truyền vào phần tử của form, như trong ví dụ sau:</p>

<pre class="brush: html">&lt;p&gt;Enter a number between 18 and 99:&lt;/p&gt;
&lt;input type="text" name="age" size=3 onChange="validate(this, 18, 99);"&gt;
</pre>

<h4 id="Toán_tử_nhóm">Toán tử nhóm</h4>

<p>Toán tử nhóm <code>( )</code> kiểm soát thứ tự thực hiện trong biểu thức. Chẳng hạn, bạn có thể cho phép nhân và chia thực hiện sau khi cộng và trừ.</p>

<pre class="brush:js">var a = 1;
var b = 2;
var c = 3;

// thứ tự mặc định
a + b * c     // 7
// mặc định sẽ thực hiện như thế này
a + (b * c)   // 7

// giờ vượt thứ tự nào
// cộng trước rồi mới nhân
(a + b) * c   // 9

// tương tự như
a * c + b * c // 9
</pre>

<h3 id="Toán_tử_vế-trái">Toán tử vế-trái</h3>

<p>Giá trị bên trái là đích của phép gán.</p>

<h4 id="new" name="new"><code>new</code></h4>

<p>Bạn có thể dùng toán tử <a href="/en-US/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a> để tạo ra một instance thuộc kiểu object mà người-dùng-định-nghĩa hoặc một trong những kiểu object dựng-sẵn. Dùng <code>new</code> như sau:</p>

<pre class="brush: js">var objectName = new objectType([param1, param2, ..., paramN]);
</pre>

<h4 id="super">super</h4>

<p>Từ khoá <a href="/en-US/docs/Web/JavaScript/Reference/Operators/super">super</a> được dùng để gọi hàm thuộc cha của object. Thường dùng bởi <a href="/en-US/docs/Web/JavaScript/Reference/Classes">classes</a> để gọi phương thức khởi tạo của lớp cha, chẳng hạn.</p>

<pre class="syntaxbox">super([arguments]); // gọi phương thức khởi tạo của lớp cha.
super.functionOnParent([arguments]);
</pre>

<h4 id="Toán_tử_Spread">Toán tử Spread</h4>

<p>Toán tử <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">spread</a> cho phép biểu thức mở rộng tại chỗ khi có nhiều tham số (khi gọi hàm) hoặc nhiều phần tử (với array literal).</p>

<p><strong>Ví dụ:</strong> Nếu bạn có một mảng và muốn tạo một mảng mới với mảng cũ là một thành phần trong nó, cú pháp của array literal không bao giờ là đủ và bạn bắt buộc phải code chay, dùng tổ hợp <code>push</code>, <code>splice</code>, <code>concat</code>, vân vân. Với cú pháp spread, việc này súc tích hơn hẳn:</p>

<pre class="brush: js">var parts = ['shoulders', 'knees'];
var lyrics = ['head', ...parts, 'and', 'toes'];</pre>

<p>Tương tự, toán tử spread cũng hoạt động với lời gọi hàm:</p>

<pre class="brush: js">function f(x, y, z) { }
var args = [0, 1, 2];
f(...args);</pre>

<div>{{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>
