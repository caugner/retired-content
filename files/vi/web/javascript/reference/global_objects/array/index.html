---
title: Array
slug: Web/JavaScript/Reference/Global_Objects/Array
tags:
  - Array
  - JavaScript
translation_of: Web/JavaScript/Reference/Global_Objects/Array
---
<div>{{JSRef}}</div>

<p>Đối tượng <strong><code>Array</code></strong> trong JavaScript là đối tượng toàn cục được dùng để xây dựng nên các mảng; là những đối tượng cấp cao và giống một dạng danh sách.</p>

<p><strong>Tạo một Mảng</strong></p>

<pre class="brush: js notranslate">var fruits = ['Apple', 'Banana'];

console.log(fruits.length);
// 2
</pre>

<p><strong>Truy cập (bằng chỉ mục) đến một phần tử của Mảng</strong></p>

<pre class="brush: js notranslate">var first = fruits[0];
// Apple

var last = fruits[fruits.length - 1];
// Banana
</pre>

<p><strong>Lặp qua một Mảng</strong></p>

<pre class="brush: js notranslate">fruits.forEach(function(item, index, array) {
  console.log(item, index);
});
// Apple 0
// Banana 1
</pre>

<p><strong>Thêm phần tử vào cuối Mảng</strong></p>

<pre class="brush: js notranslate">var newLength = fruits.push('Orange');
// ["Apple", "Banana", "Orange"]
</pre>

<p><strong>Xóa phần tử từ cuối Mảng</strong></p>

<pre class="brush: js notranslate">var last = fruits.pop(); // xoá bỏ Orange (từ vị trí cuối)
// ["Apple", "Banana"];
</pre>

<p><strong>Xóa phần tử từ đầu Mảng</strong></p>

<pre class="brush: js notranslate">var first = fruits.shift(); // xoá bỏ Apple từ vị trí đầu
// ["Banana"];
</pre>

<p><strong>Thêm phần tử vào đầu Mảng</strong></p>

<pre class="brush: js notranslate">var newLength = fruits.unshift('Strawberry') // thêm vào vị trí đầu
// ["Strawberry", "Banana"];
</pre>

<p><strong>Tìm chỉ mục của một phần tử trong Mảng</strong></p>

<pre class="brush: js notranslate">fruits.push('Mango');
// ["Strawberry", "Banana", "Mango"]

var pos = fruits.indexOf('Banana');
// 1
</pre>

<p><strong>Xóa một phần tử bằng chỉ mục của nó</strong></p>

<pre class="brush: js notranslate">var removedItem = fruits.splice(pos, 1); // đây là cách để xoá bỏ một phần tử

// ["Strawberry", "Mango"]</pre>

<p><strong>Xóa các phần tử bắt đầu từ vị trí của chỉ mục</strong></p>

<pre class="brush: js notranslate">var vegetables = ['Cabbage', 'Turnip', 'Radish', 'Carrot'];
console.log(vegetables);
// ["Cabbage", "Turnip", "Radish", "Carrot"]

var pos = 1, n = 2;

var removedItems = vegetables.splice(pos, n);
// đây là cách để xoá các phần tử, n định nghĩa số phần tử cần xoá bỏ,
// từ vị trí đó (pos) trở đi đến cuối mảng.

console.log(vegetables);
// ["Cabbage", "Carrot"] (mảng ban đầu đã bị thay đổi)

console.log(removedItems);
// ["Turnip", "Radish"]</pre>

<p><strong>Sao chép một Mảng</strong></p>

<pre class="brush: js notranslate">var shallowCopy = fruits.slice(); // đây là cách để tạo một bản sao
// ["Strawberry"]
</pre>

<h2 id="Cú_pháp">Cú pháp</h2>

<pre class="syntaxbox notranslate"><code>[ <var>element0</var> , <var>element1</var> , ..., <var>elementN</var> ]
new Array(<var>element0</var> , <var>element1</var> [, ... [, <var>elementN</var> ]])
new Array(<var>arrayLength</var>)</code></pre>

<dl>
 <dt><code>nguyên tố <em>N</em></code></dt>
 <dd>Một mảng JavaScript được khởi tạo với các yếu tố nhất định, ngoại trừ trong trường hợp một đối số duy nhất được truyền vào <code>mảng</code> xây dựng và lập luận đó là một con số. (Xem bên dưới). Lưu ý rằng trường hợp đặc biệt này chỉ áp dụng cho các mảng JavaScript tạo ra với các <code>mảng</code> xây dựng, không mảng literals tạo ra với cú pháp khung.</dd>
 <dt><code>arrayLength</code></dt>
 <dd>Nếu đối số duy nhất được truyền cho các <code>mảng</code> constructor là một số nguyên giữa 0 và 2 <sup>32</sup> -1 (bao gồm), điều này trả về một mảng JavaScript mới với chiều dài thiết lập để con số đó. Nếu đối số là số nào khác, một {{jsxref ("Global_Objects / RangeError", "RangeError")}} ngoại lệ được ném ra.</dd>
</dl>

<h2 id="Miêu_tả">Miêu tả</h2>

<p>Mảng là đối tượng danh sách giống như nguyên mẫu mà có phương pháp để thực hiện traversal và đột biến hoạt động. Cả chiều dài của một mảng JavaScript hay các loại của các yếu tố của nó được cố định. Vì chiều dài kích thước của một mảng lớn hoặc thu nhỏ bất cứ lúc nào, các mảng JavaScript là không đảm bảo được dày đặc. Nói chung, đây là những đặc điểm thuận tiện; nhưng nếu các tính năng này không được mong muốn sử dụng cụ thể của bạn, bạn có thể xem xét sử dụng các mảng gõ.</p>

<p>Một số người nghĩ rằng <a class="external" href="http://www.andrewdupont.net/2006/05/18/javascript-associative-arrays-considered-harmful/">bạn không nên sử dụng một mảng như là một mảng kết hợp</a> . Trong mọi trường hợp, bạn có thể sử dụng đồng bằng {{jsxref ("Global_Objects / Object", "đối tượng")}} thay vào đó, mặc dù làm như vậy đi kèm với hãy cẩn thận của mình. Xem các bài viết <a class="external" href="http://www.less-broken.com/blog/2010/12/lightweight-javascript-dictionaries.html">từ điển JavaScript nhẹ với các phím tùy ý</a> như là một ví dụ.</p>

<h3 id="Truy_cập_vào_các_phần_tử_mảng">Truy cập vào các phần tử mảng</h3>

<p>Mảng JavaScript được zero-lập chỉ mục: phần tử đầu tiên của mảng là lúc chỉ số <code>0</code> , và các yếu tố cuối cùng là chỉ số tương đương với giá trị của của mảng {{jsxref ("Array.length", "chiều dài")}} tài sản trừ đi 1.</p>

<pre class="brush: js notranslate">var arr = ['đây là yếu tố đầu tiên "," đây là yếu tố thứ hai'];
console.log(arr[0]); // Nhật ký này là yếu tố đầu tiên '
console.log(arr[1]); // Nhật ký này là yếu tố thứ hai '
console.log(arr[arr.length - 1]); // Nhật ký này là yếu tố thứ hai '
</pre>

<p>Các phần tử mảng là thuộc tính đối tượng trong cùng một cách mà <code>toString</code> là một thuộc tính, nhưng cố gắng để truy cập vào một phần tử của mảng như sau ném một lỗi cú pháp, bởi vì tên sở hữu là không hợp lệ:</p>

<pre class="brush: js notranslate">console.log(arr.0); // Một lỗi cú pháp
</pre>

<p>Có gì đặc biệt về mảng JavaScript và các thuộc tính gây ra điều này là. Tính JavaScript bắt đầu bằng một chữ số không thể được tham chiếu với ký hiệu dấu chấm; và phải được truy cập bằng cách sử dụng ký hiệu khung. Ví dụ, nếu bạn đã có một đối tượng với một thuộc tính có tên <code>'3D'</code> , nó chỉ có thể được tham chiếu bằng cách sử dụng ký hiệu khung. Ví dụ như:</p>

<pre class="brush: js notranslate">var years = [1950, 1960, 1970, 1980, 1990, 2000, 2010];
console.log(years.0); // Một lỗi cú pháp
console.log(years[0]); // Đúng cú pháp
</pre>

<pre class="brush: js notranslate">renderer.3d.setTexture (model, 'character.png'); // Một lỗi cú pháp
renderer['3D']setTexture (model, 'character.png.'); // Đúng cú pháp
</pre>

<p>Lưu ý rằng trong ví dụ <code>3d</code> , <code>'3D'</code> đã được trích dẫn. Có thể trích dẫn các chỉ số mảng JavaScript cũng như (ví dụ, <code>năm ['2']</code> thay vì <code>năm [2]</code> ), mặc dù nó không cần thiết. 2 trong <code>năm [2]</code> là bị cưỡng chế vào một chuỗi các công cụ JavaScript thông qua một tiềm ẩn <code>toString</code> chuyển đổi. Chính vì lý do này mà <code>'2'</code> và <code>'02'</code> sẽ chỉ đến hai khe cắm khác nhau trên <code>năm</code> đối tượng và các ví dụ sau đây có thể là <code>sự thật</code> :</p>

<pre class="brush: js notranslate">console.log(years['2'] = years['02']!);
</pre>

<p>Tương tự, thuộc tính đối tượng đó xảy ra để được dành riêng chỉ có thể được truy cập như các chuỗi trong ký hiệu khung:</p>

<pre class="brush: js notranslate">var promise = {
  'Var': 'text',
  'Array': [1, 2, 3, 4]
};

console.log(promise['Array']);
</pre>

<h3 id="Mối_quan_hệ_giữa_chiều_dài_và_số_thuộc_tính">Mối quan hệ giữa <code>chiều dài</code> và số thuộc tính</h3>

<p>Một mảng của JavaScript {{jsxref ("Array.length", "chiều dài")}} tài sản và tính toán được kết nối. Một số phương pháp mảng xây dựng trong (ví dụ, {{jsxref ("Array.join", "tham gia")}}, {{jsxref ("Array.slice", "lát cắt")}}, {{jsxref (" Array.indexOf "," indexOf ")}}, vv) có tính đến các giá trị của một mảng {{jsxref (" Array.length "," chiều dài ")}} tài sản khi chúng được gọi. Các phương pháp khác (ví dụ, {{jsxref ("Array.push", "đẩy")}}, {{jsxref ("Array.splice", "mối nối")}}, vv) cũng cho kết quả trong bản cập nhật tới một mảng của { {jsxref ("Array.length", "chiều dài")}} thuộc tính.</p>

<pre class="notranslate"><code>var fruits = [];
fruits.push('banana', 'apple', 'peach');

console.log(fruits.length); // 3</code></pre>

<p>Khi thiết lập một thuộc tính trên một mảng JavaScript khi tài sản là một chỉ số mảng hợp lệ và chỉ số đó là ngoài giới hạn hiện tại của mảng, engine sẽ cập nhật thuộc tính {{jsxref ("Array.length", "chiều dài")}} của mảng cho phù hợp:</p>

<pre class="notranslate"><code>fruits[5] = 'mango';
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits));  // ['0', '1', '2', '5']
console.log(fruits.length); // 6</code></pre>

<p>Tăng {{jsxref ("Array.length", "chiều dài")}}.</p>

<pre class="brush: js notranslate">fruits.length = 10;
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
</pre>

<p>Giảm thuộc tính {{jsxref ("Array.length", "chiều dài")}} , tuy nhiên, xóa các phần tử.</p>

<pre class="brush: js notranslate">fruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2
</pre>

<p>Điều này được giải thích thêm về {{jsxref ("Array.length")}} trang.</p>

<h3 id="Tạo_một_mảng_bằng_cách_sử_dụng_kết_quả_của_một_trận_đấu">Tạo một mảng bằng cách sử dụng kết quả của một trận đấu</h3>

<p>Kết quả của một trận đấu giữa một biểu hiện thường xuyên và một chuỗi có thể tạo ra một mảng JavaScript. Mảng này có các tính chất và các yếu tố trong đó cung cấp thông tin về trận đấu. Một mảng đó được trả về bởi {{jsxref ("RegExp.exec")}}, {{jsxref ("String.match")}} và {{jsxref ("string.Replace")}}. Để giúp giải thích các thuộc tính và các yếu tố, nhìn vào ví dụ sau đây và sau đó tham khảo bảng dưới đây:</p>

<pre class="brush: js notranslate">// Trận đấu một d theo sau bởi một hoặc nhiều b theo sau bởi một d
// Ghi phù hợp của b và d sau
// Bỏ qua trường hợp

var Myre = / d (b +) (d) / i;
var myArray = myRe.exec('cdbBdbsbz');
</pre>

<p>Các tính chất và các yếu tố trở về từ trận đấu này như sau:</p>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <td class="header">Bất động sản / tử</td>
   <td class="header">Miêu tả</td>
   <td class="header">Thí dụ</td>
  </tr>
  <tr>
   <td><code>đầu vào</code></td>
   <td>Một thuộc tính chỉ đọc phản ánh các chuỗi ban đầu dựa vào đó các biểu thức chính quy được kết hợp.</td>
   <td>cdbBdbsbz</td>
  </tr>
  <tr>
   <td><code>mục lục</code></td>
   <td>Một thuộc tính chỉ đọc mà là chỉ số không dựa trên các trận đấu trong chuỗi.</td>
   <td>1</td>
  </tr>
  <tr>
   <td><code>[0]</code></td>
   <td>Một yếu tố chỉ đọc mà xác định các ký tự tương ứng cuối cùng.</td>
   <td>dbBd</td>
  </tr>
  <tr>
   <td><code>[1], ... [n]</code></td>
   <td>Chỉ đọc các yếu tố đó chỉ định các trận đấu substring parenthesized, nếu có trong các biểu hiện thường xuyên. Số lượng các chuỗi con trong ngoặc có thể là không giới hạn.</td>
   <td>[1]: bB<br>
    [2]: d</td>
  </tr>
 </tbody>
</table>

<h2 id="Thuộc_tính">Thuộc tính</h2>

<dl>
 <dt>{{Jsxref ("Array.length")}}</dt>
 <dd>Thuộc tính chiều dài của <code>Array</code> trong constructor (hàm dựng) có giá trị là 1.</dd>
 <dt>{{Jsxref ("Array.prototype")}}</dt>
 <dd>Cho phép bổ sung các thuộc tính cho tất cả các đối tượng mảng.</dd>
</dl>

<h2 id="Phương_thức">Phương thức</h2>

<dl>
 <dt>{{Jsxref ("Array.from()")}} {{experimental_inline}}</dt>
 <dd>Tạo ra một <code>Mảng</code> mới từ một đối tượng giống mảng hoặc iterable.</dd>
 <dt>{{Jsxref ("Array.isArray()")}}</dt>
 <dd>Trả về true nếu một biến là một mảng, ngược lại false nếu không phải là mảng.</dd>
 <dt>{{Jsxref ("Array.of()")}} {{experimental_inline}}</dt>
 <dd>Tạo ra một <code>Array</code> mới với một số lượng các đối số, bất kể số hoặc loại của các đối số.</dd>
</dl>

<h2 id="Array_instances"><code>Array</code> instances</h2>

<p>Tất cả instance <code>Array </code>kế thừa từ {{jsxref ("Array.prototype")}}. Các đối tượng nguyên mẫu của <code>Array</code> constructor có thể được sửa đổi để ảnh hưởng đến tất cả các instance <code>Array</code>.</p>

<h3 id="Thuộc_tính_2">Thuộc tính</h3>

<div>{{Page ('/ en-US / docs / Web / JavaScript / Reference / Global_Objects / Array / mẫu', 'Properties')}}</div>

<h3 id="Phương_thức_2">Phương thức</h3>

<h4 id="Phương_thức_mutator">Phương thức mutator</h4>

<div>{{Page ('en-US / docs / Web / JavaScript / Reference / Global_Objects / Array / mẫu', 'Mutator_methods')}}</div>

<h4 id="Phương_thức_accessor">Phương thức accessor</h4>

<div>{{Page ('en-US / docs / Web / JavaScript / Reference / Global_Objects / Array / mẫu', 'Accessor_methods')}}</div>

<h4 id="Phương_thức_lặp_đi_lặp_lại">Phương thức lặp đi lặp lại</h4>

<div>{{Page ('en-US / docs / Web / JavaScript / Reference / Global_Objects / Array / mẫu', 'Iteration_methods')}}</div>

<h2 id="Array_phương_thức_chung"><code>Array</code> phương thức chung</h2>

<p>Đôi khi bạn muốn áp dụng phương thức mảng các chuỗi hoặc các đối tượng mảng giống khác (chẳng hạn như chức năng {{jsxref ("Chức năng / lập luận", "lý luận", "", 1)}}). Bằng cách này, bạn đối xử với một chuỗi như là một mảng kí tự (hoặc nếu không điều trị một phi mảng như là một mảng). Ví dụ, để kiểm tra xem tất cả các nhân vật trong biến <var>str</var> là một lá thư, bạn có thể viết:</p>

<pre class="brush: js notranslate">function isLetter (person) {
  return person &gt;= 'a' &amp;&amp; person &lt;= 'z';
}

if (Array.prototype.every.call (str, isLetter)) {
  console.log("<code>The string</code> " + str + " <code>contains only letters</code>!");
}
</pre>

<p>Ký hiệu này là khá lãng phí và JavaScript 1.6 giới thiệu một cách viết tắt chung:</p>

<pre class="brush: js notranslate">if (Array.every (str, isLetter)) {
  console.log("<code>The string</code> " + str + " <code>contains only letters</code>!");
}
</pre>

<p>{{Jsxref ("Global_Objects / String", "Generics", "#String_generic_methods", 1)}} cũng có sẵn trên {{jsxref ("Global_Objects / String", "String")}}.</p>

<p>Đây không phải là một phần của tiêu chuẩn ECMAScript và chúng không được hỗ trợ bởi các trình duyệt không phải là Gecko. Như một thay thế tiêu chuẩn, bạn có thể chuyển đổi đối tượng của bạn thành một mảng bằng cách sử dụng ({{jsxref ("Array.from ()")}}, mặc dù phương pháp này có thể không được hỗ trợ trong các trình duyệt cũ:</p>

<pre class="notranslate"><code>if (Array.from(str).every(isLetter)) {
  console.log("The string " + str + " contains only letters!");
}</code></pre>

<h2 id="Ví_dụ">Ví dụ</h2>

<h3 id="Tạo_một_mảng">Tạo một mảng</h3>

<p>Ví dụ sau tạo một mảng, <code>msgArray</code> , với chiều dài 0, sau đó gán giá trị cho <code>[0] msgArray</code> và <code>msgArray [99]</code> , thay đổi độ dài của mảng đến 100.</p>

<pre class="brush: js notranslate">var msgArray = [];
msgArray [0] = "Hello";
msgArray [99] = 'World';

if (msgArray.length === 100) {
  console.log('Chiều dài là 100');
}
</pre>

<h3 id="Tạo_một_mảng_hai_chiều">Tạo một mảng hai chiều</h3>

<p>Sau đây tạo ra một bàn cờ như là một mảng hai chiều của chuỗi. Động thái đầu tiên được thực hiện bằng cách sao chép 'p' trong (6,4) đến (4,4). Các vị trí cũ (6,4) được làm trống.</p>

<pre class="notranslate"><code>var board = [
  ['R','N','B','Q','K','B','N','R'],
  ['P','P','P','P','P','P','P','P'],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  ['p','p','p','p','p','p','p','p'],
  ['r','n','b','q','k','b','n','r'] ];

console.log(board.join('\n') + '\n\n');

// Di chuyển King's Pawn về phía trước 2
board[4][4] = board[6][4];
board[6][4] = ' ';
console.log(board.join('\n'));</code></pre>

<p>Đây là kết quả:</p>

<pre class="eval notranslate">R, N, B, Q, K, B, N, R
P, P, P, P, P, P, P, P
 ,,,,,,,
 ,,,,,,,
 ,,,,,,,
 ,,,,,,,
p, p, p, p, p, p, p, p
r, n, b, q, k, b, n, r

R, N, B, Q, K, B, N, R
P, P, P, P, P, P, P, P
 ,,,,,,,
 ,,,,,,,
 ,,,, P,,,
 ,,,,,,,
p, p, p, p,, p, p, p
r, n, b, q, k, b, n, r
</pre>

<h3 id="Sử_dụng_một_mảng_để_sắp_xếp_một_tập_các_giá_trị">Sử dụng một mảng để sắp xếp một tập các giá trị</h3>

<pre class="notranslate"><code>values = [];
for (var x = 0; x &lt; 10; x++){
 values.push([
  2 ** x,
  2 * x ** 2
 ])
};
console.table(values)</code></pre>

<p>Kết quả là:</p>

<pre class="notranslate"><code>0	1	0
1	2	2
2	4	8
3	8	18
4	16	32
5	32	50
6	64	72
7	128	98
8	256	128
9	512	162</code></pre>

<p>(Cột đầu tiên là index (chỉ mục))</p>

<h2 id="Thông_số_kỹ_thuật">Thông số kỹ thuật</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Đặc điểm kỹ thuật</th>
   <th scope="col">Trạng thái</th>
   <th scope="col">Chú thích</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Định nghĩa ban đầu.</td>
  </tr>
  <tr>
   <td>{{SpecName("ES5.1", "#sec-15.4", "Array")}}</td>
   <td>{{Spec2("ES5.1")}}</td>
   <td>Phương thức mới được thêm vào: {{jsxref("Array.isArray")}}, {{jsxref("Array.prototype.indexOf", "indexOf")}}, {{jsxref("Array.prototype.lastIndexOf", "lastIndexOf ")}}, {{jsxref("Array.prototype.every", "every")}}, {{jsxref("Array.prototype.some", "some")}}, {{jsxref("Array. prototype.forEach","forEach")}}, {{jsxref("Array.prototype.map","map")}}, {{jsxref("Array.prototype.filter", "filter")}}, {{jsxref("Array.prototype.reduce", "reduce")}}, {{jsxref("Array.prototype.reduceRight", "reduceRight")}}</td>
  </tr>
  <tr>
   <td>{{SpecName("ES6", "#sec-array-objects", "Array")}}</td>
   <td>{{Spec2 ("ES6")}}</td>
   <td>Phương thức mới được thêm vào: {{jsxref ("Array.from")}}, {{jsxref ("Array.of")}}, {{jsxref ("Array.prototype.find", "find")}}, {{jsxref ("Array.prototype.findIndex", "findIndex")}}, {{jsxref ("Array.prototype.fill", "fill")}}, {{jsxref ("Array.prototype.copyWithin", "copyWithin")}}</td>
  </tr>
 </tbody>
</table>

<h2 id="Khả_năng_tương_thích_trình_duyệt">Khả năng tương thích trình duyệt</h2>

<div>{{Compat("javascript.builtins.Array")}}</div>

<div id="compat-desktop"></div>

<h2 id="Xem_thêm">Xem thêm</h2>

<ul>
 <li><a href="/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Indexing_object_properties">Hướng dẫn JavaScript: "thuộc tính đối tượng Indexing"</a></li>
 <li><a href="/en-US/docs/Web/JavaScript/Guide/Predefined_Core_Objects#Array_Object">JavaScript Guide: “Predefined Core Objects: Array Object”</a></li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Array_comprehensions">Array comprehensions</a></li>
 <li><a href="https://github.com/plusdude/array-generics">Polyfill for JavaScript 1.8.5 Array Generics and ECMAScript 5 Array Extras</a></li>
 <li><a href="/en-US/docs/JavaScript_typed_arrays">Mảng Typed</a></li>
</ul>
