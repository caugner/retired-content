---
title: El model d'objectes en detall
slug: Web/JavaScript/Guide/Details_of_the_Object_Model
translation_of: Web/JavaScript/Guide/Details_of_the_Object_Model
---
<p>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Working_with_Objects", "Web/JavaScript/Guide/Iterators_and_Generators")}}</p>

<p>JavaScript és un llenguatge orientat a objectes basat en prototipus en comptes d'estar basat en classes. Degut a aquesta diferència pot resultar menys evident la forma en que JavaScript permet crear jerarquies d'objectes i proporciona herència de propietats i els seus valors. Aquest capítol pretén aclarir aquest tema.</p>

<p>Aquest capítol assumeix que teniu certa familiaritat amb JavaScript i sabeu crear objectes simples mitjançant funcions.</p>

<h2 id="Llenguatges_basats_en_classes_vs_llenguatges_basats_en_prototipus">Llenguatges basats en classes vs llenguatges basats en prototipus</h2>

<p>Els llenguatges orientats a objectes basats en classes, com ara Java i C++, es basen en el concepte de tenir dues entitats diferents: classes i instàncies.</p>

<ul>
 <li>Una <em>classe</em> defineix totes les propietats (considerem que a Java els mètodes i camps, així com els membres a C++, són propietats) que caracteritzen un determinat conjunt d'objectes. Una classe és quelcom abstracte, en contraposició amb un membre específic del grup d'objectes que defineix. Per exemple, la classe <code>Employee</code> podria representar el conjunt de tots els empleats.</li>
 <li>Una <em>instància</em>, d'altra banda, és la instanciació d'una classe, és a dir, un dels seus membres. Per exemple, <code>Victoria</code> podría ser una instància de la classe <code>Employee</code>, representant un individu concret com a empleat. Una instància te exactament les propietats de la seva classe pare, ni més ni menys.</li>
</ul>

<p>Un llenguatge basat en prototipus, com ara JavaScript, no fa aquesta distinció: simplement disposa d'objectes. Un llenguatge basat en prototipus, però, té el concepte de <em>objecte prototipus</em>, un objecte que s'utilitza com a motlle del qual obtindre les propietats inicial d'un nou objecte. Qualsevol objecte pot especificar les seves pròpies propietats, ja sigui quan aquest és creat o be en temps d'execució. A més, qualsevol objecte pot ser associat com el <em>prototipus</em> d'un altre objecte, tot permetent al segon objecte compartir les propietats del primer.</p>

<h3 id="Definir_una_classe">Definir una classe</h3>

<p>En llenguatge basats en classes hom defineix una classe de forma separada com una <em>definició de classe</em>. En aquesta definició es poden especificar mètodes especials, anomenats <em>constructors</em>, que serveixen per a crear instàncies de la classe a la que pertanyen. Un mètode constructor pot especificar valors inicials per a les propietats d'una instància, així com realitzar altres tasques en temps de creació de l'objecte. Per a crear instàncies d'una classe s'utilitza l'operador <code>new</code> en associació amb un mètode constructor de la classe.</p>

<p>JavaScript empra un model similar tot i que no disposa de definicions de classes separades dels constructors. En comptes d'això, es defineix una funció constructora per a crear objectes amb un conjunt específic de propietats i valors. Qualsevol funció de JavaScript pot ser utilitzada com a constructor. S'utilitza l'operador <code>new</code> amb una funció constructora per a crear un nou objecte.</p>

<h3 id="Subclasses_i_herència">Subclasses i herència</h3>

<p>En els llenguatges basats en classes, es poden crear jerarquies de classes mitjançant la definició de les classes. En una definició de classe es pot especificar que la nova classe és una <em>subclasse</em> d'una classe que ja existeix. La subclasse hereta totes les propietats de la <em>superclasse</em> i pot afegir noves propietats adicionals o bé modificar les heretades. Per exemple, suposem que la classe <code>Employee</code> només inclou les propietats <code>name</code> i <code>department</code>, i la classe <code>Manager</code> és una subclasse de <code>Employee</code> que afegeix la propietat <code>reports</code>. En aquest cas una instància de la classe <code>Manager</code> tindria totes tres propietats: <code>name</code>, <code>department</code> i <code>reports</code>.</p>

<p>JavaScript implementa l'herència permetent associar un objecte prototipus a qualsevol funció constructora. D'aquesta forma es pot crear exactament l'exemple <code>Employee</code> — <code>Manager</code>, tot i que fent servir una terminologia lleugerament diferent. Primerament cal definir la funció constructora de <code>Employee</code>, tot especificant les propietats <code>nom</code> i <code>departament</code>. Seguidament es defineix la funció constructora de <code>Manager</code>, tot cridant el constructor de <code>Employee</code> i especificant la propietat <code>informes</code>. Finalment s'assigna el nou objecte derivat de <code>Employee.prototype</code> com el <code>prototype</code> de la funció constructora de <code>Manager</code>. Llavors quan es crea un nou objecte de tipus <code>Manager</code> aquest hereta les propietats <code>name</code> i <code>department</code> de l'objecte <code>Employee</code>.</p>

<h3 id="Afegir_i_esborrar_propietats">Afegir i esborrar propietats</h3>

<p>En llenguatges basats en classes les classes són normalment creades en temps de compilació i mentre que les instàncies de la classe poden ser creades tant en temps de compilació com en temps d'execució. No és possible canviar el nombre o el tipus de les propietats d'una classe després d'haver definit la classe. En JavaScript, però, és possible afegir o eliminar propietats de qualsevol objecte en temps d'execució. Si s'afegeix una propietat a un objecte que està sent utilitzat com a prototipus d'un conjunt d'objectes, aquests objectes també rebran la nova propietat.</p>

<h3 id="Resum_de_diferències">Resum de diferències</h3>

<p>La taula següent proporciona un breu resum d'algunes d'aquestes diferències. La resta del capítol descriu els detalls d'utilitzar constructors i prototipus a JavaScript per a crear jerarquies d'objectes i ho compara amb com es faria amb Java.</p>

<table class="fullwidth-table">
 <caption>Taula 8.1 Comparació de sistems d'objectes basats en classes (Java) i basats en prototipus (JavaScript)</caption>
 <thead>
  <tr>
   <th scope="col">Basat en classes (Java)</th>
   <th scope="col">Basat en prototipus (JavaScript)</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Les classes i les instàncies són entitats diferents.</td>
   <td>Qualsevol objecte pot heretar d'un altre objecte.</td>
  </tr>
  <tr>
   <td>Es defineix una classe mitjançant una definició de classe; Es crea una instància d'una classe mitjançant un dels seus mètodes constructors.</td>
   <td>Es defineix i es crea un conunt d'objectes mitjançant funcions constructores.</td>
  </tr>
  <tr>
   <td>Es crea un sol objecte amb l'operador <code>new</code>.</td>
   <td>Es crea un sol objecte amb l'operador <code>new</code>.</td>
  </tr>
  <tr>
   <td>
    <p>Les jerarquies d'objectes es construeixen mitjançant definicions de classes per a especificar subclasses de les classes existents.</p>
   </td>
   <td>
    <p>Les jerarquies d'objectes es construeixen tot assignant un objecte com el prototipus associat amb una funció constructora.</p>
   </td>
  </tr>
  <tr>
   <td>Hereta les propietats tot següient la cadena de classes.</td>
   <td>
    <p>Hereta les propietats tot seguint la cadena de prototipus.</p>
   </td>
  </tr>
  <tr>
   <td>
    <p>La definició d'una classe especifica <em>totes</em> les propietats per totes les instàncies de la classe. No és possible afegir propietats dinàmicament en temps d'execució.</p>
   </td>
   <td>
    <p>Una funció constructora o un prototipus especifiquen un <em>conjunt inicial</em> de propietats. És possible afegir o eliminar propietats de forma dinàmica per a objectes individuals o bé de tot el conjunt d'objectes.</p>
   </td>
  </tr>
 </tbody>
</table>

<p> </p>

<h2 id="L'exemple_Employee">L'exemple Employee</h2>

<p>La resta d'aquest capítol utilitza la jerarquia de <code>Employee</code> que es mostra en la següent figura.</p>

<p><img alt="" class="internal" src="/@api/deki/files/4452/=figure8.1.png" style="height: 194px; width: 281px;"></p>

<p><small><strong>Figura 8.1: Una jerarquia d'objectes simple</strong></small></p>

<p>Aquest exemple utilitza els objectes següents:</p>

<ul>
 <li><code>Employee</code> té les propietats <code>name</code> (el valor de la qual és una cadena buida per defecte) i <code>dept</code> (el valor de la qual és "general" per defecte).</li>
 <li><code>Manager</code> està basada en <code>Employee</code>. Afegeix la propietat <code>reports</code> (el valor de la qual és un array buit per defecte, i destinada a emmagatzemar un array d'objectes de tipus <code>Employee</code> com a valor).</li>
 <li><code>WorkerBee</code> també està basada en <code>Employee</code>. afegeix la propietat<code> projects</code> (el valor de la qual és un array buit per defecte, i destinada a emmagatzemar un array de strings com a valor).</li>
 <li><code>SalesPerson</code> està basada en <code>WorkerBee</code>. Afegeix la propietat <code>quota</code> (el valor de la qual és 100 per defecte). També sobreescriu la propietat <code>dept</code> amb el valor "sales", tot indicant que tots els objectes del tipus salespersons pertanyen al mateix department.</li>
 <li><code>Engineer</code> està basat en <code>WorkerBee</code>. Afegeix la propietat <code>machine</code> (el valor de la qual és una string buida per defecte) i també sobreescriu la propietat <code>dept</code> amb el valor "engineering".</li>
</ul>

<h2 id="Crear_una_jerarquia">Crear una jerarquia</h2>

<p>Hi ha diverses formes de definir les funcions constructores adequades per a implementar una jerarquia de Employee. Quina escollir-ne una depen en gran mesura del que es vol fer en l'aplicació.</p>

<p>Aquesta secció mostra com utilitzar definicions molt simples (i comparativament poc flexibles) per a demostrar com funciona l'herència. En aquestes definicions no es pot especificar cap valor de les propietats al crear un objecte. L'objecte creat recentment senzillament té els valors per defecte, que es poden canviar després.</p>

<p>En una aplicació real probablement es definirien constructors que permetessin especificar valors per les propietats de l'objecte al crear-lo (vegeu <a href="#Constructors_més_flexibles">Constructors més flexibles</a> per a més informació). De moment aquestes definicions simples demostren com funciona l'herència.</p>

<p>Les següents definicions en Java i JavaScript de <code>Employee</code> són similars. L'única diferència és que a Java s'ha d'especificar el tipus de cada propietat de forma explícita mentre que a JavaScript no (degut a que Java és un <a href="http://en.wikipedia.org/wiki/Strong_and_weak_typing">llenguatge de tipatge fort</a> mentre que JavaScript és un llenguatge de tipatge dèbil).</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">JavaScript</th>
   <th scope="col">Java</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <pre class="brush: js">
function Employee() {
  this.name = "";
  this.dept = "general";
}
</pre>
   </td>
   <td>
    <pre class="brush: java">
public class Employee {
   public String name = "";
   public String dept = "general";
}
</pre>
   </td>
  </tr>
 </tbody>
</table>

<p>Les definicions de <code>Manager</code> i <code>WorkerBee</code> mostren com especificar quin és l'objecte pare dins la cadena d'herència. A JavaScript s'afegeix una instància prototipus com a valor de la propietat <code>prototype</code> de la funció constructora. Això es pot fer en qualsevol moment després d'haver definit el constructor. A Java, en canvi, s'ha d'especificar la superclasse dins la definició de la classe, i aquesta, en conseqüència, no pot canviar-se fora de la definició de classe.</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">JavaScript</th>
   <th scope="col">Java</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <pre class="brush: js">
function Manager() {
  Employee.call(this);
  this.reports = [];
}
Manager.prototype = Object.create(Employee.prototype);

function WorkerBee() {
  Employee.call(this);
  this.projects = [];
}
WorkerBee.prototype = Object.create(Employee.prototype);
</pre>
   </td>
   <td>
    <pre class="brush: java">
public class Manager extends Employee {
   public Employee[] reports;
   public Manager () {
      super();
      this.reports = new Employee[0];
   }
}

public class WorkerBee extends Employee {
   public String[] projects;
   public WorkerBee () {
      super();
      this.projects = new String[0];
   }
}
</pre>
   </td>
  </tr>
 </tbody>
</table>

<p>Les definicions de <code>Engineer</code> i <code>SalesPerson</code> creen objectes que descendeixen de <code>WorkerBee</code> i, per extensió, de <code>Employee</code>. Un objecte d'algun d'aquests tipus té les propietats de tots els objectes de damunt seu a la cadena d'herència. A més les definicions sobreescriuen els valors heretats de la propietat <code>dept</code> amb els nous valors especificats per a aquests objectes.</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">JavaScript</th>
   <th scope="col">Java</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <pre class="brush: js">
function SalesPerson() {
   WorkerBee.call(this);
   this.dept = "sales";
   this.quota = 100;
}
SalesPerson.prototype = Object.create(WorkerBee.prototype);

function Engineer() {
   WorkerBee.call(this);
   this.dept = "engineering";
   this.machine = "";
}
Engineer.prototype = Object.create(WorkerBee.prototype);
</pre>
   </td>
   <td>
    <pre class="brush: java">
public class SalesPerson extends WorkerBee {
   public double quota;
   public SalesPerson () {
      super();
      this.dept = "sales";
      this.quota = 100.0;
   }
}

public class Engineer extends WorkerBee {
   public String machine;
   public Engineer () {
      super();
      this.dept = "engineering";
      this.machine = "";
   }
}
</pre>
   </td>
  </tr>
 </tbody>
</table>

<p>A l'utilitzar aquestes definicions les instàncies creades per aquests objectes tenen els valors per defecte apropiats per a les seves propietats. La figura 8.3 mostra com utilitzar aquestes definicions de JavaScript per a crear objectes nous i mostra els valors de les propietats per als nous objectes.</p>

<div class="note">
<p>El terme <em>instància</em> té un significat tècnic específic per a llenguatges basats en classes. En aquests llenguatges una instància és una instanciació individual d'una classe i és fundamentalment diferent de la classe. A JavaScript, "instància" no té aquest significat tècnic perquè aquest no diferencia entre classes i instàncies, tot i que parlant informalment de JavaScript es pot utilitzar el terme "instància" per a indicar un objecte creat utilitzant una funció constructora particular. Així, en aquest exemple, hom pot dir informalment que <code>jane</code> és una instància d'<code>Engineer</code>. De la mateixa manera, tot i que els termes <em>fill</em>, <em>predecessor</em> i <em>descendent</em> no tenen cap significat formal a JavaScript, aquests poden emprar-se de forma informal per a fer referència a objectes més amunt o bé més avall de la cadena de prototipus.</p>
</div>

<p> </p>

<p><img alt="figure8.3.png" class="default internal" id="figure8.3" src="/@api/deki/files/4403/=figure8.3.png"><br>
 <a id="8.3" name="8.3"><small><strong>Figura 8.3: Creació d'objectes amb definicions simples</strong></small></a></p>

<h2 id="Propietats_d'un_objecte">Propietats d'un objecte</h2>

<p>Aquesta secció explica com els objectes hereten propietats d'altres objecte mitjançant la cadena de prototipus i què succeeix quan s'afegeix una propietat en temps d'execució.</p>

<h3 id="Heretar_propietats">Heretar propietats</h3>

<p>Suposem que creem l'objecte <code>mark</code> a partir de <code>WorkerBee</code> (tal i com es mostra a la <a href="#8.3">Figura 8.3</a>) amb la sentència següent:</p>

<pre class="brush: js">var mark = new WorkerBee;
</pre>

<p>Quan JavaScript es troba amb l'operador <code>new</code>, aquest crea un nou objecte genèric i passa aquest nou objecte com a valor de la paraula clau <code>this</code> a la funció constructora de <code>WorkerBee</code>. La funció constructora assigna el valor de la propietat project de forma explícita, i assigna implícitament el valor <code>WorkerBee.prototype</code> a la propietat interna <code>__proto__</code> (el nom d'aquesta propietat conté dos guions baixos tant al principi com al final). La propietat <code>__proto__</code> determina la cadena de prototipus que s'emprarà per a retornar valors de propietats. Un cop assignades aquestes propietats, JavaScript retorna el nou objecte i la sentència d'assignació associa l'objecte a la variable <code>mark</code>.</p>

<p>Aquest procés no assigna valors de forma explícita a l'objecte <code>mark</code> (valors <em>locals</em>) per a les propietats que mark hereta a través de la cadena de prototipus. Quan s'intenta obtindre el valor d'una propietat JavaScript primer mira si el valor existeix en aquest objecte. Si és així, aquest és el valor retornat. Si el valor no existeix de forma <em>local</em>, JavaScript recorre la cadena prototipus (mitjançant la propietat <code>__proto__</code>). Si un objecte de la cadena prototipus té un valor per assignat a la propietat, aquest és el valor retornat. Si aquesta propietat no es troba a cap objecte de la cadena prototipus JavaScript determina que l'objete no té aquesta propietat. D'aquesta forma, l'objete <code>mark</code> té les següents propietats i valors:</p>

<pre class="brush: js">mark.name = "";
mark.dept = "general";
mark.projects = [];
</pre>

<p>L'objecte <code>mark</code> hereta els valors per a les propietats <code>name</code> i <code>dept</code> de l'objecte prototipus a <code>mark.__proto__</code>. La propietat <code>projects</code> rep un valor local designat pel constructor <code>WorkerBee</code>. Així és com funciona l'herència de propietats i els seus valors a JavaScript. Es poden trobar alguns detalls d'aquest procès a <a href="#Un_segon_cop_d'ull_a_l'herència_de_propietats">Un segon cop d'ull a l'herència de propietats</a>.</p>

<p>Com que aquests constructors no permeten valors per a l'instància aquesta informació és genèrica. Els valors de les propietats són compartits per defecte, compartits per tots els nous objectes creats a partir de <code>WorkerBee</code>. Per suposat, es poden canviar els valors inicials d'aquestes propietats. A continuació es mostra com canviar informació específica:</p>

<pre class="brush: js">mark.name = "Doe, Mark";
mark.dept = "admin";
mark.projects = ["navigator"];</pre>

<h3 id="Afegir_propietats">Afegir propietats</h3>

<p>A JavaScript, es poden afegir propietats a qualsevol objecte en temps d'execució. No hi ha cap limitació que ens forci a utilitzar només les propietats que ofereix la funció constructora. Per a afegir una propietat específicament a només un objecte, s'assigna un valor a l'objecte de la manera següent:</p>

<pre class="brush: js">mark.bonus = 3000;
</pre>

<p>Ara l'objecte <code>mark</code> té una propietat anomenada <code>bonus</code>, però cap altre objecte de tipus WorkerBee tindrà aquesta propietat.</p>

<p>Si s'afegeix una nova propietat a un objecte que és emprat com a prototipus per una funció constructora, la propietat s'afegeix a tots els objectes que hereten propietats del prototipus. Per exemple, podem afegir la propietat <code>specialty</code> a tots els empleats amb la sentència següent:</p>

<pre class="brush: js">Employee.prototype.specialty = "none";
</pre>

<p>Un cop la sentència s'ha executat l'objecte <code>mark</code> també disposa de la propietat <code>specialty</code>, amb el valor <code>"none"</code>. La figura següent mostra l'efecte d'afegir aquesta propietat al prototipus <code>Employee</code> i tot seguit sobreescriure-la per al prototipus <code>Engineer</code>.</p>

<p><img alt="" class="internal" src="/@api/deki/files/4422/=figure8.4.png" style="height: 519px; width: 833px;"><br>
 <small><strong>Figura 8.4: Afegir propietats</strong></small></p>

<h2 id="Constructors_més_flexibles">Constructors més flexibles</h2>

<p>Les funcions constructores emprades fins ara no permeten especificar els valors de les propietats al crear una instància. Tal i com succeeix amb Java, es poden passar arguments als constructors per a inicialitzar els valors de les propietats de les instàncies a crear. La figura següent mostra una forma d'aconseguir-ho.</p>

<p><img alt="" class="internal" id="figure8.5" src="/@api/deki/files/4423/=figure8.5.png" style="height: 481px; width: 1012px;"><br>
 <a id="8.5" name="8.5"><small><strong>Figura 8.5: Determinar propietats en un constructor, primera aproximació</strong></small></a></p>

<p>La taula següent mostra les definicions tant en Java com en JavaScript d'aquests objectes.</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">JavaScript</th>
   <th scope="col">Java</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <pre class="brush: js">
function Employee (name, dept) {
  this.name = name || "";
  this.dept = dept || "general";
}
</pre>
   </td>
   <td>
    <pre class="brush: java">
public class Employee {
   public String name;
   public String dept;
   public Employee () {
      this("", "general");
   }
   public Employee (String name) {
      this(name, "general");
   }
   public Employee (String name, String dept) {
      this.name = name;
      this.dept = dept;
   }
}
</pre>
   </td>
  </tr>
  <tr>
   <td>
    <pre class="brush: js">
function WorkerBee (projs) {

 this.projects = projs || [];
}
WorkerBee.prototype = new Employee;
</pre>
   </td>
   <td>
    <pre class="brush: java">
public class WorkerBee extends Employee {
   public String[] projects;
   public WorkerBee () {
      this(new String[0]);
   }
   public WorkerBee (String[] projs) {
      projects = projs;
   }
}

</pre>
   </td>
  </tr>
  <tr>
   <td>
    <pre class="brush: js">

function Engineer (mach) {
   this.dept = "engineering";
   this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;
</pre>
   </td>
   <td>
    <pre class="brush: java">
public class Engineer extends WorkerBee {
   public String machine;
   public Engineer () {
      dept = "engineering";
      machine = "";
   }
   public Engineer (String mach) {
      dept = "engineering";
      machine = mach;
   }
}
</pre>
   </td>
  </tr>
 </tbody>
</table>

<p>Aquestes definicions de JavaScript utilitzen un modisme especial per a assignar els valors per defecte:</p>

<pre class="brush: js">this.name = name || "";
</pre>

<p>L'operador lògic OR de JavaScript (<code>||</code>) avalua el primer argument. Si aquest argument esdevé cert, l'operador el retorna. En cas constrari l'operador retorna el valor del segon argument. Així, aquesta línia de codi comprova que la propietat name tingui un valor útil. Si és així, assigna aquest valor a <code>this.name</code>. En cas contrari, assigna una string buida a <code>this.name</code>. Aquest capítol utilitza aquest modisme per a abreujar tot i que pot resultar desconcertant a primera vista.</p>

<div class="note">
<p>Això pot no tindre el comportament esperat si la funció constructora es crida amb arguments que s'avaluen a fals (com <code>0</code> (zero) o la cadena buida (<code>""</code>). En aquest cas el valor per defecte serà l'escollit.</p>

<p>Amb aquestes definicions, al crear una instància d'un objecte, podem especificar valors per a les propietats locals definides. Tal i com es mostra a la <a href="#8.5">Figura 8.5</a>, es pot utilitzar la sentència següent per a crear un now <code>Engineer</code>:</p>
</div>

<pre class="brush: js">var jane = new Engineer("belau");
</pre>

<p>Les propietats de <code>Jane</code> ara són:</p>

<pre class="brush: js">jane.name == "";
jane.dept == "engineering";
jane.projects == [];
jane.machine == "belau"
</pre>

<p>Fixeu-vos que amb aquestes definicions no és possible especificar un valor inicial per a propietats heretades, com ara <code>name</code>. Si es vol especificar un valor inicial per a propietats heretades a JavaScript és necesari afegir més codi a la funció constructora.</p>

<p>Fins ara les funcions constructores han creat objectes genèrics i han pogut assignar valors a les propietats locals del nou objecte. El constructor mateix també pot afegir més propietats mitjançant la crida a la funció constructora d'un objecte més adalt en la cadena de propotitpus. La figura següent mostra aquestes noves definicions.</p>

<p><img alt="" class="internal" src="/@api/deki/files/4430/=figure8.6.png" style="height: 534px; width: 1063px;"><br>
 <small><strong>Figura 8.6 Especificar propietats al consctructor, segona aproximació</strong></small></p>

<p>Fem un cop d'ull a una d'aquestes definicions en detall. Aquesta és la nova definició del constructor de <code>Engineer</code>:</p>

<pre class="brush: js">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
</pre>

<p>Suposem que creem un nou objecte de tipus <code>Engineer</code> de la forma següent:</p>

<pre class="brush: js">var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
</pre>

<p>JavaScript realitza els següents passos:</p>

<ol>
 <li>L'operador new crea un objecte genèric i assigna <code>Engineer.prototype</code> a la propietat <code>__proto__</code> d'aquest nou objecte.</li>
 <li>L'operador new passa el nou objecte al constructor de <code>Engineer</code> com a valor de la paraula clau <code>this</code>.</li>
 <li>El constructor crea una nova propietat anomenada <code>base</code> per a aquest objecte i assigna el valor del constructor de <code>WorkerBee</code> a aquesta propietat. Això fa que el constructor <code>WorkerBee</code> pugui ser emprat com un mètode de l'objecte <code>Engineer</code>. El nom de la propietat base no és especial. Es pot emprar qualsevol nom de propietat que sigui vàlid; <code>base</code> ha estat escollit perquè simplement és adient per al seu propòsit.</li>
 <li>El constructor crida el mètode <code>base</code>, tot passant-li com a arguments dos dels arguments passats al constructor (<code>"Doe, Jane"</code> and <code>["navigator", "javascript"]</code>) i també la string <code>"engineering"</code>. Al passar <code>"engineering"</code> explícitament al constructor tots els objectes de tipus <code>Engineer</code> tindran el mateix valor per a la propietat hertada <code>dept</code>, i aquest valor sobreescriurà el valor heretat de <code>Employee</code>.</li>
 <li>
  <p>Com que base és un mètode de <code>Engineer</code>, durant la crida a base JavaScript assigna a la paraula clau this l'objecte creat al pas 1. D'aquesta forma, la funció <code>WorkerBee</code> passa els arguments <code>"Doe, Jane"</code> i <code>"engineering"</code> a la funció constructora <code>Employee</code>. Un cop la funció constructora <code>Employee</code> ha retornat, la funció <code>WorkerBee</code> utilitza l'argument restant per a assignar un valor a la propietat <code>projects</code>.</p>
 </li>
 <li>Un cop el mètode base ha retornat, el constructor <code>Engineer</code> initialitza la propietat <code>machine</code> de l'objecte al valor <code>"belau"</code>.</li>
 <li>Un cop el constructor ha retornat, JavaScript assigna el nou objecte a la variable <code>jane</code>.</li>
</ol>

<p>Es pot pensar que, debug a que s'ha cridat al constructor <code>WorkerBee</code> des de dins el constructor <code>Engineer</code>, s'ha inicialitzat la herència de forma adequada per als objectes <code>Engineer</code>. No és el cas. Cridar el constructor <code>WorkerBee</code> ens asegura que l'objecte <code>Engineer</code> comença amb les propietats especificades per a totes les funcions constructores que es criden. Però, si més tard afegim propietats als prototipus <code>Employee</code> o <code>WorkerBee</code>, aquestes propietats no són heretades per l'objecte <code>Engineer</code>. Per exemple, suposem que tenim les sentències següents:</p>

<pre class="brush: js">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
Employee.prototype.specialty = "none";
</pre>

<p>L'objecte <code>jane</code> no hereta la propietat <code>specialty</code>. Es fa necesari inicialitzar el prototipus per a assegurar que hi haurà herència de forma dinàmica. Suposem que tenim les sentències següents:</p>

<pre class="brush: js">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;
var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
Employee.prototype.specialty = "none";
</pre>

<p>Ara el valor de la propietat specialty de l'objecte  <code>jane</code> és "none".</p>

<p>Una altra forma d'heretar és mitjançant els mètodes <a href="/en-US/docs/JavaScript/Reference/Global_Objects/Function/call" title="en-US/docs/JavaScript/Reference/Global Objects/Function/call"><code>call()</code></a> / <a href="/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply" title="en-US/docs/JavaScript/Reference/Global Objects/Function/apply"><code>apply()</code></a>. Les funcions següents són equivalents:</p>

<table>
 <tbody>
  <tr>
   <td>
    <pre class="brush: js">
function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
</pre>
   </td>
   <td>
    <pre class="brush: js">
function Engineer (name, projs, mach) {
  WorkerBee.call(this, name, "engineering", projs);
  this.machine = mach || "";
}
</pre>
   </td>
  </tr>
 </tbody>
</table>

<p>Utilitzar el mètode de JavaScript <code>call()</code> esdevé en una implementació més neta perquè ja no es requereix la propietat <code>base</code>.</p>

<h2 id="Un_segon_cop_d'ull_a_la_herència_de_propietats">Un segon cop d'ull a la herència de propietats</h2>

<p>Les seccions anteriors han descrit com utilitzar els constructors de JavaScript i els prototipus per crear jerarquies i proporcionar herència. Aquesta secció explica alguns detalls que poden no haver estat obvis en les seccions anteriors.</p>

<h3 id="Valors_locals_versus_valors_heretats">Valors locals versus valors heretats</h3>

<p>A l'accedir a la propietat d'un objecte, JavaScritp segueix els passos següents, tal i com s'ha descrit abans en aquest mateix capítol:</p>

<ol>
 <li>Es comprova si el valor existeix de forma local. En cas afirmatiu es retorna aquest valor.</li>
 <li>Si ho hi ha valor local, es cerca a la cadena de prototipus (mitjançant la propietat<code> __proto__</code>).</li>
 <li>Si un objecte de la cadena de prototipus té un valor per la propietat especificada, es retorna aquest valor.</li>
 <li>Si no es troba aquesta propietat, s'infereix que l'objecte no té aquesta propietat.</li>
</ol>

<p>El resultat d'aquests passos depèn de com s'hagin definit les coses. L'exemple original disposaba de les següents definicions:</p>

<pre class="brush: js">function Employee () {
  this.name = "";
  this.dept = "general";
}

function WorkerBee () {
  this.projects = [];
}
WorkerBee.prototype = new Employee;
</pre>

<p>Amb aquestes definicions, suposem que creem amy com una instància de WorkerBee amb la sentència següent:</p>

<pre class="brush: js">var amy = new WorkerBee;
</pre>

<p>L'objecte <code>amy</code> té una propietat local, <code>projects</code>. Els valors per a les propietats <code>name</code> i <code>dept</code> no són locals per a <code>amy</code> i en conseqüència s'obtenen a partir de la propietat <code>__proto__</code> de <code>amy</code>. Així, <code>amy</code> té els següents valors a les seves propietats:</p>

<pre class="brush: js">amy.name == "";
amy.dept == "general";
amy.projects == [];
</pre>

<p>Ara suposem que canviem el valor de la propietat <code>name</code> en el prototipus associat a <code>Employee</code>:</p>

<pre class="brush: js">Employee.prototype.name = "Unknown"
</pre>

<p>A primer cop d'ull podeu pensar que el nou valor es propagarà afectant a totes les instàncies de <code>Employee</code>. Tanmateix això no succeeix.</p>

<p>Quan es crea <em>qualsevol</em> instància de l'objecte <code>Employee</code>, aquesta instància un valor local per a la propietat <code>name</code> (la cadena buida). Això vol dir que quan s'assigna el prototipus <code>WorkerBee</code> al crear un nou objecte <code>Employee</code>, <code>WorkerBee.propotype</code> té un valor local per a la propietat <code>name</code>. Així, quan JavaScript cerca la propietat <code>name</code> per a l'objecte <code>amy</code> (una instància de <code>WorkerBee</code>), JavaScript trova la variable local per a aquesta propietat a <code>WorkerBee.prototype</code>. Degut a això no cerca la propietat més enllà dins la cadena de prototipus, cap a <code>Employee.prototype</code>.</p>

<p>Si es vol canviar el valor de la propietat d'un objecte en temps d'execució i que el nou valor sigui heretat per tots els descendents d'un objecte, no es pot definir la propietat dins la funció constructora de l'objecte. En comptes d'això, s'afegeix al constructor del protipus associat. Per exemple, suposem que canviem el codi anterir pel següent:</p>

<pre class="brush: js">function Employee () {
  this.dept = "general";
}
Employee.prototype.name = "";

function WorkerBee () {
  this.projects = [];
}
WorkerBee.prototype = new Employee;

var amy = new WorkerBee;

Employee.prototype.name = "Unknown";
</pre>

<p>En aquest cas, la propietat <code>name</code> de <code>amy</code> esdevé "Unknown".</p>

<p>Tal i com mostren els exemples, si es vol tenir un valor predefinit per a les propietats d'un objecte i es vol poder canviar aquest valor predefinit en temps d'execució, les propietats s'han d'assignar al constructor del prototipus i no a la funció constructora de l'objecte mateix.</p>

<h3 id="Determining_instance_relationships">Determining instance relationships</h3>

<p>Property lookup in JavaScript looks within an object's own properties and, if the property name is not found, it looks within the special object property <code>__proto__</code>. This continues recursively; the process is called "lookup in the prototype chain".</p>

<p>The special property <code>__proto__</code> is set when an object is constructed; it is set to the value of the constructor's <code>prototype</code> property. So the expression <code>new Foo()</code> creates an object with <code>__proto__ == <code class="moz-txt-verticalline">Foo.prototype</code></code>. Consequently, changes to the properties of <code class="moz-txt-verticalline">Foo.prototype</code> alters the property lookup for all objects that were created by <code>new Foo()</code>.</p>

<p>Every object has a <code>__proto__</code> object property (except <code>Object</code>); every function has a <code>prototype</code> object property. So objects can be related by 'prototype inheritance' to other objects. You can test for inheritance by comparing an object's <code>__proto__</code> to a function's <code>prototype</code> object. JavaScript provides a shortcut: the <code>instanceof</code> operator tests an object against a function and returns true if the object inherits from the function prototype. For example,</p>

<pre class="brush: js">var f = new Foo();
var isTrue = (f instanceof Foo);</pre>

<p>For a more detailed example, suppose you have the same set of definitions shown in <a href="#Inheriting_properties">Inheriting properties</a>. Create an <code>Engineer</code> object as follows:</p>

<pre class="brush: js">var chris = new Engineer("Pigman, Chris", ["jsd"], "fiji");
</pre>

<p>With this object, the following statements are all true:</p>

<pre class="brush: js">chris.__proto__ == Engineer.prototype;
chris.__proto__.__proto__ == WorkerBee.prototype;
chris.__proto__.__proto__.__proto__ == Employee.prototype;
chris.__proto__.__proto__.__proto__.__proto__ == Object.prototype;
chris.__proto__.__proto__.__proto__.__proto__.__proto__ == null;
</pre>

<p>Given this, you could write an <code>instanceOf</code> function as follows:</p>

<pre class="brush: js">function instanceOf(object, constructor) {
   object = object.__proto__;
   while (object != null) {
      if (object == constructor.prototype)
         return true;
      if (typeof object == 'xml') {
        return constructor.prototype == XML.prototype;
      }
      object = object.__proto__;
   }
   return false;
}
</pre>

<div class="note"><strong>Note:</strong> The implementation above checks the type of the object against "xml" in order to work around a quirk of how XML objects are represented in recent versions of JavaScript. See {{ bug(634150) }} if you want the nitty-gritty details.</div>

<p class="note">Using the <code>instanceOf</code> function defined above, these expressions are true:</p>

<pre class="brush: js">instanceOf (chris, Engineer)
instanceOf (chris, WorkerBee)
instanceOf (chris, Employee)
instanceOf (chris, Object)
</pre>

<p>But the following expression is false:</p>

<pre class="brush: js">instanceOf (chris, SalesPerson)
</pre>

<h3 id="Informació_global_als_constructors">Informació global als constructors</h3>

<p>A l'hora de crear constructors cal anar amb compte si es manega informació global dins el constructor. Per exemple, suposem que volem crear un identificador (ID) únic que serà assignat automàticament per a cada nou <code>Employee</code>. Podríem utilitzar la definició següent per a <code>Employee</code>:</p>

<pre class="brush: js">var idCounter = 1;

function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   this.id = idCounter++;
}
</pre>

<p>Amb aquesta definició quan es crea un nou <code>Employee</code>, el constructor assigna la següent ID seqüencialment i llavors incrementa el valor del contador global de ID. Així, suposant el codi següent, tenim que <code>victoria.id</code> val 1 i <code>harry.id</code> val 2:</p>

<pre class="brush: js">var victoria = new Employee("Pigbert, Victoria", "pubs")
var harry = new Employee("Tschopik, Harry", "sales")
</pre>

<p> </p>

<p>At first glance that seems fine. However, <code>idCounter</code> gets incremented every time an <code>Employee</code> object is created, for whatever purpose. If you create the entire <code>Employee</code> hierarchy shown in this chapter, the <code>Employee</code> constructor is called every time you set up a prototype. Suppose you have the following code:</p>

<pre class="brush: js">var idCounter = 1;

function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   this.id = idCounter++;
}

function Manager (name, dept, reports) {...}
Manager.prototype = new Employee;

function WorkerBee (name, dept, projs) {...}
WorkerBee.prototype = new Employee;

function Engineer (name, projs, mach) {...}
Engineer.prototype = new WorkerBee;

function SalesPerson (name, projs, quota) {...}
SalesPerson.prototype = new WorkerBee;

var mac = new Engineer("Wood, Mac");
</pre>

<p>Ara suposem que les definicions omeses aquí tenen la propietat <code>base</code> i criden el constructor que tenen damunt de la cadena de prototipus. En aquest cas, quan es crea l'objecte <code>mac</code>, <code>mac.id</code> rep el valor de 5.</p>

<p>Depenent de l'aplicació, el fet que el contador s'incrementi aquests cops adicionals pot tenir o no conseqüències. Si el valor exacte d'aquest contador és important una possible solució pot ser el constructor següent:</p>

<pre class="brush: js">function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   if (name)
      this.id = idCounter++;
}
</pre>

<p>Al crear una instància de <code>Employee</code> per a ser emprada com a prototipus, no es passen paràmetres al constructor. Aquesta definició del constructor no assigna un valor a la id i no actualitza el contador quan el constructor no rep paràmetres. Així, per a que un <code>Employee</code> rebi una id, requerim que rebi un nom. Executar l'exemple anterior amb el nou constructor esdevindrà en que <code>mac.id</code> rebi el valor 1.</p>

<h3 id="No_hi_ha_herència_múltiple">No hi ha herència múltiple</h3>

<p>Alguns llenguatges orientats a objectes permeten l'herència múltiple, és a dir, que un objecte pugui heretar propietats i valors de pares que no tenen res a veure entre ells. JavaScript no suporta l'herència múltiple.</p>

<p>L'herència de valors de propietats succeeix en temps d'execució i és proporcionada per fet que JavaScript cerqui un valor dins la cadena de prototipus de l'objecte. Com que un objecte disposa d'un sol prototipus associat a ell JavaScript no pot heretar dinàmicament de més d'una cadena de prototipus.</p>

<p>A JavaScript, però, es pot fer que una funció constructora cridi a més d'una funció constructora dins d'ella. Això crea la ilusió d'herència múltiple. Per exemple, suposem les sentències següents:</p>

<pre class="brush: js">function Hobbyist (hobby) {
   this.hobby = hobby || "scuba";
}

function Engineer (name, projs, mach, hobby) {
   this.base1 = WorkerBee;
   this.base1(name, "engineering", projs);
   this.base2 = Hobbyist;
   this.base2(hobby);
   this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;

var dennis = new Engineer("Doe, Dennis", ["collabra"], "hugo")
</pre>

<p>Ara suposem que la definició de WorkerBee és l'emprada abans en aquest capítol. En aquest case l'objecte <code>dennis</code> rep les propietats següents:</p>

<pre class="brush: js">dennis.name == "Doe, Dennis"
dennis.dept == "engineering"
dennis.projects == ["collabra"]
dennis.machine == "hugo"
dennis.hobby == "scuba"
</pre>

<p>Així tenim que dennis rep la propietat <code>hobby</code> del constructor <code>Hobbyist</code>. Tot i així, suposem llavors que afegim una propietat al constructor del prototipus <code>Hobbyist</code>:</p>

<pre class="brush: js">Hobbyist.prototype.equipment = ["mask", "fins", "regulator", "bcd"]
</pre>

<p>L'objecte <code>dennis</code> no hereta aquesta nova propietat.</p>

<div>{{PreviousNext("Web/JavaScript/Guide/Working_with_Objects", "Web/JavaScript/Guide/Iterators_and_Generators")}}</div>
