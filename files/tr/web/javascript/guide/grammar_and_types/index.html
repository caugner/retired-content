---
title: Dil bilgisi ve türler
slug: Web/JavaScript/Guide/Grammar_and_types
tags:
  - JavaScript
  - Rehber
translation_of: Web/JavaScript/Guide/Grammar_and_types
---
<p>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}</p>

<p class="summary">Bu bölümde JavaScript'in temel dil bilgisi, değişken tanımları, veri türleri ve sabitleri üzerine değinilecektir.</p>

<h2 id="Temeller">Temeller</h2>

<p>JavaScript çoğu söz dizimini Java'dan almıştır. Awk, Perl and Python'dan da etkilenmiştir.</p>

<p>JavaScript büyük-küçük harfe duyarlıdır ve <strong>Unicode </strong>karakter setini kullanır.</p>

<p>JavaScript'te, komutlara {{Glossary("Statement", "statements")}} denir ve noktalı virgül (;) ile ayrılırlar. Boşluklara, tablara ve satırbaşı karakterlerine whitespace denir. JavaScript betiklerinde, kaynak metin soldan sağa taranır ve token, kontrol karakterleri, satır sonlayıcıları, yorumlar ve whitespace gibi girdi elemanları dizisine dönüştürülür. ECMAScript, bazı kelimeleri ve sabitleri tanımlamıştır ayrıca noktalı virgül (;) karakterinin komut sonlarına otomatik olarak eklenmesi için kurallar belirlemiştir. Ancak kodda herhangi bir yan etki oluşturmaması için komut sonlarına her zaman noktalı virgül konması önerilir.  Daha fazla bilgi için JavaScript'in <a href="/en-US/docs/Web/JavaScript/Reference/Lexical_grammar">sözcük dil bilgisi</a> hakkındaki başvurusuna bakınız.</p>

<h2 id="Yorumlar">Yorumlar</h2>

<p>Yorumların söz dizimi C++ ve çoğu diğer dillerde olduğu şekilde aynıdır:</p>

<pre class="brush: js">// Tek satırlık yorum.

/* *
 * Bu ise daha uzun,
 * çok satırlı yorum.
 */

/* Ancak /* iç içe yorum */  konulması söz dizimi hatasına yol açar<code> */</code></pre>

<h2 id="Bildirimler">Bildirimler</h2>

<p>JavaScript'te üç çeşit bildirim vardır:</p>

<p>{{jsxref("Statements/var", "var")}}</p>

<dl>
 <dd>Bir değişkeni tanımlar, isteğe bağlı olarak değer ataması yapılır.</dd>
 <dt>{{experimental_inline}} {{jsxref("Statements/let", "let")}}</dt>
 <dd>Etki alanı kod bloğudur, yerel değişken tanımlar, isteğe bağlı olarak değer ataması yapar.</dd>
 <dt>{{experimental_inline}} {{jsxref("Statements/const", "const")}}</dt>
 <dd>Salt okunur değişken tanımlar.</dd>
</dl>

<h3 id="Değişkenler">Değişkenler</h3>

<p>Uygulamalarınızda, verilerin sembolik birer gösterimi olarak değişkenleri kullanırsınız. Değişkenlerin isimine {{Glossary("Identifier", "identifiers")}} denir ve kesin kurallar çerçevesinde oluşturulurlar.</p>

<p>JavaScript'te değişken adı; bir harfle, alt tire (_) ile veya dolar işareti ($) ile başlamalıdır; ardından rakamlar gelebilir (0-9). JavaScript'in büyük-küçük harfe duyarlı olmasından dolayı, harfler büyük harf (A'dan Z'ye) ve küçük harf (a'dan z'ye) içerebilirler. </p>

<p>Değişken adları için å ve ü gibi Unicode harfleri bulunan ISO 8859-1 standardındaki karakter setini kullanabilirsiniz. Ayrıca değişkenlerdeki karakterler olarak, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#String_literals">Unicode kaçış karakterlerini</a> kullanabilirsiniz.</p>

<p>Bir kaç uygun örnek: <code>Popüler_şarkılar, jamesBond007, _isim</code>.</p>

<h3 id="Değişken_tanımlama">Değişken tanımlama</h3>

<p>Bir değişkeni üç yolla tanımlayabilirsiniz:</p>

<ul>
 <li>{{jsxref("Statements/var", "var")}} kelimesi ile. Örneğin, <code>var x = 42</code>. Bu söz dizimi hem yerel hem global değişkenler bildirebilir.</li>
 <li>Sadece değer vererek. Mesela, <code>x = 42</code>. Bu şekilde daima global bir değişken tanımlanır. Tanımlandığı zaman JavaScript uyarı verir. Bu yüzden böyle bir tanımlama yapmamalısınız.</li>
 <li>{{jsxref("Statements/let", "let")}} kelimesi ile. Örneğin, <code>let y = 13</code>. Bu şekilde blok seviyesinde yerel değişken tanımlanmış olur. Yani y=13 değerinin etki alanı içinde bulunduğu kod bloğu (statement) 'dur. Daha fazlası için aşağıdaki <a href="https://developer.mozilla.org/tr/docs/Web/JavaScript/Guide/Grammar_and_types#Değişkenin_etki_alanı">Değişkenin etki alanı</a> kısmına bakabilirsiniz. </li>
</ul>

<h3 id="Değişkenlerin_değerlendirilmesi">Değişkenlerin değerlendirilmesi</h3>

<p><code>var</code> veya <code>let</code> komutuyla başlangıç değer ataması yapmadan tanımlanan değişkenler, {{jsxref("undefined")}} değerine sahiptirler.</p>

<p>Değer ataması yapılmayan bir değişkene erişilmeye çalışıldığında {{jsxref("ReferenceError")}} hatası alınır:</p>

<pre><code>var a;
console.log("a'nın değeri " + a); // a'nın değeri undefined

var b;
console.log("b'nın değeri " + b); // b'nin değeri undefined

console.log("c'nin değeri " + c); // </code>
Yakalanmamış Referans Hatası<code>: c değeri tanımlanamadı

let x;
console.log("x'in değeri " + x); // x'in değeri undefined

console.log("y'in değeri " + y); // </code>
Yakalanmamış Referans Hatası<code>: y değeri tanımlanamadı
let y;</code></pre>

<p><code>undefined</code>'ı, bir değişkenin herhangi bir değere sahip olup olmadığını kontrol etmek için kullanabilirsiniz.  Aşağıdaki kod parçasında girdi değişkenine değer atanmamıştır ve <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/if...else" title="en-US/docs/JavaScript/Reference/Statements/if...else">if</a> </code>ifadesi doğru olarak değerlendirileceği için bunuYap(); metodu çalıştırılmış olur. </p>

<pre class="brush: js">var girdi;
if(girdi === undefined){
  bunuYap();
} else {
  sunuYap();
}
</pre>

<p>Eğer <code>undefined</code> değeri boolean bir kontrol deyiminde (<code>if, while</code> vb.) kullanılırsa  yanlış <code>(false) </code>çıktı verecek şekilde davranır . Örneğin, aşağıdaki kodda <code>benimDizim </code>değişkeni tanımsız olduğu için <code>yap() </code>fonksiyonu çalıştırılır:</p>

<pre class="brush: js">var benimD<code>izim</code> = [];
if (!benimD<code>izim</code>[0]) yap();
</pre>

<p>Eğer <code>undefined</code> değeri sayısal bir içerikte kullanıldığında <code>NaN</code> (sayı değil) değerini alır.</p>

<pre class="brush: js">var a;
a + 2;  // NaN sonucunu verir</pre>

<p>{{jsxref("null")}} değişkeni sayısal bir içerikte kullanıldığında 0, boolean bir içerikte kullanıldığında ise <code>false</code> gibi davranır. Örneğin:</p>

<pre class="brush: js">var n = null;
console.log(n * 32); // ekrana 0 yazdırır
</pre>

<h3 id="Değişkenin_etki_alanı">Değişkenin etki alanı</h3>

<p>Herhangi bir fonksiyon etki alanının dışında bir değişken tanımladığınız zaman, <em>global</em> değişken tanımlamış olursunuz. Bu sayede JavaScript dokümanı içerisinde herhangi bir kod parçası bu değişkene erişilebilir. Bir fonksiyon etki alanı içerisinde değişken tanımladığınızda <em>local (yerel) </em> değişken tanımlamış olursunuz. Bu sayede değişkene sadece o fonksiyon içerisinden erişilebilir.</p>

<p>ECMAScript 6'dan önceki JavaScript'te, <a href="/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#Block_statement" title="en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#Block_statement">blok seviyesinde</a> etki alanı yoktur; bilâkis, blok içerisinde tanımlanan değişken, o bloğun bulunduğu fonksiyonda (veya global etki alanında) yerel olarak tanımlanmış olur. Örneğin aşağıdaki kod ekrana 5 değerini yazdırır. Çünkü x'in etki alanı, if bloğu içerisinde değil, x'in tanımlandığı fonksiyonda (veya globalde) yer almaktadır.</p>

<pre class="brush: js">if (true) {
  var x = 5;
}
console.log(x);  // 5
</pre>

<p>ECMAScript 2015'te belirlenen <code>let </code>ifadesi ile kullanılırsa, çıktı değişkenlik gösterebilir. Çünkü let ifadesi global alanı değil if bloğunun alanını etki alanı olarak ele alır ve y değişkeni, JavaScript tarafından tanımsız olarak değerlendirileceği için hata döndürür:</p>

<pre class="brush: js">if (true) {
  let y = 5;
}
console.log(y);  // Uncaught ReferenceError: y is not defined
</pre>

<h3 id="Değişkeni_yukarı_alma_hoisting">Değişkeni yukarı alma (hoisting)</h3>

<p>JavaScript'teki değişkenler hakkında bir sıradışı olay ise, tanımladığınız bir değişkene daha önceki satırda hata almadan erişebiliyor olmanızdır. Bu kavram <strong>hoisting (yukarı alma) </strong>olarak bilinir; JavaScript'te tanımlanan değişkenler bir anlamda fonksiyon veya ifadenin üzerine alınmış (hoisted) olarak ele alınır. Yukarı alınan değişkenler atandıkları değer yerine <code>undefined </code>değerini alırlar. Hatta bu değişkeni kullandıktan sonra tekrar tanımlarsanız, yine undefined sonucunu alırsınız.</p>

<pre class="brush: js">/**
 * Örnek 1
 */
console.log(x === undefined); // "true" yazar
var x = 3;

/**
 * Örnek 2
 */
// undefined değeri alacak
var degiskenim = "değerim";

(function() {
  console.log(degiskenim); // undefined
  var degiskenim = "yerel değerim";
})();
</pre>

<p>Üstteki örnekler bilgisayar tarafından aşağıdaki şekilde yorumlanır:</p>

<pre class="brush: js">/**
 * Örnek 1
 */
var x;
console.log(x === undefined); // "true" yazar
x = 3;

/**
 * Örnek 2
 */
var degiskenim = "değerim";

(function() {
  var degiskenim;
  console.log(degiskenim); // undefined yazar
  degiskenim = "yerel değerim";
})();
</pre>

<p>Yukarı alma ile ilgili sorunların yaşanmaması için, fonksiyon içerisinde yer alan bütün değişken tanımları olabildiğince en üste taşınmalıdır. Değişken tanımlamanın en iyi yöntemi de zaten budur. Bu sayede kodun okunabilirliği artmış olur. </p>

<p>ECMAScript 2015'te, <code>let</code> veya <code>const</code> ifadesi ile tanımlanan değişken, üste alınmaz. Değişken tanımından önce o değişkenin kullanılmaya çalışılırsa {{jsxref("ReferenceError")}} hatası ile sonuçlanır. Değişken, bloğun başlangıcından itibaren tanımının yapıldığı yere kadar ölü bölgededir.</p>

<h3 id="Fonksiyonu_yukarı_alma">Fonksiyonu yukarı alma</h3>

<p>Fonksiyonlarda, yalnızca fonksiyon tanımı yukarı alınır. Fonksiyon ifadesine erişilmeye çalışıldığında ise hata oluşur.</p>

<pre class="brush: js">/* fonksiyon tanımlama */

foo(); // "bar"

function foo() {
  console.log('bar');
}


/* fonksiyon ifadesi */

baz(); // TypeError: baz is not a function

var baz = function() {
  console.log('bar2');
};
</pre>

<h3 id="Global_değişkenler">Global değişkenler</h3>

<p>Global değişkenler aslında temel bir <em>global nesne</em>nin özellikleridirler. Web sayfalarında bulunan global nesnenin adı {{domxref("window")}} 'dur. Böylece global değişkenlere, <code>window.<em>variable</em></code> söz dizimi kullanılarak erişilebilir.</p>

<p>Sonuç olarak, herhangi bir window veya iframe'deki global değişkenlere, diğer window veya iframe üzerinden değişkenin ismi kullanılarak erişilebilir. Örneğin, eğer bir dokümanda <code>telefonNumarası</code> isminde bir değişken tanımlanmışsa, bu değişkene iframe içerisinden <code>parent.telefonNumarası</code> şeklinde erişebilirsiniz.</p>

<h3 id="Sabitler">Sabitler</h3>

<p>{{jsxref("Statements/const", "const")}} anahtar kelimesi ile sabit bir değişken oluşturabilirsiniz. Sabit değerler için söz dizimi, değişken değerleri ile aynıdır: bir harf, alt çizgi veya dolar işareti ile başlamalıdırlar, devamında ise alfabetik, sayısal veya alt çizgi gibi karakterler gelebilir.</p>

<pre><code>const PI = 3.14;</code></pre>

<p>JavaScript kodu çalışırken bir sabitin değeri, atama yapılarak değiştirilemez ve sabit tekrar tanımlanamaz. Ayrıca sabitlere başlangıçta tanımlanırken bir değer atanması zorunludur.</p>

<p>Sabitlerin etki alanı <code>let </code>bloğunun etki alanındaki değişkenler ile aynıdır. Eğer <code>const </code>ifadesi çıkarılırsa, ifade artık değişken haline gelir.</p>

<p>Bir etki alanında, halihazırda bir fonksiyon veya değişken varsa, aynı isimli sabit tanımlamak hataya yol açar. Örneğin:</p>

<pre class="example-bad brush: js">// BU HATAYA NEDEN OLUR
function f() {};
const f = 5;

// BU DA HATAYA NEDEN OLUR
function f() {
  const g = 5;
  var g;
}
</pre>

<p>Sabit bir nesneye atanan özellikler diğer fonksiyonların kullanımına karşı korunmamışlardır ve nesnenin kendisi sabit olmasına rağmen değişken değerler alabilirler. Bu sebeple aşağıdaki ifade sorunsuz bir şekilde çalışır.</p>

<pre><code>const BENIM_NESNEM = {"anahtar": "değer"};
BENIM_NESNEM.anahtar = "diğerDeğer";</code></pre>

<h2 id="Veri_yapıları_ve_tipleri">Veri yapıları ve tipleri</h2>

<h3 id="Veri_tipleri">Veri tipleri</h3>

<p>Son yayınlanan ECMAScript standardı ile yedi veri tipi tanımlanabilir:</p>

<ul>
 <li>Altı adet veri türü {{Glossary("Primitive", "primitives")}}'dir:
  <ul>
   <li>{{Glossary("Boolean")}}. <code>true</code> ve <code>false</code>.</li>
   <li>{{Glossary("null")}}. <code>null</code> değeri belirten özel anahtar kelime. JavaScript büyük-küçük karaktere duyarlı olduğu için, <code>null</code> ifadesi <code>Null</code>, <code>NULL</code>, veya diğer değişkenler ile aynı değildir.</li>
   <li>{{Glossary("undefined")}}. Değeri tanımsız olan özellikler için <code>undefined</code>'tır.</li>
   <li>{{Glossary("Number")}}. <code>42</code> ya da <code>3.14159</code>.</li>
   <li>{{Glossary("String")}}. "Zafer"</li>
   <li>{{Glossary("Symbol")}} (ECMAScript 6 ile yeni geldi). Özellikleri eşsiz (unique) ve değiştirilemez (immutable) olan nesnelerdir.</li>
  </ul>
 </li>
 <li>ve {{Glossary("Object")}} veri türü</li>
</ul>

<p>Veri tipleri nispeten az miktarda olmalarına rağmen, uygulamalarınızla yararlı işlevler oluşturmanıza olanak sağlarlar. {{jsxref("Object", "Objects")}} (nesneler) ve {{jsxref("Function", "functions")}} (fonksiyonlar) dilin diğer temel elemanlarıdırlar. Nesneleri, değerleriniz için isimlendirilmiş kutular, fonksiyonları (functions) ise uygulamanızın gerçekleştirebileceği işlevler olarak düşünebilirsiniz.</p>

<h3 id="Veri_tipi_dönüşümü">Veri tipi dönüşümü</h3>

<p>JavaScript dinamik tipli bir dildir. Bunun anlamı, bir değişken tanımlarken, veri tipini belirtme zorunluluğunuzun olmaması ve değişkenin veri tipinin çalışma esnasında ihtiyaç olunan tipe otomatik olarak dönüştürülmesidir. Örneğin sayısal bir değişken tanımlayabilirsiniz:</p>

<pre class="brush: js">var yanit = 42;
</pre>

<p>Ve sonra, aynı değişkene string bir değer atayabilirsiniz:</p>

<pre class="brush: js">yanit = "Hoşçakal, balık için teşekkürler...";
</pre>

<p>JavaScript dinamik tipli olduğu için, bu atama bir hata vermez.</p>

<p>Bir string ve sayının toplama işlemine konulması ile JavaScript otomatik olarak sayısal değeri string ifadeye çevirir ve eklenecek string ile birleştirir. Örneğin aşağıdaki ifadelere bakalım:</p>

<pre class="brush: js">x = "Cevap " + 42 // "Cevap 42"
y = 42 + " cevaptır." // "42 cevaptır."
</pre>

<p>Toplama işlemi dışındaki diğer işlemlerde JavaScript otomatik olarak tür dönüşümü yapmaz. Örneğin:</p>

<pre class="brush: js">"37" - 7 // 30
"37" + 7 // "377"
</pre>

<h3 id="String_ifadelerin_sayısal_değerlere_dönüştürülmesi">String ifadelerin sayısal değerlere dönüştürülmesi</h3>

<p>Bellekte sayısal bir ifadeyi temsil eden bir string'in olduğu durumlarda tip dönüşümü yapmak için aşağıdaki metodları kullanabilirsiniz: </p>

<ul>
 <li id="parseInt()_and_parseFloat()">{{jsxref("parseInt", "parseInt()")}}</li>
 <li>{{jsxref("parseFloat", "parseFloat()")}}</li>
</ul>

<p><code>parseInt</code> fonksiyonu sadece tam sayı döndürür, bu yüzden ondalık sayılarla kullanıldığında ondalık kısmını atar. Buna ek olarak parseInt'in en uygun kullanımlarından biri de sayının hangi tabanda (2'lik, 10'luk, 16'lık vb.) yazılabileceğini parametre olarak fonksiyona verebilmenizdir. Taban parametresi hangi sayısal sistemin kullanılacağının belirlenmesini sağlar.</p>

<p>String ifadelerin, sayısal ifadelere dönüştürülmesinin diğer bir yolu da, string ifadenin başına + operatörünün eklenmesidir:</p>

<pre class="brush: js">"1.1" + "1.1" = "1.11.1"
(+"1.1") + (+"1.1") = 2.2
// Not: parantezler gösterim kolaylığı için konulmuştur, zorunlu değildir.</pre>

<h2 id="Değişken_değerleri">Değişken değerleri</h2>

<p>JavaScript'te değişkenlerin temsil edilmesi için değerler kullanırsınız. Bunlar, kodunuzda değişkenlere <code>=</code> operatöründen sonra atadığınız değerlerdir. Bu kısımda aşağıdaki değer tiplerini inceleyeceğiz:</p>

<ul>
 <li>{{anch("Dizi değerleri")}}</li>
 <li>{{anch("Boolean değerleri")}}</li>
 <li>{{anch("Ondalıklı-sayı değerleri")}}</li>
 <li>{{anch("Tam sayılar")}}</li>
 <li>{{anch("Nesne değerleri")}}</li>
 <li>{{anch("String değerleri")}}</li>
</ul>

<h3 id="Dizi_değerleri">Dizi değerleri</h3>

<p>Bir dizi değeri 0 veya daha fazla ifadeden oluşan liste biçimindedir, liste başında ve sonunda listeyi açıp/kapatan köşeli parantezler [ ] bulunur. Bir dizi oluşturup bu diziye değerler atadığınızda, belirlediğiniz değerleri kendi elemanı olarak barındıran bir dizi üretilir ve dizinin uzunluğu belirlediğiniz değer sayısı kadardır.</p>

<p>Aşağıdaki örnekte, 3 elemanı barındıran ve bu nedenle 3 uzunluğunda olan <code style="font-style: normal; font-weight: normal;">kahveler</code> isimli bir dizi oluşturulmaktadır:</p>

<pre class="brush: js">var kahveler = ["Türk kahvesi", "Espresso", "Mocha"];
</pre>

<div class="note">
<p><strong>Not :</strong> Bir dizi değeri, bir nesne başlatıcısı türündedir. Dahası için bkz: <a href="/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Using_object_initializers" title="en-US/docs/JavaScript/Guide/Working with Objects#Using Object Initializers">Nesne başlatıcılarının kullanımı</a>.</p>
</div>

<p>Eğer bir dizi, üst-seviye betikte sabit değer kullanarak oluşturulmuşsa JavaScript, bu diziyi içeren her ifadeyi çalıştırdığında diziyi yorumlar. Buna ek olarak, fonksiyon içerisinde tanımlanan diziler, her fonksiyon çağrımında yeni bir dizi olarak bellekte oluşturulur.</p>

<p>Dizi değerleri ayrıca <code>Array</code> nesneleridirler. Detaylı bilgi için {{jsxref("Array")}} ve <a href="/en-US/docs/Web/JavaScript/Guide/Indexed_collections">Index'li koleksiyonlar</a> kısmına bakınız.</p>

<h4 id="Dizi_değerleri_arasında_bulunan_fazladan_virgül">Dizi değerleri arasında bulunan fazladan virgül</h4>

<p>Dizi tanımlarken her değeri belirlemek zorunda değilsiniz. Eğer iki tane virgülü art arda koyarak dizi oluşturursanız, virgüller arasında kalan tanımlanmayan her değer için <code>undefined</code> değeri üretilir. Aşağıdaki örnekte bir <code>balık</code> dizisi oluşturulmaktadır:</p>

<pre class="brush: js">var balik = ["Japon", , "Melek"];
</pre>

<p>Bu dizi değerlere sahip 2 elemana ve bir tane boş elemana sahiptir (<code>balik</code><code>[0]</code> = "Japon", <code>balik[1]</code> = <code>undefined</code>, ve <code>balik[2]</code> = "Melek").</p>

<p>Eğer dizideki elemanların sonuna virgül koyarsanız virgül, JavaScript tarafından görmezden gelinir. Aşağıdaki örnekte bulunan dizinin uzunluğu üçtür. <code>dizi[3]'</code>ü ifade eden herhangi bir eleman bulunmamaktadır. Listedeki diğer virgüller, undefined değerine sahip yeni bir elemanı ifade eder. </p>

<div class="note">
<p><strong>Not :</strong> Sona konan virgüller, eski versiyonlu tarayıcılarda hatalara neden olur. Yapılacak en doğru şey, dizi sonlarında kullanılan virgüllerin kaldırılmasıdır.</p>
</div>

<pre class="brush: js">var dizi = ['ev', , 'okul', ];
</pre>

<p>Aşağıdaki örnekte oluşturulan dizinin uzunluğu, <code>dizi[0]</code> ve <code>dizi[2] </code>değerleri tanımlanmadığı halde 4'tür.</p>

<pre class="brush: js">var dizi = [ , 'ev', , 'okul'];
</pre>

<p>Aşağıdaki bir diğer örnekte, dizinin uzunluğu, <code>dizi[1]</code> ve <code>dizi[3]</code> değerleri tanımlanmadığı halde yine 4'tür. Sadece son virgül görmezden gelinir.</p>

<pre class="brush: js">var dizi = ['ev', , 'okul', , ];
</pre>

<p>Ekstra virgüllerin davranışlarının kavranılması, JavaScript dilinin öğrenilmesi için çok önemlidir, ancak kendi kodunuzu yazarken tanımsız elemanları <code>undefined</code> olarak dizi içerisinde belirlemeniz, kodunuzun okunabilirliğini ve bakım yapılabilirliğini önemli ölçüde arttıracaktır.</p>

<h3 id="Boolean_değerleri">Boolean değerleri</h3>

<p>Boolean tipinde iki çeşit değer bulunur: <code>true</code> (doğru) ve <code>false</code> (yanlış).</p>

<p>İlkel Boolean değerleri olan <code>true</code> ve <code>false</code> ile <em>Boolean</em> nesnesi olan true ve false değerlerini karıştırmayınız. Boolean nesnesi, ilkel olan Boolean veri tipinin alınması ve üzerine bazı ek özellikler getirilmesi ile oluşturulmuştur. Daha fazlası için bkz: {{jsxref("Boolean")}}.</p>

<h3 id="Tam_sayılar">Tam sayılar</h3>

<p>Tam sayılar; ikilik (binary) (2 tabanında), sekizlik (octal) (8 tabanında), onluk (decimal) (10 tabanında), ve onaltılık (hexadecimal) (16 tabanında) temsil edilebilirler.</p>

<ul>
 <li>Başında 0b (veya 0B) yer alan tam sayı ifadeleri ikiliktirler. İkilik tam sayılar sadece 0 ve 1 rakamlardan oluşurlar.</li>
 <li>Başında 0 (sıfır) yer alan tam sayı ifadeleri sekizliktirler. Sekizlik tamsayılar sadece 0-7 arasındaki rakamlardan oluşurlar.</li>
 <li>Onluk tam sayı değeri, 0 (sıfır) ile başlamayan rakamlardan oluşurlar.</li>
 <li>Başında 0x (veya 0X) yer alan tam sayı ifadeleri onaltılıktırlar. Onaltılık tamsayılar, 0-9 arasındaki rakamları içerebildiği gibi aynı zamanda a-f veya A-F arasındaki harfleri de barındırabilirler.</li>
</ul>

<p>Bazı örnek tamsayılar:</p>

<pre class="eval">0, 117 and -345 (onluk, 10 tabanında)
015, 0001 and -077 (sekizlik, 8 tabanında)
0x1123, 0x00111 and -0xF1A7 (onaltılık, "hex" veya 16 tabanında)
0b11, 0b0011 and -0b11 (ikilik, 2 tabanında)
</pre>

<p>Daha fazlası için bkz: <a href="/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Numeric_literals">Sayısal değerler ve sözsel gramer başvurusu</a>.</p>

<h3 id="Ondalıklı_değerler">Ondalıklı değerler</h3>

<p>Bir ondalıklı değer aşağıdaki kısımları içerebilir:</p>

<ul>
 <li>İşaretli olabilen bir onluk sayı ("<code>+</code>" veya "<code>-</code>" ile başlayabilir),</li>
 <li>Bir nokta ("<code>.</code>"),</li>
 <li>Ondalık (noktadan sonra diğer onluk sayı),</li>
 <li>Bir katsayı.</li>
</ul>

<p>Katsayı kısmı  bir "e" veya "E" karakteridir ve devamında işaretli olabilen bir tamsayı gelir. Ondalıklı değerin tanımlanabilmesi için en az bir rakam ve devamında ondalıklı sayı ve katsayı "e" (veya "E") içermelidir.</p>

<p>Özetle söz dizimi aşağıdaki şekildedir:</p>

<pre class="eval">[(+|-)][rakamlar][.rakamlar][(E|e)[(+|-)]rakamlar]
</pre>

<p>Örneğin:</p>

<pre class="eval">3.1415926
-.123456789
-3.1E+12
.1e-23
</pre>

<h3 id="Nesne_değerleri">Nesne değerleri</h3>

<p>Bir nesne değeri, süslü parantezlerle <code>{}</code> çevrili sıfır veya daha fazla özellik ismi ve bu özellikler ile ilişkili değerleri içeren bir listeden oluşur. Bir kod satırının başlangıcında değişken ismi olmadan sadece süslü parantezler ile başlayarak bir nesne <u>oluşturmamanız</u> gerekmektedir. Eğer oluşturursanız, JavaScript nesne başlangıcındaki <code>{</code> karakterini, bir kod bloğuna başlangıç yapılıyormuş gibi yorumlar ve bunun sonucunda ya bir hata mesajı alırsınız, ya da yazdığınız kod beklediğiniz şekilde çalışmaz.</p>

<p>Aşağıda, nesne değerini içeren bir örnek bulunmaktadır. <code>otoGaleri</code> nesnesinin ilk elemanı, "<code>Fiat</code>" değerini barındıran <code>arabam</code> isminde bir özelliği tanımlamaktadır; ikinci elemanı <code>arabaAl</code> özelliğidir ve <code>function</code> <code>(arabaTipleri("Honda"))</code> fonksiyonu çalıştırıldıktan hemen sonra fonksiyonun sonucunu içerir; üçüncü eleman <code>sporArabaAl</code> özelliğidir, halihazırda varolan <code>hayalimdekiAraba</code> değişkenini kullanır.</p>

<pre class="brush: js">var hayalimdekiAraba = "Bugatti";

function arabaTipleri(markaAdı) {
  if (markaAdı == "Wolksvagen") {
    return markaAdı;
  } else {
    return "Üzgünüz, malesef " + markaAdı + " marka araba elimizde bulunmamaktadır.";
  }
}

var otoGaleri = {
    arabam: "Fiat",
    arabaAl: arabaTipleri("Wolksvagen"),
    sporArabaAl: arabaTipleri(hayalimdekiAraba)
};

console.log(otoGaleri.arabam);   // Fiat
console.log(otoGaleri.arabaAl);  // Wolksvagen
console.log(otoGaleri.sporArabaAl); // Üzgünüz, malesef Bugatti marka araba elimizde bulunmamaktadır.
</pre>

<p>Ek olarak, sayısal veya string bir değer, özellik adı veya iç içe olan diğer bir nesnenin adı yerine kullanabilir. Aşağıdaki örnekte bu seçenekleri görebiliriz:</p>

<pre class="brush: js">var otoGaleri = {
    arabalar: {s: "Saab", "j": "Jeep"},
    7: "Mazda"
};

console.log(otoGaleri.arabalar.j); // Jeep
console.log(otoGaleri[7]); // Mazda
</pre>

<p>Nesne özelik adları boş bir string de dahil olmak üzere herhangi bir string ifade olabilirler. Eğer özellik adı geçerli bir JavaScript {{Glossary("Identifier","identifier")}} değilse, tırnak içinde yazılması gereklidir. Buna ek olarak geçersiz olan özellik adlarına, nokta (<code>.</code>) ile erişim yapılamaz, bunun yerine dizi tarzında köşeli parantezler(<code>[]</code>) kullanılır:</p>

<pre class="brush: js">var geçersizÖzellikAdlarıÖrnek = {
  "": "Boş bir string",
  "!": "Ateş!"
}
console.log(geçersizÖzellikAdlarıÖrnek."");   // SyntaxError: Unexpected string
console.log(geçersizÖzellikAdlarıÖrnek[""]);  // Boş bir string
console.log(geçersizÖzellikAdlarıÖrnek.!);    // SyntaxError: Unexpected token !
console.log(geçersizÖzellikAdlarıÖrnek["!"]); // Ateş!</pre>

<p>Diğer örnekler:</p>

<pre class="brush: js">var nesne = {a: "armut", 2: "iki"};
console.log(nesne.a);    // armut
console.log(nesne[2]);   // iki
//console.log(nesne.2);  // Error: missing ) after argument list
//console.log(nesne[a]); // Error: a is not defined
console.log(nesne["a"]); // armut
console.log(nesne["2"]); // iki
</pre>

<h3 id="Düzenli_İfade_RegExp_değerleri">Düzenli İfade (RegExp) değerleri</h3>

<p>Bir düzenli ifade değeri bölü (<code>/</code>) karakterleri arasında ifade edilir. Aşağıda, örnek bir düzenli ifade bulunmaktadır:</p>

<pre><code>var re = /ab+c/;</code></pre>

<h3 id="String_değerleri">String değerleri</h3>

<p>Bir string değer çift tırnak (") veya tek tırnak (') arasında bulunan sıfır veya daha fazla karakterlerin yer almasıyla oluşur. Bir string değer aynı tip tırnak ile sonlanmalıdır; bu nedenle karakterleri kapsayan tırnaklar ya çift tırnak ya da tek tırnak ikililerinden oluşmalıdır. Aşağıdaki örnekte string değerler ifade edilmiştir:</p>

<pre class="eval">"elma"
'armut'
"1234"
"bir satır \n diğer satır"
"Zafer'in kedisi"
</pre>

<p><em>String</em> nesnesinin herhangi bir fonksiyonuna, string değerin sonuna nokta koyarak erişebilir ve çalıştırabilirsiniz—JavaScript otomatik olarak string değeri geçici bir <em>String</em> nesnesine dönüştürür, metodu çağırır, ve sonra oluşan geçici String nesnesini hafızadan siler. Ayrıca <code>String.length</code> özelliğini de string değerinin sonuna <code>.length</code> ekleyerek kullanablirsiniz:</p>

<pre class="brush: js">console.log("Zafer'in kedisi".length);
// Boşluk da dahil olmak üzere, string içerisindeki tüm sembollerin sayısını ekrana yazar.
// Ekrana yazılan değer: 15
</pre>

<p><code>String</code> nesnesine hususi olarak ihtiyaç duymadığınız durumlarda, string değerleri kullanmanız gerekir. <code>String</code> nesneler için bkz: {{jsxref("String")}}.</p>

<h4 id="Özel_karakterlerin_string_değerlerde_kullanımı">Özel karakterlerin string değerlerde kullanımı</h4>

<p>String değerler oluştururken, her zamanki kullandığınız karakterlere ek olarak aşağıdaki şekilde özel karakterler de kullanabilirsiniz:</p>

<pre class="brush: js">"bir satır \n diğer satır"
</pre>

<p>Aşağıdaki tabloda, JavaScript string değerleri içerisinde kullanabileceğiniz özel karakterler listelenmiştir: </p>

<table class="standard-table">
 <caption>Tablo: JavaScript özel karakterleri</caption>
 <thead>
  <tr>
   <th scope="col">Karakter</th>
   <th scope="col">Anlamı</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>\0</code></td>
   <td>Boş değer</td>
  </tr>
  <tr>
   <td><code>\b</code></td>
   <td>Geri silme</td>
  </tr>
  <tr>
   <td><code>\f</code></td>
   <td>Form beslemesi</td>
  </tr>
  <tr>
   <td><code>\n</code></td>
   <td>Yeni satır</td>
  </tr>
  <tr>
   <td><code>\r</code></td>
   <td>Enter karakteri</td>
  </tr>
  <tr>
   <td><code>\t</code></td>
   <td>Tab</td>
  </tr>
  <tr>
   <td><code>\v</code></td>
   <td>Dikey tab</td>
  </tr>
  <tr>
   <td><code>\'</code></td>
   <td>Kesme işareti veya tek tırnak</td>
  </tr>
  <tr>
   <td><code>\"</code></td>
   <td>Çift tırnak</td>
  </tr>
  <tr>
   <td><code>\\</code></td>
   <td>Ters bölü (<code>\</code>) karakteri</td>
  </tr>
  <tr>
   <td><code>\<em>XXX</em></code></td>
   <td>3 adet sekizlik rakamı barındırabilen, ve 0-377 arasındaki XXX değerlerinin Latin-1 kodlaması ile oluşturulduğu karakterdir. Örneğin, sekizlik \251 değeri telif hakkı sembolünü (<strong>©)</strong> ifade eder.</td>
  </tr>
  <tr>
  </tr>
  <tr>
   <td><code>\x<em>XX</em></code></td>
   <td>
    <p>2 adet onaltılık karakteri barındırabilen ve 00-FF arasındaki XX değerlerinin Latin-1 kodlaması ile oluşturduğu karakterdir. Örneğin, onaltılık \xA9 değeri telif hakkı sembolünü (<strong>©)</strong> ifade eder.</p>
   </td>
  </tr>
  <tr>
  </tr>
  <tr>
   <td><code>\u<em>XXXX</em></code></td>
   <td>
    <p>4 adet onaltılık karakteri barındırabilen XXXX değerleri ile belirlenen Unicode karakteridir. Örneğin \u00A9 karakteri, Unicode olarak telif hakkı sembolünü (<strong>©)</strong> ifade eder. Bkz: <a href="/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#String_literals">Unicode kaçış karakterleri</a>.</p>
   </td>
  </tr>
  <tr>
   <td>\u<em>{XXXXX}</em></td>
   <td>Unicode kod noktası kaçış karakterlerini ifade eder. Örneğin, \u{2F804} karakteri, \uD87E\uDC04 ile aynı sembolü ifade eder.</td>
  </tr>
 </tbody>
</table>

<h4 id="Kaçış_karakterleri">Kaçış karakterleri</h4>

<p><span style='color: #3b3c40; font-family: "Open Sans",Arial,sans-serif; font-size: 14px;'>Üstteki tabloda yer almayan karakterlerin başına ters bölü işaretinin konulduğunda, ters bölü işareti göz ardı edilir, fakat bu tarz kullanım artık rafa kaldırılmıştır ve kullanımından kaçınılması gerekir. </span></p>

<p>Bir string değer içerisinde tırnak işaretini kullanabilmeniz için, karakterin başına ters bölü işareti eklemeniz gerekir. Bu kullanıma <strong>tırnaktan kaçış</strong> (<em>escaping</em> the quotation mark) denir. Örneğin:</p>

<pre class="brush: js">var alıntı = "Sebahattin Ali'nin \"Kürk Mantolu Madonna\" adlı kitabını okudu.";
console.log(alıntı);
</pre>

<p>Ekran çıktısı aşağıdaki gibi olacaktır:</p>

<pre class="eval">Sebahattin Ali'nin "Kürk Mantolu Madonna" adlı kitabını okudu.
</pre>

<p>String değer içerisinde ters bölü işaretini kullanabilmeniz için, tekrar bir ters bölü karakteri daha eklemeniz gerekir. Örneğin <code>c:\temp</code> isimli dosya yolunu, bir string olarak aşağıdaki şekilde ifade edebiliriz:</p>

<pre class="brush: js">var geçiciDosyalarDizini = "c:\\temp";
</pre>

<p>Uzun string değerleri satır satır yazmak için tırnak artı tırnak (<code>" + "</code>) işaretleri ile eklemek yerine satır sonuna sadece ters bölü işareti ekleyebilirsiniz. Ters bölü ve satır sonu karakterleri, string değerinden çıkarılmış olarak tek satır halinde döndürülür.</p>

<pre class="brush: js">var metin = "Bu metin \
birçok \
satıra ayrılarak \
oluşturulmuştur."
console.log(metin);  // Ekran çıktısı: Bu metin birçok satıra ayrılarak oluşturulmuştur.
</pre>

<p>JavaScript'in paragrafları tanımlamak için bir söz dizimi bulunmamasına rağmen, her satır sonuna  <code>\n\</code> karakterleri ekleyerek paragraf oluşturabilirsiniz:</p>

<pre class="brush: js">var şiir =
"Sana gitme demeyeceğim \n\
Ama gitme Lavinia \n\
Adını gizleyeceğim \n\
Sen de bilme Lavinia.";
</pre>

<h2 id="Daha_fazlası">Daha fazlası</h2>

<p>Bu bölümde, tanımlamalar ve türler için temel söz dizimleri konuları üzerinde durulmuştur. JavaScript'in dil oluşturucularıyla ilgili daha fazla bilgi edinmek için bu rehberde bulunan aşağıdaki bölümleri inceleyebilirsiniz:</p>

<ul>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling">Kontrol akışı ve hata yakalama</a></li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration">Döngüler ve iterasyon</a></li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions">Fonksiyonlar</a></li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">İfadeler ve operatörler</a></li>
</ul>

<p>Sonraki bölümde, kontrol akışının oluşturulması ve hata yakalamaya göz atacağız.</p>

<p>{{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}</p>
