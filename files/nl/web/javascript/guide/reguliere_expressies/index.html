---
title: Reguliere Expressies
slug: Web/JavaScript/Guide/Reguliere_Expressies
tags:
  - JavaScript
  - RegExp
  - regex
  - reguliere expressies
translation_of: Web/JavaScript/Guide/Regular_Expressions
---
<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Text_formatting", "Web/JavaScript/Guide/Indexed_collections")}}</div>

<p class="summary">Reguliere expressies zijn patronen om combinaties van karakters in strings mee te vinden. In JavaScript zijn reguliere expressies ook objecten. Deze patronen worden gebruikt met de  {{jsxref("RegExp.exec", "exec")}} en {{jsxref("RegExp.test", "test")}} methoden van {{jsxref("RegExp")}}, en met de {{jsxref("String.match", "match")}}, {{jsxref("String.replace", "replace")}}, {{jsxref("String.search", "search")}}, en {{jsxref("String.split", "split")}} methoden van {{jsxref("String")}}. Dit hoofdstuk beschrijft reguliere expressies in JavaScript.</p>

<h2 id="Een_reguliere_expressie_maken">Een reguliere expressie maken</h2>

<p>Een reguliere expressie kan op een van twee manieren gemaakt worden:</p>

<p>Met behulp van een letterlijke reguliere expressie, die bestaat uit een patroon tussen slash-karakters:</p>

<pre class="brush: js">var re = /ab+c/;
</pre>

<p>Letterlijke reguliere expressies worden gecompileerd op het moment dat het script geladen is. Als de reguliere expressie constant blijft kan dit de prestaties verbeteren.</p>

<p>Of door de constructor-functie van het {{jsxref("RegExp")}} object te gebruiken, op de volgende manier:</p>

<pre class="brush: js">var re = new RegExp('ab+c');
</pre>

<p>Het gebruik van de constructor-functie biedt runtime-compilatie van de reguliere expressie. Gebruik de constructor functie als je weet dat het reguliere expressie patroon zal veranderen, of als je het patroon niet weet en uit een andere bron krijgt, zoals input van een gebruiker.</p>

<h2 id="Typen_speciale_karakters">Typen speciale karakters</h2>

<dl>
 <dt><a href="/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions">Stellingen</a></dt>
 <dd>Geven op een bepaalde manier aan dat een overeenkomst mogelijk is. Stellingen bevatten 'lookahead', 'lookbehind' en conditionele expressies.</dd>
 <dt><a href="/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Boundaries">Grenzen</a></dt>
 <dd>Wijzen op de begin- en eindpunten van regels en woorden.</dd>
 <dt><a href="/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes">Karakter Klassen</a></dt>
 <dd>Differentieer tussen verschillende soorten karakters zoals, bijvoorbeeld, tussen letters en cijfers.</dd>
 <dt><a href="/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges">Groepen en Bereiken</a></dt>
 <dd>Geef groepen en bereiken van expressie karakters aan.</dd>
 <dt><a href="/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers">Kwantificeerders</a></dt>
 <dd>Geef hoeveelheden karakters of expressies aan om te vinden.</dd>
 <dt><a href="/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Properties">Unicode Eigenschappen</a></dt>
 <dd>Differentieer op basis van unicode karakter eigenschappen zoals, bijvoorbeeld, hoofd- en kleine letters, wiskundige symbolen, en punctuatie.</dd>
</dl>

<h2 id="Een_reguliere_expressie_schrijven">Een reguliere expressie schrijven</h2>

<p>Een reguliere expressie bestaat uit eenvoudige karakters zoals <code>/abc/</code>, of een combinatie van eenvoudige en speciale karakters, zoals <code>/ab*c/</code> of <code>/Hoofdstuk (\d+)\.\d*/</code>. Het laatste voorbeeld bevat haakjes die gebruikt worden als geheugen mechanisme. De overeenkomst die met dit deel gemaakt is wordt onthouden voor later gebruik., zoals beschreven in <a href="#Using_parenthesized_substring_matches">Using parenthesized substring matches</a>.</p>

<h3 id="Eenvoudige_patronen_gebruiken">Eenvoudige patronen gebruiken</h3>

<p>Eenvoudige patronen bestaan uit karakters waarvoor je een directe overeenkomst wilt vinden. Het patroon <code>/abc/</code> bijvoorbeeld komt alleen overeen met karakter combinaties als de karakters 'abc' samen voorkomen in exact die volgorde. Zo'n overeenkomst zou successvol zijn in de strings "Hi, do you know your abc's?" en "The latest airplane designs evolved from slabcraft." In beide gevallen is de overeenkomst de substring 'abc'. Er is geen overeenkomst met de string 'Grab crab' omdat hoewel het de substring 'ab c' bevat, het niet de precieze substring 'abc' bevat.</p>

<h3 id="Speciale_karakters_gebruiken">Speciale karakters gebruiken</h3>

<p>Als het zoeken naar een overeenkomst meer vergt dan een directe overeenkomst, zoals het vinden van een of meerdere b's, of het vinden van witregels/ruimte, bevat het patroon speciale karakters. Het patroon <code>/ab*c/</code> bijvoorbeeld komt overeen met elke combinatie karakters waarbij een enkele 'a' gevolgd wordt door nul of meerdere b's. (<code>*</code> betekent 0 of meer gevallen van het voorgaande item) en dan onmiddelijk gevolgd door 'c'. In de string "cbbabbbbcdebc," komt het patroon overeen met de substring 'abbbbc'.</p>

<p>Onderstaande tabel geeft een volledige lijst en beschrijving van de speciale karakters die gebruikt kunnen worden in reguliere expressies.</p>

<table class="standard-table">
 <caption>Speciale karakters in reguliere expressies</caption>
 <thead>
  <tr>
   <th scope="col">Karakter</th>
   <th scope="col">Betekenis</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="#special-backslash" id="special-backslash" name="special-backslash"><code>\</code></a></td>
   <td>
    <p>Matched volgens de volgende regels:<br>
     <br>
     Een backslash die voorafgaat aan een niet-speciaal karakter geeft aan dat het volgende karakter speciaal is en niet letterlijk moet worden geïnterpreteerd. Bijvoorbeeld, een 'b' zonder een voorafgaande '\' matched kleine-letter b's waar die ook voorkomen  — Het karakter zal letterlijk worden geïnterpreteerd. Maar de opeenvolging van '\b' komt niet overeen met wat voor karakter dan ook; het duidt op een <a href="#special-word-boundary" title="#special-word-boundary">woordgrens</a>.<br>
     <br>
     Een backslash die voorafgaat aan een speciaal karakter geeft aan dat het volgende karakter niet speciaal is en letterlijk moet worden geïnterpreteerd. Bijvoorbeeld, het patroon <code>/a*/</code> vertrouwt op het speciale karakter '<code>*</code>' om 0 of meerdere a's te matchen. Het patroon <code>/a\*/</code> in contrast, noteert de '<code>*</code>'  als niet-speciaal, wat matches met strings zoals 'a' mogelijk maakt.</p>

    <p>Vergeet niet om de <code>\</code> zelf te escapen bij het gebruiken van de RegExp("patroon") notatie — <code>\</code> is ook een escape karakter in strings.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-caret" id="special-caret" name="special-caret"><code>^</code></a></td>
   <td>Matched het begin van de input. Matched ook direct na een line break karakter als de multiline vlag ingesteld is op 'true'.<br>
    <br>
    Als voorbeeld, <code>/^A/</code> matched niet de 'A' in "uit Amsterdam", maar matched wel de 'A' in "Apenstaartje".<br>
    <br>
    De '<code>^</code>' heeft een verschillende betekenis wanneer het voorkomt als het eerste karakter in een karakterset patroon. Zie <a href="#special-negated-character-set" title="#special-negated-character-set">complemented character sets</a> voor details en een voorbeeld.</td>
  </tr>
  <tr>
   <td><a href="#special-dollar" id="special-dollar" name="special-dollar"><code>$</code></a></td>
   <td>
    <p>Matched het einde van de input. Matched ook direct voor een line break karakter als de multiline vlag is ingesteld.</p>

    <p>Als voorbeeld, <code>/t$/</code> matched niet de 't' in "beter", maar matched wel in "beet".</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-asterisk" id="special-asterisk" name="special-asterisk"><code>*</code></a></td>
   <td>
    <p>Matched de voorafgaande expressie 0 of meerdere malen. Equivalent aan <code>{0,}</code>.</p>

    <p>Als voorbeeld, <code>/bo*/</code> matched 'boo' in "de grote boom" en 'b' in "bar" maar niets in "hallo".</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-plus" id="special-plus" name="special-plus"><code>+</code></a></td>
   <td>
    <p>Vind de voorafgaande expressie 1 of meerdere malen. Equivalent aan <code>{1,}</code>.</p>

    <p>Als voorbeeld, <code>/a+/</code> matched de 'a' in "pan" and alle a's in "haaaaaaatsjoe", maar niets in "zzp".</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-questionmark" id="special-questionmark" name="special-questionmark"><code>?</code></a></td>
   <td>
    <p>Matched de voorafgaande expressie 0 of 1 maal. Equivalent aan <code>{0,1}</code>.<br>
     <br>
     Als voorbeeld, <code>/e?le?/</code> matched de 'el' in "angel" en de 'le' in "angle" en ook de 'l' in "oslo".</p>

    <p>Als het direct na de quantifiers  *, +, ?, or {} wordt gebruikt maakt het deze niet-gretig (matched het minst mogelijke aantal karakters), in tegenstelling tot de standaard, die gretig is (matched zo veel mogelijk karakters als mogelijk). Bijvoorbeeld, <code>/\d+/</code> toepassen op "123abc" matched "123". Echter, <code>/\d+?/</code> toepassen op diezelfde string matched alleen de "1".</p>

    <p>Wordt ook gebruikt in lookahead stellingen, zoals beschreven in de <code>(x(?=y)</code> en  <code>(x(?!y)</code> van deze tabel.<br>
      </p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-dot" id="special-dot" name="special-dot"><code>.</code></a></td>
   <td>
    <p>(De decimale punt) matched welk individueel karakter dan ook, met uitzondering van de newline.</p>

    <p>Als voorbeeld, <code>/.n/</code> matched 'an' and 'on' in "nay, an apple is on the tree", maar niet 'nay'.</p>

    <p>Wanneer de <code>s</code> ("dotAll") vlag is ingesteld op 'true' matched het ook newline karakters.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-capturing-parentheses" id="special-capturing-parentheses" name="special-capturing-parentheses"><code>(x)</code></a></td>
   <td>
    <p>Matched 'x' en onthoudt de match, zoals het volgende voorbeeld toont. De haakjes worden <em>capturing parentheses</em> genoemd<br>
     <br>
     De '<code>(foo)</code>' en '<code>(bar)</code>' in het patroon <code>/(foo) (bar) \1 \2/</code> matchen en onthouden de eerste twee woorden in de string "foo bar foo bar". De <code>\1</code> en <code>\2</code>  geven de eerste en tweede substring matches tussen haakjes weer - <code>foo</code> and <code>bar</code>, en matchen de laatste twee woorden van de string. Let op dat <code>\1</code>, <code>\2</code>, ..., <code>\n</code> worden gebruikt in het matchende gedeelte van de regex, voor meer informatie, zie <a href="#special-backreference">\n</a> beneden. In het vervangings gedeelte van een regex moet de syntax <code>$1</code>, <code>$2</code>, ..., <code>$n</code> worden gebruikt, e.g.: <code>'bar foo'.replace(/(...) (...)/, '$2 $1')</code>.  <code>$&amp;</code> betekent de gehele gevonden string.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-non-capturing-parentheses" id="special-non-capturing-parentheses" name="special-non-capturing-parentheses"><code>(?:x)</code></a></td>
   <td>Matched 'x' maar onthoudt de match niet. De haakjes heten <em>non-capturing </em>haakjes, en maken het mogelijk om sub-expressies te definiëren voor regular expression operators om mee te werken.  Overweeg de voorbeeld expressie <code>/(?:foo){1,2}/</code>. Als de expressie <code>/foo{1,2}/</code> was, zouden de <code>{1,2}</code> karakters alleen van toepassing zijn op de laatste 'o' in 'foo'. met de non-capturing haakjes, is <code>{1,2}</code> van toepassing op het gehele woord 'foo'. Voor meer informatie, zie <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parentheses">Using parentheses</a>.</td>
  </tr>
  <tr>
   <td><a href="#special-lookahead" id="special-lookahead" name="special-lookahead"><code>x(?=y)</code></a></td>
   <td>
    <p>Matched  'x' alleen als 'x' gevolgd wordt door 'y'. Dit heet een 'lookahead'.</p>

    <p>Als voorbeeld, <code>/Jack(?=Sprat)/</code> matched alleen 'Jack' als het gevolgd wordt door 'Sprat'. <code>/Jack(?=Sprat|Frost)/</code> matched alleen 'Jack' als het gevolgd wordt door 'Sprat' of 'Frost'. Echter, noch 'Sprat' noch 'Frost' is onderdeel van de match resultaten.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-negated-look-ahead" id="special-negated-look-ahead" name="special-negated-look-ahead"><code>x(?!y)</code></a></td>
   <td>
    <p>Matched 'x' alleen als 'x' niet gevolgd wordt door 'y'. Dit heet een negated lookahead.</p>

    <p>Als voorbeeld, <code>/\d+(?!\.)/</code> matched alleen een nummer als het niet gevolgd wordt door een decimale punt. De reguliere expressie <code>/\d+(?!\.)/.exec("3.141")</code> matched '141' maar niet '3.141'.</p>
   </td>
  </tr>
  <tr>
   <td><code>(?&lt;=<em>y</em>)<em>x</em></code></td>
   <td>
    <p>Matched <code><em>x</em></code> alleen als <code><em>x</em></code> wordt voorafgegaan door <code><em>y</em></code>.Dit heet een 'lookbehind'.</p>

    <p>Als voorbeeld, /<code>(?&lt;=Jack)Sprat/</code> matched "Sprat" alleen als het wordt voorafgegaan door "Jack".<br>
     <code>/(?&lt;=Jack|Tom)Sprat/</code> matched "Sprat" alleen als het wordt voorafgegaan door "Jack" or "Tom".<br>
     Echter, noch "Jack" noch "Tom" maken deel uit van de match resultaten.</p>
   </td>
  </tr>
  <tr>
   <td><code>(?&lt;!<em>y</em>)<em>x</em></code></td>
   <td>
    <p>Matched <code><em>x</em></code> alleen als <code><em>x</em></code> niet wordt voorafgegaan door <code><em>y</em></code>. Dit heet een 'negated lookbehind'.</p>

    <p>Als voorbeeld, <code>/(?&lt;!-)\d+/</code> matched een nummer alleen als het niet wordt voorafgegaan door een min-teken.<br>
     <code>/(?&lt;!-)\d+/.exec('3')</code> matched "3".<br>
      <code>/(?&lt;!-)\d+/.exec('-3')</code>  wordt niet gevonden omdat aan het nummer een min-teken voorafgaat.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-or" id="special-or" name="special-or"><code>x|y</code></a></td>
   <td>
    <p>Matched 'x', of 'y' (indien er geen match is voor 'x').</p>

    <p>Als voorbeeld, <code>/groene|rode/</code> matched 'groene' in "groene appel" en 'rode' in "rode appel." De volgorde van 'x' en 'y' maakt uit. <code>a*|b</code> matched bijvoorbeeld de lege string in "b", maar <code>b|a*</code> matched "b" in dezelfde string.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-quantifier" id="special-quantifier" name="special-quantifier"><code>{n}</code></a></td>
   <td>Matched de voorafgaande expressie precies n maal. N moet een positief getal zijn.<br>
    <br>
    Als voorbeeld, <code>/a{2}/</code> matched de 'a' in "candy" niet, maar matched wel alle a's in "caandy," en de eerste twee a's in "caaandy."</td>
  </tr>
  <tr>
   <td><a href="#special-quantifier" id="special-quantifier" name="special-quantifier"><code>{n,}</code></a></td>
   <td>
    <p>Matched de voorafgaande expressie tenminste n maal. N moet een positief getal zijn.</p>

    <p>Als voorbeeld, /a{2,}/ matched "aa", "aaaa" en "aaaaa" maar niet "a"</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-quantifier-range" id="special-quantifier-range" name="special-quantifier-range"><code>{n,m}</code></a></td>
   <td>
    <p>Waar <code>n</code> en <code>m</code> positieve getallen zijn en <code>n &lt;= m</code>. Matched tenminste <code>n</code> en maximaal <code>m</code> keer de voorafgaande expressie. Als <code>m</code> is weggelaten, wordt het behandeld als ∞.</p>

    <p>Als voorbeeld, <code>/a{1,3}/</code> matched niets in "cndy", de 'a' in "candy," de eerste twee a's in "caandy," en de eerste drie a's in "caaaaaaandy". Let op dat als "caaaaaaandy" wordt gematched, de match "aaa" is, ook al heeft de originele string meer a's er in staan.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-character-set" id="special-character-set" name="special-character-set"><code>[xyz]</code></a></td>
   <td>Karakter set. Dit type patroon matched een van de karakters tussen de haken, inclusief <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Using_special_characters_in_strings" title="JavaScript Guide: Grammar and types § Using special characters in strings">escape sequences</a>. Speciale karakters zoals de punt(<code>.</code>) en asterisk(<code>*</code>) zijn niet speciaal binnen een karakter set, en hoeven niet geëscaped te worden. Je kan een reeks karakters specificeren door een streepje te gebruiken , zoals het volgende voorbeeld illustreert.<br>
    <br>
    Het patroon<code> [a-d]</code>, wat dezelfde match uitvoert als <code>[abcd]</code>, matched de 'b' in "brisket" en de 'c' in "city". De patronen <code>/[a-z.]+/ </code>en <code>/[\w.]+/</code> matchen de gehele string "test.i.ng".</td>
  </tr>
  <tr>
   <td><a href="#special-negated-character-set" id="special-negated-character-set" name="special-negated-character-set"><code>[^xyz]</code></a></td>
   <td>
    <p>Een genegeerde karakter set, dat wil zeggen het matched alles wat niet binnen de haakjes staat. Je kan een reeks karakters specificeren door een streepje te gebruiken. Alles wat werkt in een normale karakter set werkt ook hier.</p>

    <p>Als voorbeeld, <code>[^abc]</code> is hetzelfde als <code>[^a-c]</code>. Ze matchen als eerste  'r' in "brisket" en 'h' in "chop."</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-backspace" id="special-backspace" name="special-backspace"><code>[\b]</code></a></td>
   <td>
    <p>Matched een backspace (U+0008). Je hebt vierkante haakjes nodig om een letterlijk backspace karakter te matchen. (Niet te verwarren met <code>\b</code>.)</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-word-boundary" id="special-word-boundary" name="special-word-boundary"><code>\b</code></a></td>
   <td>
    <p>Matched een <em>woordgrens</em>. een woordgrens matched de positie tussen een woord karakter gevolgd door een niet-woord karakter, of tussen een niet-woord karakter gevolgd door een woord karakter, of thet begin van de string, of het einde van de string. Een woordgrens is geen "karakter" om te matchen; net als een anker wordt een woordgens niet toegevoegd aan de match. In andere woorden, de lengte van een gematchede woordgrens is nul. (Niet te verwarren met [\b]</p>

    <p>Voorbeelden met de input string "moon":</p>

    <p><code>/\bm/</code> matched omdat de <code>\b</code> zich aan het begin van de string bevindt; de \b in <code>/oo\b/</code> matched niet omdat de \b zowel voorafgegaan wordt als gevolgd wordt door woord karakters; de \b in <code>/oon\b/</code> matched omdat het aan het zich einde van de string bevindt; de \b in <code>/\w\b\w/</code> zal nooit iets matchen, omdat het zowel voorafgegaan en gevolgd wordt door een woordkarakter.</p>

    <div class="note">
    <p><strong>N.B.:</strong> JavaScript's reguliere expressie engine definieert een specifieke groep karakters als "woord" karakters. Enig karakter niet in groep wordt als non-woord karakter beschouwd. Deze groep karakters is redelijk beperkt: het bestaat enkel uit het Romeinse alfabet in zowel hoofd- als kleine letters, decimale getallen en het underscore karakter. Geaccentueerde karakters zoals "é" of "ü" worden helaas behandelt als non-woord karakters voor wat betreft woordgrenzen, evenals ideografische karakters (e.g. Chinees, Japans, Koreaans) in het algemeen.</p>
    </div>
   </td>
  </tr>
  <tr>
   <td><a href="#special-non-word-boundary" id="special-non-word-boundary" name="special-non-word-boundary"><code>\B</code></a></td>
   <td>
    <p>Matched een non-woordgrens. Dit matched de volgende gevallen:</p>

    <ul>
     <li>Voor het eerste karakter van de string</li>
     <li>Na het laatste karakter van de string</li>
     <li>Tussen twee woord karakters</li>
     <li>Tussen twee niet-woord karakters</li>
     <li>Een lege string</li>
    </ul>

    <p>Als voorbeeld, <code>/\B../</code> matched 'oo' in "noonday", en <code>/y\B./</code> matched 'ye' in "possibly yesterday."</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-control" id="special-control" name="special-control"><code>\c<em>X</em></code></a></td>
   <td>
    <p>Waar X een karakter is in de reeks van A tot Z. Matched een control karakter in een string.</p>

    <p>Als voorbeeld, <code>/\cM/</code> matched control-M (U+000D) in een string.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-digit" id="special-digit" name="special-digit"><code>\d</code></a></td>
   <td>
    <p>Matched een numeriek (digit) karakter. Equivalent aan <code>[0-9]</code>.</p>

    <p>Als voorbeeld, <code>/\d/</code> of <code>/[0-9]/</code> matched '2' in "B2 is het kamernummer"</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-non-digit" id="special-non-digit" name="special-non-digit"><code>\D</code></a></td>
   <td>
    <p>Matched een niet-numeriek karacter. Equivalent aan <code>[^0-9]</code>.</p>

    <p>Als voorbeeld, <code>/\D/</code> or <code>/[^0-9]/</code> matched 'B' in "B2 is het kamernummer"</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-form-feed" id="special-form-feed" name="special-form-feed"><code>\f</code></a></td>
   <td>Matched een form feed (U+000C).</td>
  </tr>
  <tr>
   <td><a href="#special-line-feed" id="special-line-feed" name="special-line-feed"><code>\n</code></a></td>
   <td>Matched een line feed (U+000A).</td>
  </tr>
  <tr>
   <td><a href="#special-carriage-return" id="special-carriage-return" name="special-carriage-return"><code>\r</code></a></td>
   <td>Matched een carriage return (U+000D).</td>
  </tr>
  <tr>
   <td><a href="#special-white-space" id="special-white-space" name="special-white-space"><code>\s</code></a></td>
   <td>
    <p>Matched een witruimte karacter, inclusief spatie, tab, form feed, line feed. Equivalent aan <code>[ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code>.</p>

    <p>Als voorbeeld, <code>/\s\w*/</code> matches ' bar' in "foo bar."</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-non-white-space" id="special-non-white-space" name="special-non-white-space"><code>\S</code></a></td>
   <td>
    <p>Matched een karakter anders dan witruimte. Equivalent aan <code>[^ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code>.</p>

    <p>Als voorbeeld, <code>/\S*/</code> matched 'foo' in "foo bar."</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-tab" id="special-tab" name="special-tab"><code>\t</code></a></td>
   <td>Matched een tab (U+0009).</td>
  </tr>
  <tr>
   <td><a href="#special-vertical-tab" id="special-vertical-tab" name="special-vertical-tab"><code>\v</code></a></td>
   <td>Matched een verticale tab (U+000B).</td>
  </tr>
  <tr>
   <td><a href="#special-word" id="special-word" name="special-word"><code>\w</code></a></td>
   <td>
    <p>Matched elk alfanumeriek karakters met inbegrip van de underscore. Equivalent aan <code>[A-Za-z0-9_]</code>.</p>

    <p>Als voorbeeld, <code>/\w/</code> matched 'a' in "apple," '5' in "$5.28," en '3' in "3D."</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-non-word" id="special-non-word" name="special-non-word"><code>\W</code></a></td>
   <td>
    <p>Matched een niet-woord karakter. Equivalent aan <code>[^A-Za-z0-9_]</code>.</p>

    <p>Als voorbeeld, <code>/\W/</code> of <code>/[^A-Za-z0-9_]/</code> matched '%' in "50%."</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-backreference" id="special-backreference" name="special-backreference"><code>\<em>n</em></code></a></td>
   <td>
    <p>Waarbij n een positief getal is, een terugreferentie naar de laatste substring die de <em>n</em>de groep tussen ronde haakjes in de reguliere expressie matchde (linker haakjes tellend).</p>

    <p>Als voorbeeld, <code>/apple(,)\sorange\1/</code> matched 'apple, orange,' in "apple, orange, cherry, peach."</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-null" id="special-null" name="special-null"><code>\0</code></a></td>
   <td>
    <p>Matched een NULL (U+0000) karakter. Volg dit niet met nog een getal, want <code>\0&lt;digits&gt;</code> is een octale <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Using_special_characters_in_strings" title="JavaScript Guide: Grammar and types § Using special characters in strings">escape sequence</a>. Gebruik in plaats daarvan <code>\x00</code>.</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-hex-escape" id="special-hex-escape" name="special-hex-escape"><code>\xhh</code></a></td>
   <td>
    <p>Matched het karakter met de code hh (twee hexadecimale getallen)</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-unicode-escape" id="special-unicode-escape" name="special-unicode-escape"><code>\uhhhh</code></a></td>
   <td>
    <p>Matched het karakter met de code hhhh (vier hexadecimale getallen).</p>
   </td>
  </tr>
  <tr>
   <td><a href="#special-unicode-escape-es6" id="special-unicode-escape-es6" name="special-unicode-escape-es6"><code>\u{hhhh}</code></a></td>
   <td>
    <p>(enkel als de u vlag is ingesteld) Matched het karakter met de Unicode-waarde hhhh (hexadecimale getallen).</p>
   </td>
  </tr>
 </tbody>
</table>

<p>Invoer van gebruikers escapen die als letterlijke string binnen een reguliere expressie behandeld moet worden—die anders als een speciaal karakter gezien zou worden—kan bereikt worden met eenvoudige vervanging:</p>

<pre>function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&amp;'); // $&amp; means the whole matched string
}
</pre>

<p>De g na de reguliere expressie is een optie of vlaggetje wat globaal zoekt, dus in de hele string kijkt en alle vondsten teruggeeft. Dit wordt in detail beneden uitgelegd in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Advanced_searching_with_flags">Advanced Searching With Flags</a></p>

<h3 id="Ronde_haakjes_gebruiken">Ronde haakjes gebruiken</h3>

<p>Ronde haakjes om een deel van het reguliere expressie patroon zorgen ervoor dat een deel van de gevonden substring wordt onthouden. Eenmaal onthouden kan de substring opgehaald worden voor ander gebruik, zoals beschreven in <a href="#Using_parenthesized_substring_matches">Using Parenthesized Substring Matches.</a></p>

<p>Als voorbeeld, het patroon <code>/Chapter (\d+)\.\d*/</code> illustreert additionele ontsnapte en bijzondere karakters en geeft aan dat een deel van het patroon moet worden onthouden. Het vind precies de karakters 'Chapter' gevolgd door een of meer numerieke karakters (<code>\d</code> betekent ieder numeriek karakter en <code>+</code> betekent 1 of meer keer), gevolgd door een decimale punt (wat een bijzonder karakter is uit zichzelf; \ voorafgaand aan de punt betekend dat het patroon moet zoeken naar het letterlijke karakter '.'), gevolgd door enig numeriek karakter 0 of meer keer. (<code>\d</code> betekent ieder numeriek karakter, <code>*</code> betekent 0 of meer keer). Daarnaast worden de ronde haakjes gebruikt om het eerste gevonden numerieke karakters te onthouden.</p>

<p>Dit patroon wordt gevonden in "Open Chapter 4.3, paragraph 6" en "4' wordt onthouden. Het patroon wordt niet gevonden in "Chapter 3 en 4" omdat de string geen punt bevat na de '3'.</p>

<p>Om een substring te vinden zonder het gevonden deel te onthouden kan binnen de ronde haakjes <code>?:</code> voor het patroon geplaatst worden. Als voorbeeld, <code>(?:\d+)</code> vind een of meer numerieke karakters maar onthoudt de gevonden karakters niet.</p>

<h2 id="Werken_met_reguliere_expressies">Werken met reguliere expressies</h2>

<p>Reguliere expressies worden gebruikt met de <code>RegExp</code> methoden <code>test</code> en <code>exec</code> en met de <code>String</code> methoden <code>match</code>, <code>replace</code>, <code>search</code>, and <code>split</code>. Deze methoden zijn in detail uitgelegd in de <a href="/en-US/docs/Web/JavaScript/Reference" title="en-US/docs/JavaScript/Reference">JavaScript referentie</a></p>

<table class="standard-table">
 <caption>Methoden die reguliere expressies gebruiken</caption>
 <thead>
  <tr>
   <th scope="col">Methode</th>
   <th scope="col">Beschrijving</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{jsxref("RegExp.exec", "exec")}}</td>
   <td>
    <p>Een <code>RegExp</code> methode die zoekt naar een vondst in een string. Het geeft een lijst (array) met informatie terug of null bij geen vondst.</p>
   </td>
  </tr>
  <tr>
   <td>{{jsxref("RegExp.test", "test")}}</td>
   <td>
    <p>Een <code>RegExp</code> methode die op een vondst test in een string. geeft true of false terug.</p>
   </td>
  </tr>
  <tr>
   <td>{{jsxref("String.match", "match")}}</td>
   <td>
    <p>Een <code>String</code> methode die zoekt naar een vondst in een string. Het geeft een array met informatie terug of null bij geen vondst.</p>
   </td>
  </tr>
  <tr>
   <td>{{jsxref("String.matchAll", "matchAll")}}</td>
   <td>
    <p>Een <code>String</code> methode die een iterator teruggeeft met alle vondsten, inclusief opgeslagen (capturing) groepen</p>
   </td>
  </tr>
  <tr>
   <td>{{jsxref("String.search", "search")}}</td>
   <td>
    <p>Een <code>String</code> methode die op een vondst in een string test. Het geeft de index van de vonst terug of -1 indien niets gevonden is.</p>
   </td>
  </tr>
  <tr>
   <td>{{jsxref("String.replace", "replace")}}</td>
   <td>
    <p>Een <code>String</code> methode die zoekt naar en vondst in een string en de gevonden substring vervangt met een andere substring.</p>
   </td>
  </tr>
  <tr>
   <td>{{jsxref("String.split", "split")}}</td>
   <td>
    <p>Een <code>String</code> methode die een reguliere expressie of een vaste string gebruikt om een string op te delen in een lijst (array) van substrings.</p>
   </td>
  </tr>
 </tbody>
</table>

<p>Gebruik de <code>test</code> of <code>search</code> methode wanneer je wilt weten of een string een patroon bevat; gebruik voor meer informatie (maar langzamere executie) de <code>exec</code> of <code>match</code> methode. Als je <code>exec</code> of <code>match</code> gebruikt en als er vondsten zijn, dan geven deze methoden een lijst (array) terug en updaten de eigenschappen van het betreffende reguliere expressie object en ook van het voorgedefinieerde reguliere expressie object, <code>RegExp</code>. Als niets wordt gevonden geeft de <code>exec</code> methode null terug, wat teruggeleid wordt naar <code>false</code>.</p>

<p>In het volgende voorbeeld gebruikt het script de <code>exec</code> methode om een vondst te doen in een string.</p>

<pre class="brush: js">var myRe = /d(b+)d/g;
var myArray = myRe.exec('cdbbdbsbz');
</pre>

<p>Als je geen toegang nodig hebt tot de eigenschappen van de reguliere expressie is dit script een alternatieve manier om <code>myArray</code> te creëren:</p>

<pre class="brush: js">var myArray = /d(b+)d/g.exec('cdbbdbsbz');
    // gelijk aan "cdbbdbsbz".match(/d(b+)d/g); echter,
    // "cdbbdbsbz".match(/d(b+)d/g) heeft als resultaat Array [ "dbbd" ], terwijl
    // /d(b+)d/g.exec('cdbbdbsbz') als resultaat heeft Array [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ].
</pre>

<p>(Zie <a href="#g-different-behaviors">g different behaviors</a> voor verdere info over de verschillende werkingen.)</p>

<p>Als je een reguliere expressie wil opbouwen uit een string, is dit script nog een alternatief:</p>

<pre class="brush: js">var myRe = new RegExp('d(b+)d', 'g');
var myArray = myRe.exec('cdbbdbsbz');
</pre>

<p>Met dit script is de vondst een success en geeft het een lijst (array) terug en update de eigenschappen die in de volgende tabel worden getoond:</p>

<table class="standard-table">
 <caption>Resultaten van reguliere expressie executie.</caption>
 <thead>
  <tr>
   <th scope="col">Object</th>
   <th scope="col">Eigenschap of index</th>
   <th scope="col">Beschrijving</th>
   <th scope="col">In dit voorbeeld</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td rowspan="4"><code>myArray</code></td>
   <td></td>
   <td>
    <p>De gevonden string en alle onthouden substrings.</p>
   </td>
   <td><code>['dbbd', 'bb', index: 1, input: 'cdbbdbsbz']</code></td>
  </tr>
  <tr>
   <td><code>index</code></td>
   <td>
    <p>De 0-gebaseerde index van de vondst in de invoer string.</p>
   </td>
   <td><code>1</code></td>
  </tr>
  <tr>
   <td><code>input</code></td>
   <td>De originele string</td>
   <td><code>"cdbbdbsbz"</code></td>
  </tr>
  <tr>
   <td><code>[0]</code></td>
   <td>De laatste gevonden karakters.</td>
   <td><code>"dbbd"</code></td>
  </tr>
  <tr>
   <td rowspan="2"><code>myRe</code></td>
   <td><code>lastIndex</code></td>
   <td>
    <p>De index vanaf waar de volgende match gestart moet worden. (deze eigenschap is alleen ingesteld als de reguliere expressie de g optie gebruikt, beschreven in <a href="#Advanced_searching_with_flags">Advanced Searching With Flags</a>.)</p>
   </td>
   <td><code>5</code></td>
  </tr>
  <tr>
   <td><code>source</code></td>
   <td>
    <p>De tekst van het patroon. Geüpdate op het moment dat de reguliere expressie wordt gecreërd, niet geëxecuteerd.</p>
   </td>
   <td><code>"d(b+)d"</code></td>
  </tr>
 </tbody>
</table>

<p>Zoals getoond in het tweede formulier van dit voorbeeld kan je een reguliere expressie gebruiken die gemaakt is met een object initializer zonder het aan een variabele toe te kennen. Echter, als je dit doet is ieder voorval een nieuwe reguliere expressie. Om deze reden, als je deze vorm gebruikt zonder het aan een variabele toe te kennen, kan je vervolgens niet de eigenschappen van de reguliere expressie verkrijgen. Stel dat je bijvoorbeeld dit script hebt:</p>

<pre class="brush: js">var myRe = /d(b+)d/g;
var myArray = myRe.exec('cdbbdbsbz');
console.log('The value of lastIndex is ' + myRe.lastIndex);

// "The value of lastIndex is 5"
</pre>

<p>Echter, als je dit script hebt:</p>

<pre class="brush: js">var myArray = /d(b+)d/g.exec('cdbbdbsbz');
console.log('The value of lastIndex is ' + /d(b+)d/g.lastIndex);

// "The value of lastIndex is 0"
</pre>

<p>De voorvallen van <code>/d(b+)d/g</code> in de twee statements zijn verschillende reguliere expressie objecten en hebben daarom verschillende waarden voor hun <code>lastIndex</code> eigenschap. Als je toegang nodig hebt tot de eigenschappen van een reguliere expressie die gecreërd is met een object initializer, moet je het eerst toekennen aan een variabele.</p>

<h3 id="Using_parenthesized_substring_matches_2"><a id="Using_parenthesized_substring_matches" name="Using_parenthesized_substring_matches">Using parenthesized substring matches</a></h3>

<p>Including parentheses in a regular expression pattern causes the corresponding submatch to be remembered. For example, <code>/a(b)c/</code> matches the characters 'abc' and remembers 'b'. To recall these parenthesized substring matches, use the <code>Array</code> elements <code>[1]</code>, ..., <code>[n]</code>.</p>

<p>The number of possible parenthesized substrings is unlimited. The returned array holds all that were found. The following examples illustrate how to use parenthesized substring matches.</p>

<p>The following script uses the {{jsxref("String.replace", "replace()")}} method to switch the words in the string. For the replacement text, the script uses the <code>$1</code> and <code>$2</code> in the replacement to denote the first and second parenthesized substring matches.</p>

<pre class="brush: js">var re = /(\w+)\s(\w+)/;
var str = 'John Smith';
var newstr = str.replace(re, '$2, $1');
console.log(newstr);

// "Smith, John"
</pre>

<h3 id="Advanced_searching_with_flags_2"><a name="Advanced_searching_with_flags">Advanced searching with flags</a></h3>

<p>Regular expressions have six optional flags that allow for functionality like global and case insensitive searching. These flags can be used separately or together in any order, and are included as part of the regular expression.</p>

<table class="standard-table">
 <caption>Regular expression flags</caption>
 <thead>
  <tr>
   <th scope="col">Flag</th>
   <th scope="col">Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>g</code></td>
   <td>Global search.</td>
  </tr>
  <tr>
   <td><code>i</code></td>
   <td>Case-insensitive search.</td>
  </tr>
  <tr>
   <td><code>m</code></td>
   <td>Multi-line search.</td>
  </tr>
  <tr>
   <td><code>s</code></td>
   <td>Allows <code>.</code> to match newline characters.</td>
  </tr>
  <tr>
   <td><code>u</code></td>
   <td>"unicode"; treat a pattern as a sequence of unicode code points</td>
  </tr>
  <tr>
   <td><code>y</code></td>
   <td>Perform a "sticky" search that matches starting at the current position in the target string. See {{jsxref("RegExp.sticky", "sticky")}}</td>
  </tr>
 </tbody>
</table>

<p>To include a flag with the regular expression, use this syntax:</p>

<pre class="brush: js">var re = /pattern/flags;
</pre>

<p>or</p>

<pre class="brush: js">var re = new RegExp('pattern', 'flags');
</pre>

<p>Note that the flags are an integral part of a regular expression. They cannot be added or removed later.</p>

<p>For example, <code>re = /\w+\s/g</code> creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string.</p>

<pre class="brush: js">var re = /\w+\s/g;
var str = 'fee fi fo fum';
var myArray = str.match(re);
console.log(myArray);

// ["fee ", "fi ", "fo "]
</pre>

<p>You could replace the line:</p>

<pre class="brush: js">var re = /\w+\s/g;
</pre>

<p>with:</p>

<pre class="brush: js">var re = new RegExp('\\w+\\s', 'g');
</pre>

<p>and get the same result.</p>

<p id="g-different-behaviors">The behavior associated with the '<strong><code>g</code></strong>' flag is different when the <code>.exec()</code> method is used.  (The roles of "class" and "argument" get reversed: In the case of <code>.match()</code>, the string class (or data type) owns the method and the regular expression is just an argument, while in the case of <code>.exec()</code>, it is the regular expression that owns the method, with the string being the argument.  Contrast <em><code>str.match(re)</code></em> versus <em><code>re.exec(str)</code></em>.)  The '<code><strong>g</strong></code>' flag is used with the <strong><code>.exec()</code></strong> method to get iterative progression.</p>

<pre class="brush: js">var xArray; while(xArray = re.exec(str)) console.log(xArray);
// produces:
// ["fee ", index: 0, input: "fee fi fo fum"]
// ["fi ", index: 4, input: "fee fi fo fum"]
// ["fo ", index: 7, input: "fee fi fo fum"]</pre>

<p>The <code>m</code> flag is used to specify that a multiline input string should be treated as multiple lines. If the <code>m</code> flag is used, <code>^</code> and <code>$</code> match at the start or end of any line within the input string instead of the start or end of the entire string.</p>

<h2 id="Examples">Examples</h2>

<p>The following examples show some uses of regular expressions.</p>

<h3 id="Changing_the_order_in_an_input_string">Changing the order in an input string</h3>

<p>The following example illustrates the formation of regular expressions and the use of <code>string.split()</code> and <code>string.replace()</code>. It cleans a roughly formatted input string containing names (first name last) separated by blanks, tabs and exactly one semicolon. Finally, it reverses the name order (last name first) and sorts the list.</p>

<pre class="brush: js">// The name string contains multiple spaces and tabs,
// and may have multiple spaces between first and last names.
var names = 'Orange Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand ';

var output = ['---------- Original String\n', names + '\n'];

// Prepare two regular expression patterns and array storage.
// Split the string into array elements.

// pattern: possible white space then semicolon then possible white space
var pattern = /\s*;\s*/;

// Break the string into pieces separated by the pattern above and
// store the pieces in an array called nameList
var nameList = names.split(pattern);

// new pattern: one or more characters then spaces then characters.
// Use parentheses to "memorize" portions of the pattern.
// The memorized portions are referred to later.
pattern = /(\w+)\s+(\w+)/;

// Below is the new array for holding names being processed.
var bySurnameList = [];

// Display the name array and populate the new array
// with comma-separated names, last first.
//
// The replace method removes anything matching the pattern
// and replaces it with the memorized string—the second memorized portion
// followed by a comma, a space and the first memorized portion.
//
// The variables $1 and $2 refer to the portions
// memorized while matching the pattern.

output.push('---------- After Split by Regular Expression');

var i, len;
for (i = 0, len = nameList.length; i &lt; len; i++) {
  output.push(nameList[i]);
  bySurnameList[i] = nameList[i].replace(pattern, '$2, $1');
}

// Display the new array.
output.push('---------- Names Reversed');
for (i = 0, len = bySurnameList.length; i &lt; len; i++) {
  output.push(bySurnameList[i]);
}

// Sort by last name, then display the sorted array.
bySurnameList.sort();
output.push('---------- Sorted');
for (i = 0, len = bySurnameList.length; i &lt; len; i++) {
  output.push(bySurnameList[i]);
}

output.push('---------- End');

console.log(output.join('\n'));
</pre>

<h3 id="Using_special_characters_to_verify_input">Using special characters to verify input</h3>

<p>In the following example, the user is expected to enter a phone number. When the user presses the "Check" button, the script checks the validity of the number. If the number is valid (matches the character sequence specified by the regular expression), the script shows a message thanking the user and confirming the number. If the number is invalid, the script informs the user that the phone number is not valid.</p>

<p>Within non-capturing parentheses <code>(?:</code> , the regular expression looks for three numeric characters <code>\d{3}</code> OR <code>|</code> a left parenthesis <code>\(</code> followed by three digits<code> \d{3}</code>, followed by a close parenthesis <code>\)</code>, (end non-capturing parenthesis <code>)</code>), followed by one dash, forward slash, or decimal point and when found, remember the character <code>([-\/\.])</code>, followed by three digits <code>\d{3}</code>, followed by the remembered match of a dash, forward slash, or decimal point <code>\1</code>, followed by four digits <code>\d{4}</code>.</p>

<p>The <code>Change</code> event activated when the user presses Enter sets the value of <code>RegExp.input</code>.</p>

<pre class="brush: html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;
    &lt;meta http-equiv="Content-Script-Type" content="text/javascript"&gt;
    &lt;script type="text/javascript"&gt;
      var re = /(?:\d{3}|\(\d{3}\))([-\/\.])\d{3}\1\d{4}/;
      function testInfo(phoneInput) {
        var OK = re.exec(phoneInput.value);
        if (!OK)
          window.alert(phoneInput.value + ' isn\'t a phone number with area code!');
        else
          window.alert('Thanks, your phone number is ' + OK[0]);
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Enter your phone number (with area code) and then click "Check".
        &lt;br&gt;The expected format is like ###-###-####.&lt;/p&gt;
    &lt;form action="#"&gt;
      &lt;input id="phone"&gt;&lt;button onclick="testInfo(document.getElementById('phone'));"&gt;Check&lt;/button&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<div>{{PreviousNext("Web/JavaScript/Guide/Text_formatting", "Web/JavaScript/Guide/Indexed_collections")}}</div>
