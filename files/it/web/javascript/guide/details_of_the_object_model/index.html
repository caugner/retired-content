---
title: Dettagli del modello a oggetti
slug: Web/JavaScript/Guide/Details_of_the_Object_Model
tags:
  - Guide
  - Intermediate
  - JavaScript
translation_of: Web/JavaScript/Guide/Details_of_the_Object_Model
original_slug: Web/JavaScript/Guida/Dettagli_Object_Model
---
<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Working_with_Objects", "Web/JavaScript/Guide/Iterators_and_Generators")}}</div>

<div class="note">
<p>Il contenuto di questo articolo è in discussione. Lascia un feedback e aiutaci a rendere migliore questa pagina: {{bug(1201380)}}.</p>
</div>

<p class="summary">JavaScript è un linguaggio ad oggetti basato su prototipi, piuttosto che sulle classi. A causa di questa diversa base, può essere meno evidente come JavaScript permette di creare gerarchie di oggetti e di avere l'ereditarietà delle proprietà e dei loro valori. Questo articolo cerca di chiarire questo aspetto.</p>

<p>Questo capitolo presuppone una certa familiarità con JavaScript e con l'uso delle funzioni per la creazione di semplici oggetti.</p>

<h2 id="Linguaggi_class-based_vs._linguaggi_prototype-based">Linguaggi class-based vs. linguaggi prototype-based</h2>

<p>I linguaggi ad oggetti basati su classi, come Java e C++, si basano su due entità distinte: le classi (<em>classes</em>) e le istanze (<em>instances</em>).</p>

<ul>
 <li>Una <em>class</em>e definisce tutte le proprietà (considering methods and fields in Java, or members in C++, to be properties) che caratterizzano una determinata collezione di oggetti. Una classe è un'entità astratta, più che un membro del gruppo di oggetti che descrive. Per esempio, la classe <code>Employee</code> può rappresentare il gruppo di tutti i dipendenti.</li>
 <li>Un'<em>istanza</em>, d'altra parte, è l'istanziazione di una classe; cioè uno dei suoi membri. Per esempio <code>Victoria</code> può essere un'istanza della classe <code>Employee</code>, che rappresenta un particolare individuo come un dipendente. Un'istanza ha esattamente le stesse proprietà della classe a cui appartiene (né più, né meno).</li>
</ul>

<p>Un linguaggio basato su prototipi, come JavaScript, non fa questa distinzione: ha solo oggetti. Introduce la nozione di <em>oggetto prototipo</em> (<em>prototypical object</em>), un oggetto usato come modello da cui prendere le proprietà iniziali per un nuovo oggetto. Ogni oggetto può specificare le sue proprietà, anche quando viene creato o in fase di esecuzione.Inoltre, ogni oggetto può essere associato ad un altro oggetto come <em>prototipo</em>, consentendo al secondo oggetto di condividere le proprietà del primo.</p>

<h3 id="Definizione_di_una_classe">Definizione di una classe</h3>

<p>Nei linguaggi basati su classi, le classi vengono definite in <em>class definition</em> separate. In queste definizioni è possibile specificare metodi speciali, chiamari <em>costruttori</em> (<em>constructors</em>), per creare istanze della classe. Un costruttore può specificare i valori iniziali per le proprietà dell'istanza ed eseguire altre elaborazioni adatte al momento della creazione. Per creare le istanze di una classe si utilizza l'operatore <em>new</em> associato al metodo costruttore.</p>

<p>JavaScript segue un modello simile, ma non prevede la definizione della classe separata dal costruttore. Invece, per creare oggetti con un particolare set di proprietà e valori si definisce una funzione costruttore. Ogni funzione JavaScript può essere usata come costruttore. Per creare un nuovo oggetto si utilizza l'operatore <em>new</em> associato a una funzione costruttore.</p>

<h3 id="Sottoclassi_e_ereditarietà">Sottoclassi e ereditarietà</h3>

<p>In un linguaggio basato su classi, si crea una gerarchia tra le classi attraverso le definizioni delle classi stesse. All'interno della definizione di una classe è possibile specificare che la nuova classe è una <em>sottoclasse</em> (<em>subclass</em>) di una classe esistente. La sottoclasse eredita tutte le proprietà della superclasse e può inoltre aggiungere nuove proprietà o modificare quelle ereditate. Per esempio, assumiamo che la classe <code>Employee</code> include solo le proprietà <code>name</code> <code>e dept</code>, <code>e Manager</code> è una sottoclasse di <code>Employee</code> che aggiunge la proprietà <code>reports</code>. In questo caso, un'istanza della classe <code>Manager</code> avrà tutte e tre le proprietà: <code>name</code>, <code>dept</code>, <code>e reports</code>.</p>

<p>JavaScript implementa l'ereditarietà permettendo di associare un oggetto prototipo ad ogni funzione costruttore. Quindi, è possibile ricreare esattamente l'esempio visto in precedenza, ma usando una terminologia leggermente diversa. Innanzitutto  si definisce la funzione costruttore <code>Employee</code>, specificando le proprietà <code>name</code> <code>e dept</code>. In seguito, si definisce la funzione costruttore <code>Manager</code>, chiamando il costruttore <code>Empl</code><code>oyee</code> e specificando la proprietà <code>reports</code>. Infine, si assegna a un nuovo oggetto derivato da <code>Employee.prototype</code> come il prototipo per la funzione costruttore <code>Manager</code>. Quando si crea un nuovo <code>Manager</code>, questo eredita le proprietà <code>name</code> e <code>dept</code> dall'oggetto <code>Employee</code>.</p>

<h3 id="Aggiungere_e_rimuovere_proprietà">Aggiungere e rimuovere proprietà</h3>

<p>Nei linguaggi basati su classi, una classe viene solitamente creata in fase di compilazione mentre le istanze possono essere create in fase di compilazione o in fase di esecuzione. Non è possibile cambiare il numero o il tipo di proprietà di una classe dopo che questa è stata definita. In JavaScript in fase di esecuzione si possono aggiungere o rimuovere proprietà a qualunque oggetto. Se si aggiunge una proprietà a un oggetto che è usato come prototipo per un gruppo di oggetti, anche gli oggetti del gruppo ereditano la nuova proprietà.</p>

<h3 id="Riepilogo_delle_differenze">Riepilogo delle differenze</h3>

<p>La tabella seguente fornisce un breve riepilogo di alcune di queste differenze. Il resto di questo capitolo descrive nel detteglio l'uso in JavaScript di costruttori e prototipi per creare una gerarchia di oggetti e lo confronta con la procedura che si userebbe in Java.</p>

<table class="standard-table">
 <caption>Confronto tra il sistema di oggetti basato su classi (Java) e il sistema di oggetti basato su prototipi (JavaScript)</caption>
 <thead>
  <tr>
   <th scope="col">Class-based (Java)</th>
   <th scope="col">Prototype-based (JavaScript)</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Classi e istanze sono entità separate.</td>
   <td>Tutti gli oggetti possono ereditare da un altro oggetto.</td>
  </tr>
  <tr>
   <td>Definire una classe con una definizione; istanziare una classe con un metodo costruttore</td>
   <td>Definire e creare una collezione di oggetti con una funzione costruttore.</td>
  </tr>
  <tr>
   <td>Creare un singolo oggetto con l'operatore <code>new</code>.</td>
   <td>Uguale.</td>
  </tr>
  <tr>
   <td>Costruire una gerarchia di oggetti usando la definizione di classe per definire le sottoclassi di classi esistenti.</td>
   <td>Costruire una gerarchia di oggetti assegnando un oggetto come prototipo associato a una funzione costruttore.</td>
  </tr>
  <tr>
   <td>Ereditare le proprietà seguendo la catena delle classi.</td>
   <td>Ereditare le proprietà seguendo la catena dei prototipi.</td>
  </tr>
  <tr>
   <td>La definizione di classe specifica <em>tutte</em> le proprietà di tutte le istanze della classe. Non è possibile aggiungere proprietà dinamicamente durante l'esecuzione.</td>
   <td>La funzione costruttore o il prototipo specificano un set <em>iniziale</em> di proprietà. <span class="st">È possibile aggiungere o rimuovere dinamicamente proprietà ai singoli oggetti o all'intero gruppo di oggetti.</span></td>
  </tr>
 </tbody>
</table>

<h2 id="L'esempio_'dipendente'">L'esempio 'dipendente'</h2>

<p>Il resto di questo capitolo usa la gerarchia dei dipendenti mostrata nella figura seguente.</p>

<div style="display: table-row;">
<div style="display: table-cell; width: 350px; text-align: center; vertical-align: middle; padding: 10px;">
<p>Una semplice gerarchia con gli oggetti seguenti:</p>

<p><img alt="" src="https://mdn.mozillademos.org/files/3060/figure8.1.png"></p>
</div>

<div style="display: table-cell; vertical-align: middle; padding: 10px;">
<ul>
 <li><code>Employee</code> ha le proprietà <code>name</code> (il cui valore di default è una stringa vuota) e <code>dept</code> (il cui valore di default è "general").</li>
 <li><code>Manager</code> è basato su <code>Employee</code>. Aggiunge la proprietà <code>reports</code>  (il cui valore di default è un array vuoto, destinato a contenere una serie di oggetti <code>Employee</code>).</li>
 <li><code>WorkerBee</code> è anch'esso basato su <code>Employee</code>. Aggiunge la proprietà <code>projects</code> (il cui valore di default è un array vuoto, destinato a contenere una serie di stringhe).</li>
 <li><code>SalesPerson</code> è basato su <code>WorkerBee</code>. Aggiunge la proprietà <code>quota</code> (il cui valore di default è 100). Sovrascrive inoltre la proprietà <code>dept</code> con il valore "sales", che indica che tutti i venditori si trovano nello stesso dipartimento.</li>
 <li><code>Engineer</code> è basato su <code>WorkerBee</code>. Aggiunge la proprietà <code>machine</code> (il cui valore di default è una stringa vuota) e sovrascrive la proprietà <code>dept</code> con il valore "engineering".</li>
</ul>
</div>
</div>

<h2 id="Creazione_della_gerarchia">Creazione della gerarchia</h2>

<p>Ci sono diversi modi per definire una funzione costruttore appropriata per implementare la gerarchia dei dipendenti. Il modo scelto per definirli dipende molto da cosa si vuole riuscire a fare nella propria applicazione.</p>

<p>Questa sezione mostra come usare definizioni molto semplici (e relativamente rigide) per dimostrare come far funzionare l'ereditarietà. In queste definizioni, quando si crea un oggetto non è possibile specificare il valore di nessuna proprietà. L'oggetto creato avrà semplicemente i valori di default, che potranno essere cambiati in un secondo momento.</p>

<p>In una applicazione reale, probabilmente si vorranno definire dei costruttori che permettono di impostare i valori delle proprietà mentre si crea un oggetto (per maggiori informazioni si veda la sezione <a href="#Costruttori_più_flessibili" rel="internal">Costruttori più flessibili</a>). Per adesso, queste semplici definizioni dimostrano come le proprietà vengono ereditate.</p>

<p>Le seguenti definizioni Java e JavaScript di <code>Employee</code> sono simili. L'unica differenza è che in Java si ha la necessità di specificare il tipo di ogni proprietà (questo è dovuto al fatto che Java è un<a href="https://it.wikipedia.org/wiki/Tipizzazione_forte"> linguaggio fortemente tipizzato</a> mentre JavaScript è un <a href="https://it.wikipedia.org/wiki/Tipizzazione_dinamica">linguaggio a tipizzazione dinamica</a>.</p>

<div class="twocolumns">
<h4 id="JavaScript">JavaScript</h4>

<pre class="brush: js">function Employee() {
  this.name = "";
  this.dept = "general";
}
</pre>

<h4 id="Java">Java</h4>

<pre class="brush: java">public class Employee {
   public String name = "";
   public String dept = "general";
}
</pre>
</div>

<p>Le definizioni di <code>Manager</code> e <code>WorkerBee</code> mostrano la differenza nel modo di specificare l'oggetto seguente che si trova più in alto nella catena di ereditarietà. In JavaScript si aggiunge un'istanza prototipo come valore della proprietà <code>prototype</code> della funzione costrutore. È possibile farlo in qualsiasi momento dopo aver definito il costruttore. In Java, si specifica la superclasse all'interno della definizione della classe. Non è possibile cambiare la superclasse all'esterno della definizione.</p>

<div class="twocolumns">
<h4 id="JavaScript_2">JavaScript</h4>

<pre class="brush: js">function Manager() {
  Employee.call(this);
  this.reports = [];
}
Manager.prototype = Object.create(Employee.prototype);

function WorkerBee() {
  Employee.call(this);
  this.projects = [];
}
WorkerBee.prototype = Object.create(Employee.prototype);
</pre>

<h4 id="Java_2">Java</h4>

<pre class="brush: java">public class Manager extends Employee {
   public Employee[] reports = new Employee[0];
}



public class WorkerBee extends Employee {
   public String[] projects = new String[0];
}


</pre>
</div>

<p>Le definizioni di <code>Engineer</code> e <code>SalesPerson</code> creano oggetti che discendono da  <code>WorkerBee</code>, e quindi da <code>Employee</code>. Un oggetto di questo tipo ha le proprietà di tutti gli oggetti che si trovano sopra di esso nella catena. Inoltre, queste definizioni sovrascrivono il valore ereditato delle proprietà  <code>dept</code> con nuovi valori specifici per questi oggetti.</p>

<div class="twocolumns">
<h4 id="JavaScript_3">JavaScript</h4>

<pre class="brush: js">function SalesPerson() {
   WorkerBee.call(this);
   this.dept = "sales";
   this.quota = 100;
}
SalesPerson.prototype = Object.create(WorkerBee.prototype);

function Engineer() {
   WorkerBee.call(this);
   this.dept = "engineering";
   this.machine = "";
}
Engineer.prototype = Object.create(WorkerBee.prototype);
</pre>

<h4 id="Java_3">Java</h4>

<pre class="brush: java">public class SalesPerson extends WorkerBee {
   public String dept = "sales";
   public double quota = 100.0;
}


public class Engineer extends WorkerBee {
   public String machine;
   public String dept = "engineering";
   public String machine = "";
}

</pre>
</div>

<p>Usando queste definizioni è possibile creare istanze di questi oggetti che ricevono i valori di default delle loro proprietà. La figura seguente illustra l'utilizzo di queste definizioni JavaScript per creare nuovi oggetti e mostra i valori delle diverse proprietà per questi nuovi oggetti.</p>

<div class="note">
<p><strong>Nota:</strong> Il termine <em>istanza</em> ha uno specifico significato tecnico nei linguaggi basati su classi. In questi linguaggi, un'istanza è una singola istanziazione di una classe ed è fondamentalmente differente dala classe. In JavaScript, "istanza" non ha questo significato tecnico perché JavaScript non ha questa differenza tra classi e istanze. Tuttavia, parlando di JavaScript, "istanza" può essere usato in modo informale per riferirsi a un oggetto creato usando una particolare funzione costruttore. Quindi, in questo esempio, è possibile dire che <code><code>jane</code></code> è un'istanza di <code><code>Engineer</code></code>. Allo stesso modo, sebbene i termini <em>genitore  </em>(<em>parent</em>), <em>figlio </em>(<em>child</em>), <em>antenato </em>(<em>ancestor</em>) e <em>discendente</em> (<em><em>descendant</em></em>) non hanno un significato conenzionale in JavaScript, possono essere usati in modo informale per riferirsi a oggetti che si trovano più o meno in alto nella catena dei prototipi.</p>
</div>

<h3 id="Creazione_di_oggetti_con_definizioni_semplici">Creazione di oggetti con definizioni semplici</h3>

<div class="twocolumns">
<h4 id="Gerarchia_degli_oggetti">Gerarchia degli oggetti</h4>

<p>La gerarchia seguente è creata usando il codice sulla destra.</p>

<p><img src="https://mdn.mozillademos.org/files/10412/=figure8.3.png"></p>

<p> </p>

<h4 id="singoli_oggetti">singoli oggetti</h4>

<pre class="brush: js">var jim = new Employee;
// jim.name is ''
// jim.dept is 'general'

var sally = new Manager;
// sally.name is ''
// sally.dept is 'general'
// sally.reports is []

var mark = new WorkerBee;
// mark.name is ''
// mark.dept is 'general'
// mark.projects is []

var fred = new SalesPerson;
// fred.name is ''
// fred.dept is 'sales'
// fred.projects is []
// fred.quota is 100

var jane = new Engineer;
// jane.name is ''
// jane.dept is 'engineering'
// jane.projects is []
// jane.machine is ''
</pre>
</div>

<h2 id="Proprietà_degli_oggetti">Proprietà degli oggetti</h2>

<p>Questa sezione spiega come gli oggetti ereditano le proprietà da altri oggetti presenti nella catena dei prototipi e cosa succede quando viene aggiunta una proprietà in fase di esecuzione.</p>

<h3 id="Ereditare_le_proprietà">Ereditare le proprietà</h3>

<p>Supponiamo di creare un nuovo oggetto <code>WorkerBee</code> chiamato <code>mark</code> con l'istruzione seguente:</p>

<pre class="brush: js">var mark = new WorkerBee;
</pre>

<p>Quando JavaScript vede l'operatore <code>new</code>, crea un nuovo oggeto generico e lo passa come valore della parola chiave <code>this</code> nella funzione costruttore <code>WorkerBee</code>. La funzione costruttore imposta esplicitamente il valore della proprietà <code>projects</code> e implicitamente il valore della proprietà interna <code>__proto__</code> uguale al valore <code>WorkerBee.prototype</code>. (Il nome di questa proprietà ha due underscores iniziali e due finali). La proprietà <code>__proto__</code> determina la catena di prototipi usata per restituire i valori delle proprietà. Una volta che queste proprietà sono impostate, JavaScript restituisce il nuovo oggetto e l'istruzione di assegnazione imposta la variabile <code>mark</code> per questo oggetto.</p>

<p>Questo processo non inserisce esplicitamente valori nell'oggetto<code> mark</code> (valori <em>locali</em>) per le proprietà che l'oggetto eredita dalla catena dei prototipi. Quando si richiede un valore di una proprietà, JavaScript prima controlla se il valore è presente nell'oggetto. Se c'è, viene restituito quel valore. Se il valore non è presente a livello locale, JavaScript controlla la catena dei prototipi (sfruttando la proprietà <code>__proto__</code>). Se un oggetto nella catena dei prototipi ha un valore per la proprietà, viene restituito. Se non viene trovata la proprietà, JavaScript risponde che l'oggetto non ha la proprietà cercata. In questo modo, l'oggetto <code>mark</code> ha le seguenti propietà con i rispettivi valori:</p>

<pre class="brush: js">mark.name = "";
mark.dept = "general";
mark.projects = [];
</pre>

<p>L'oggetto <code>mark</code> eredita i valori per le proprietà <code>name</code> e <code>dept</code> dall'oggetto prototipo presente in <code>mark.__proto__</code>. Il costruttore <code>WorkerBee</code> assegna un valore locale per la proprietà <code>projects</code>. L'ereditarietà di proprietà e valori in JavaScript fnziona in questo modo. Alcune sottigliezze su questo processo sono trattate nella sezione <a href="#Ereditare_le_proprietà_(revisited)">Ereditare le proprietà (revisited)</a>.</p>

<p>Poiché questi costruttori non permettono di fornire valori specifici per una singola istanza, questa informazione è generica. I valori delle proprietà sono quelli di default condivisi da tutti i nuovi oggetti creati da <code>WorkerBee</code>. <span class="st">È</span> oviamente possibile cambiare i valori di ognuna di queste proprietà. <span class="st">È</span> quindi possibile assegnare informazioni specifice per <code>mark</code> nel modo seguente:</p>

<pre class="brush: js">mark.name = "Doe, Mark";
mark.dept = "admin";
mark.projects = ["navigator"];</pre>

<h3 id="Aggiungere_proprietà">Aggiungere proprietà</h3>

<p>In JavaScript, è possibile aggiungere proprietà a qualsiasi oggetto in fase di esecuzione. Non si è costretti ad usare solo le proprietà fornite dalla funzione costruttore. Per aggiungere una proprietà che sia specifica per un singolo oggetto, si deve assegnare il valore all'oggetto nel modo seguente::</p>

<pre class="brush: js">mark.bonus = 3000;
</pre>

<p>Ora, l'oggetto <code>mark</code>ha una proprietà <code>bonus</code>, ma nessun altro <code>WorkerBee</code> ha questa proprietà.</p>

<p>Se si aggiunge una nuova proprietà a un oggetto che viene usato come prototipo per una funzione costruttore, la proprietà sarà aggiunta a tutti gli oggetti che ereditano le proprietà dal prototipo. Per esempio, è possibile aggiungere la proprietà <code>specialty</code> a tutti i dipendenti con l'istruzione seguente:</p>

<pre class="brush: js">Employee.prototype.specialty = "none";
</pre>

<p>Non appena JavaScript esegue questa istruzione, anche l'oggetto <code>mark</code> avrà la proprietà <code>specialty</code> con il valore <code>"none"</code>. La figura seguente mostra cosa succede qunado questa proprietà viene aggiunta al prototipo <code>Employee</code> e in seguito la si sovrascrive per il prototipo <code>Engineer</code>.</p>

<p><img alt="" class="internal" src="/@api/deki/files/4422/=figure8.4.png" style="height: 519px; width: 833px;"><br>
 <small><strong>Aggiungere le proprietà</strong></small></p>

<h2 id="Costruttori_più_flessibili">Costruttori più flessibili</h2>

<p>Le funzioni costruttore mostrate finora non permettono di specificare i valori delle proprietà qunado viene creata un'istanza. Come in Java, è possibile fornire argomenti al costruttore per inizializzare i valori delle proprietà per le istanze. La figura seguente mostra un modo per farlo.</p>

<p><img alt="" class="internal" id="figure8.5" src="/@api/deki/files/4423/=figure8.5.png" style="height: 481px; width: 1012px;"><br>
 <small><strong>Specificare le proprietà in un costruttore, modo 1</strong></small></p>

<p>La tabella seguente mostra le definizioni di questi oggetti in JavaScript e in Java.</p>

<div class="twocolumns">
<h4 id="JavaScript_4">JavaScript</h4>

<h4 id="Java_4">Java</h4>
</div>

<div class="twocolumns">
<pre class="brush: js">function Employee (name, dept) {
  this.name = name || "";
  this.dept = dept || "general";
}
</pre>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<pre class="brush: java">public class Employee {
   public String name;
   public String dept;
   public Employee () {
      this("", "general");
   }
   public Employee (String name) {
      this(name, "general");
   }
   public Employee (String name, String dept) {
      this.name = name;
      this.dept = dept;
   }
}
</pre>
</div>

<div class="twocolumns">
<pre class="brush: js">function WorkerBee (projs) {

 this.projects = projs || [];
}
WorkerBee.prototype = new Employee;
</pre>

<p> </p>

<p> </p>

<pre class="brush: java">public class WorkerBee extends Employee {
   public String[] projects;
   public WorkerBee () {
      this(new String[0]);
   }
   public WorkerBee (String[] projs) {
      projects = projs;
   }
}
</pre>
</div>

<div class="twocolumns">
<pre class="brush: js">
function Engineer (mach) {
   this.dept = "engineering";
   this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;
</pre>

<p> </p>

<p> </p>

<pre class="brush: java">public class Engineer extends WorkerBee {
   public String machine;
   public Engineer () {
      dept = "engineering";
      machine = "";
   }
   public Engineer (String mach) {
      dept = "engineering";
      machine = mach;
   }
}
</pre>
</div>

<p>Queste definizioni JavaScript usano un linguaggio speciale per impostare i valori di default:</p>

<pre class="brush: js">this.name = name || "";
</pre>

<p>In JavaScript l'operatore logico OR (<code>||</code>) valuta il suo primo argomento. Se questa espressione può essere convertita a <code>true</code>, l'operatore restituisce il primo argomento. Altrimenti l'operatore restituisce il valore del secondo argomento. Quindi, questa linea di codice verifica se <code>name</code> ha un valore utile per la proprietà <code>name</code>. Se ce l'ha, imposta <code>this.name</code> a questo valore. Altrimenti, imposta <code>this.name</code> a una stringa vuota. Questo capitolo usa questo linguaggio per brevità, comunque può disorientare a prima vista.</p>

<div class="note">
<p><strong>Nota:</strong> Potrebbe non funzionare come atteso se la funzione costruttore è chiamata con un argomento che converte a <code>false</code> (come ad esempio <code>0</code> (zero) o una stringa vuota (<code><code>""</code></code>)). In questo caso verrà scelto il valore di default.</p>
</div>

<p>Con queste definizioni, quando si crea un'istanza di un oggetto, è possibile specificare i valori per le proprietà definite localmente. <span class="st">Per creare un nuovo <code>Engineer</code></span> è possibile utilizzare l'espressione seguente:</p>

<pre class="brush: js">var jane = new Engineer("belau");
</pre>

<p>Le proprietà di <code>Jane</code> sono ora:</p>

<pre class="brush: js">jane.name == "";
jane.dept == "engineering";
jane.projects == [];
jane.machine == "belau"
</pre>

<p><span class="st">È</span> da notare che con queste definizioni non è possibile specificare una valore iniziale per le proprietà ereditate, come ad esempio <code>name</code>. Se si desidera specificare un valore iniziale per una proprietà ereditata, in JavaScript è necessario aggiungere ulteriore codice alla funzione costruttore.</p>

<p>Finora, la funzione costruttore ha creato un oggetto generico e poi ha specificato proprietà locali e valori per il nuovo oggetto. <span class="st">È</span> possibile fare in modo che il costruttore aggiunga più proprietà chiamando direttamente la funzione costruttore per un oggetto che si trova a un livello più alto nella catena dei prototipi. La figura seguente mostra queste nuove definizioni.</p>

<p><img alt="" class="internal" src="/@api/deki/files/4430/=figure8.6.png" style="height: 534px; width: 1063px;"><br>
 <small><strong>Specificare le proprietà in un costruttore, modo 2</strong></small></p>

<p>Guardiamo nel dettaglio una di queste definizioni. Ecco la nuova definizione per il costruttore <code>Engineer</code>:</p>

<pre class="brush: js">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
</pre>

<p>Supponiamo di creare un nuovo oggetto <code>Engineer</code> nel modo seguente:</p>

<pre class="brush: js">var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
</pre>

<p>JavaScript segue questa procedura:</p>

<ol>
 <li>L'operatore <code>new</code> crea un oggetto generico e imposta il valore <code>Engineer.prototype</code> per la sua proprietà <code>__proto__</code>.</li>
 <li>L'operatore <code>new</code> passa il nuovo oggetto come valore della parola chiave <code>this</code> nella funzione costruttore <code>Engineer</code>.</li>
 <li>Il costruttore crea una nuova proprietà per l'oggetto chiamata <code>base</code> e assegna il valore del costruttore <code>WorkerBee</code> alla proprietà <code>base</code>. Questo rende il costruttore <code>WorkerBee</code> un metode dell'oggetto <code>Engineer</code>. Il nome della proprietà <code>base</code> non è peculiare. <span class="st">È</span> possibile usare qualsiasi nome per la proprietà; <code>base</code> è semplicemente evocativo dello scopo.</li>
 <li>Il costruttore chiama il metodo <code>base</code>, passando come suoi argomenti due degli argomenti passati al costruttore (<code>"Doe, Jane"</code> e <code>["navigator", "javascript"]</code>) e anche la stringa <code>"engineering"</code>. Usando esplicitamente <code>"engineering"</code> nel costruttore indica che tutti gli oggetti <code>Engineer</code> hanno lo stesso valore per la proprietà <code>dept</code> ereditata, e questo valore sovrascrive il valore ereditato dal costruttore <code>Employee</code>.</li>
 <li>Poiché <code>base</code> è un metodo di <code>Engineer</code>, all'interno della chiamata di <code>base</code>, JavaScript aggiunge la parola chiave <code>this</code> all'oggetto creato al passaggio 1. In questo modo, la funzione <code>WorkerBee</code> a sua volta passa gli argomenti <code>"Doe, Jane"</code> e <code>"engineering"</code> alla funzione costruttore <code>Employee</code>. Dopo l'esecuzione della funzione costruttore <code>Employee</code>, la funzione <code>WorkerBee</code> utilizza l'argomento rimanente per impostare la proprietà<code> projects</code>.</li>
 <li>Dopo l'esecuzione del metodo <code>base</code>, il costruttore <code>Engineer</code> inizializza la proprietà <code>machine</code> dell'oggetto al valore <code>"belau"</code>.</li>
 <li>Dopo l'esecuzione del costruttore, JavaScript assegna il nuovo oggetto alla variabile <code>jane</code>.</li>
</ol>

<p>Avendo chiamato il costruttore <code>WorkerBee</code> dall'interno del costruttore <code>Engineer</code>, si potrebbe pensare di aver impostato in modo corretto l'ereditarietà per gli oggetti <code>Engineer</code>. Questo non è il caso. Chiamare il costruttore <code>WorkerBee</code> assicura che un oggetto <code>Engineer</code> venga creato con le proprietà specificate in tutte le funzioni costruttore che sono chiamate. Però, se in un secondo momento vengono aggiunte proprietà ai prototipi <code>Employee</code> o <code>WorkerBee</code>, queste proprietà non saranno ereditate dall'oggetto <code>Engineer</code>. Per esempio, se si considera il codice seguente:</p>

<pre class="brush: js">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
Employee.prototype.specialty = "none";
</pre>

<p>L'oggetto <code>jane</code> non eredita la proprietà <code>specialty</code>. <span class="short_text" id="result_box" lang="it"><span>È</span></span> comunque necessario impostare esplicitamente il prototipo per garantire l'ereditarietà dinamica. Se si considera invece l'esempio seguente:</p>

<pre class="brush: js">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;
var jane = new Engineer("Doe, Jane", ["navigator", "javascript"], "belau");
Employee.prototype.specialty = "none";
</pre>

<p>Adesso il valore per l'oggetto <code>jane</code> della proprietà <code>specialty</code> è "none".</p>

<p>Un altro modo per ereditare le proprietà è l'utilizzo dei metodi <code><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" title="en-US/docs/JavaScript/Reference/Global Objects/Function/call">call()</a></code> e <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" title="en-US/docs/JavaScript/Reference/Global Objects/Function/apply"><code>apply()</code></a>. Gli esempi sottostanti si equivalgono:</p>

<div class="twocolumns">
<pre class="brush: js">function Engineer (name, projs, mach) {
  this.base = WorkerBee;
  this.base(name, "engineering", projs);
  this.machine = mach || "";
}
</pre>

<pre class="brush: js">function Engineer (name, projs, mach) {
  WorkerBee.call(this, name, "engineering", projs);
  this.machine = mach || "";
}
</pre>
</div>

<p>L'utilizzo del metodo <code>call()</code> costituisce un'implementazione più pulita poiché la proprietà <code>base</code> non è più necessaria.</p>

<h2 id="Ereditare_le_proprietà_(revisited)">Ereditare le proprietà (revisited)</h2>

<p>Le sezioni precedenti descrivono come i costruttori e i prototipi consentono di avere gerarchia ed ereditarietà in JavaScript. Questa sezione espone alcune sottiglienzze che non erano necessariamente evidenti nelle discussioni precedenti.</p>

<h3 id="Valori_locali_vs._valori_ereditati">Valori locali vs. valori ereditati</h3>

<p>Quando si accede a una proprietà di un oggetto, JavaScript esegue i seguenti passaggi, come descritto in precedenza in questo capitolo:</p>

<ol>
 <li>Verifica se il valore è presente a livello locale. Se c'è, restituisce quel valore.</li>
 <li>Se non è presente, verifica la catena dei prototipi (usando la proprietà <code>__proto__</code>).</li>
 <li>Se un oggetto nella catena dei prototipi ha un valore per la proprietà specificata, restituisce quel valore.</li>
 <li>Se la proprietà non viene trovata, l'oggetto non ha la proprietà.</li>
</ol>

<p>Il risultato di questo processo dipende da come sono stati definiti gli elementi. L'esempio iniziale aveva queste definizioni:</p>

<pre class="brush: js">function Employee () {
  this.name = "";
  this.dept = "general";
}

function WorkerBee () {
  this.projects = [];
}
WorkerBee.prototype = new Employee;
</pre>

<p>Con queste definizioni, si supponga di creare <code>amy</code> come un'istanza di <code>WorkerBee</code> con la seguente istruzione:</p>

<pre class="brush: js">var amy = new WorkerBee;
</pre>

<p>L'oggetto <code>amy</code> ha una proprietà locale, <code>projects</code>. I valori per le proprietà <code>name</code> e <code>dept</code> non sono specifici per <code>amy</code> e quindi derivano dalla proprietà <code>__proto__</code> dell'oggetto <code>amy</code>. Quindi, <code>amy</code> ha i seguenti valori:</p>

<pre class="brush: js">amy.name == "";
amy.dept == "general";
amy.projects == [];
</pre>

<p>Ora si supponga di cambiare il valore della proprietà <code>name</code> nel prototipo associato con <code>Employee</code>:</p>

<pre class="brush: js">Employee.prototype.name = "Unknown"
</pre>

<p>Ci si potrebbe aspettare che il nuovo valore si propaghi a tutte le istanze di <code>Employee</code>. Invece, non lo fa.</p>

<p>Quando si crea <em>qualsiasi </em>istanza dell'oggetto <code>Employee</code>, questa istanza riceve un <strong>valore locale</strong> per la proprietà <code>name</code> (la stringa vuota). Questo significa che quando si imposta il prototipo <code>WorkerBee</code> creando un nuovo oggetto <code>Employee</code>, <code>WorkerBee.prototype</code> avrà un valore locale per la proprietà <code>name</code>. Quindi, quando JavaScript legge la proprietà <code>name</code> dell'oggetto <code>amy</code> (istanza di <code>WorkerBee</code>), trova in <code>WorkerBee.prototype </code>il valore locale di questa proprietà. Pertanto non continua a cercare nella catena salendo a <code>Employee.prototype</code>.</p>

<p>Se si vuole cambiare il valore di una proprietà di un oggetto in fase di esecuzione e si vuole che il nuovo valore venga ereditato da tutti i discendenti dell'oggetto, non è possibile definire la proprietà all'interno della funzione costruttore dell'oggetto. Invece, si aggiunge la proprietà al prototipo associato al costruttore. Per esempio, assumiamo di cambiare il codice precedente con quello che segue:</p>

<pre class="brush: js">function Employee () {
  this.dept = "general";    // Note that this.name (a local variable) does not appear here
}
Employee.prototype.name = "";    // A single copy

function WorkerBee () {
  this.projects = [];
}
WorkerBee.prototype = new Employee;

var amy = new WorkerBee;

Employee.prototype.name = "Unknown";
</pre>

<p>In questo caso, il valore della proprietà <code>name</code> di <code>amy</code> diventa "Unknown".</p>

<p>Come mostra questo esempio, se si vogliono avere i valori di default per le proprietà dell'oggetto e si vuole avere la possibilità di cambiare questi valori in fase di esecuzione, si devono impostare le proprietà nel prototipo del costruttore, e non direttamente nella funzione costruttore.</p>

<h3 id="Determinazione_delle_relazioni_tra_istanze">Determinazione delle relazioni tra istanze</h3>

<p>In JavaScript la ricerca delle proprietà (<em>property lookup</em>) controlla prima tra le proprietà specifiche dell'oggetto e, se il nome della proprietà non viene trovato, controlla la proprietà speciale <code>__proto__</code>. Il processo, chiamato "ricerca nella catena dei prototipi" (<em>lookup in the prototype chain</em>), continua ricorsivamente .</p>

<p>Quando un oggetto viene costruito, la proprietà speciale <code>__proto__</code> viene impostata al valore della proprietà <code>prototype</code> del costruttore. L'espressione <code>new Foo()</code> crea un oggetto con <code>__proto__ == <code class="moz-txt-verticalline">Foo.prototype</code></code>. Di conseguenza, le modifiche alle proprietà di <code class="moz-txt-verticalline">Foo.prototype</code> alterano la ricerca delle proprietà per tutti gli oggetti che sono stati creati con <code>new Foo()</code>.</p>

<p>Ogni oggetto ha una proprietà <code>__proto__</code> (ad eccezione di <code>Object</code>); ogni funzione ha una proprietà <code>prototype</code>. Quindi gli oggetti possono essere correlati ad altri oggetti attraverso una 'ereditarietà prototipale' (<em>prototypal inheritance</em>). <span class="st">È</span> possibile verificare l'ereditarietà confrontando la proprietà <code>__proto__</code> di un oggetto con l'oggetto <code>prototype</code> di una funzione. JavaScript fornisce una scorciatoia: l'operatore <code>instanceof</code> confronta un oggetto con una funzione e restituisce <code>true</code> se l'oggetto eredita dal prototipo della funzione. Per esempio,</p>

<pre class="brush: js">var f = new Foo();
var isTrue = (f instanceof Foo);</pre>

<p>Per un esempio più dettagliato, supponiamo di avere lo stesso gruppo di definizioni visto nella sezione For a more detailed example, suppose you have the same set of definitions shown in <a href="#Ereditare_le_proprietà">Ereditare le proprietà</a>. Creiamo un oggetto <code>Engineer</code> nel modo seguente:</p>

<pre class="brush: js">var chris = new Engineer("Pigman, Chris", ["jsd"], "fiji");
</pre>

<p>Per questo oggetto, tutti gli enunciati seguenti sono veri:</p>

<pre class="brush: js">chris.__proto__ == Engineer.prototype;
chris.__proto__.__proto__ == WorkerBee.prototype;
chris.__proto__.__proto__.__proto__ == Employee.prototype;
chris.__proto__.__proto__.__proto__.__proto__ == Object.prototype;
chris.__proto__.__proto__.__proto__.__proto__.__proto__ == null;
</pre>

<p>Dato ciò, è possibile scrivere una funzione <code>instanceOf</code> come segue:</p>

<pre class="brush: js">function instanceOf(object, constructor) {
   object = object.__proto__;
   while (object != null) {
      if (object == constructor.prototype)
         return true;
      if (typeof object == 'xml') {
        return constructor.prototype == XML.prototype;
      }
      object = object.__proto__;
   }
   return false;
}
</pre>

<div class="note">
<p><strong>Nota:</strong> L'implementazione vista sopra verifica se l'oggetto è di tipo "xml" per ovviare a una stranezza nel modo in cui gli oggetti XML sono rappresentati nelle versioni recenti di JavaScript. Per i dettagli essenziali si veda il {{ bug(634150) }}.</p>
</div>

<p>Se si utilizza la funzione <code>instanceOf</code> definita in precedenza, queste espressioni sono vere:</p>

<pre class="brush: js">instanceOf (chris, Engineer)
instanceOf (chris, WorkerBee)
instanceOf (chris, Employee)
instanceOf (chris, Object)
</pre>

<p>Ma l'espressione seguente è falsa:</p>

<pre class="brush: js">instanceOf (chris, SalesPerson)
</pre>

<h3 id="Informazioni_globali_nei_costruttori">Informazioni globali nei costruttori</h3>

<p>Quando vengono creati dei costruttori, è necessario essere scrupolosi se si impostano informazioni globali all'interno del costruttore. Per esempio, se si vuole che un ID univoco venga assegnato automaticamente a ogni nuovo <code>Employee </code>si potrebbe usare la definizione seguente:</p>

<pre class="brush: js">var idCounter = 1;

function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   this.id = idCounter++;
}
</pre>

<p>Con questa definizione, quando viene creato un nuovo <code>Employee</code>, il costruttore assegna l'ID seguente e incrementa il contatore globale (<code>idCounter</code>). Così, se l'istruzione successiva è la seguente, l'ID di <code>victoria </code>sarà 1, l'ID di <code>harry </code>sarà 2:</p>

<pre class="brush: js">var victoria = new Employee("Pigbert, Victoria", "pubs")
var harry = new Employee("Tschopik, Harry", "sales")
</pre>

<p>Questa a prima vista potrebbe sembrare la procedura corretta. Tuttavia, il contatore globale <code>idCounter</code> viene incrementato ogni volta che viene creato un oggetto <code>Employee</code>, per qualsiasi scopo. Se viene creata l'intera gerarchia di oggetti <code>Employee</code> mostrata in questo capitolo, il costruttore <code>Employee</code> viene chiamato ogni volta che si definisce un prototipo. Supponiamo di avere il codice seguente:</p>

<pre class="brush: js">var idCounter = 1;

function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   this.id = idCounter++;
}

function Manager (name, dept, reports) {...}
Manager.prototype = new Employee;

function WorkerBee (name, dept, projs) {...}
WorkerBee.prototype = new Employee;

function Engineer (name, projs, mach) {...}
Engineer.prototype = new WorkerBee;

function SalesPerson (name, projs, quota) {...}
SalesPerson.prototype = new WorkerBee;

var mac = new Engineer("Wood, Mac");
</pre>

<p>Si assuma inoltre che le definizioni omesse abbiano la proprietà <code>base</code> e chiamino il costruttore che si trova al livello superiore nella catena dei prototipi. In questo caso, nel momento in cui viene creato l'oggetto <code>mac</code>, il valore di <code>mac.id</code> sarà 5.</p>

<p>A seconda dell'applicazione, può essere più o meno importante che il valore del contatore sia stato incrementato queste volte aggiuntive. Se interessa il valore esatto di questo contatore, una soluzione possibile può prevedere l'uso del costruttore seguente al posto di quello visto in precedenza:</p>

<pre class="brush: js">function Employee (name, dept) {
   this.name = name || "";
   this.dept = dept || "general";
   if (name)
      this.id = idCounter++;
}
</pre>

<p>Quando viene creata un'istanza di <code>Employee</code> che deve essere usata come prototipo, non vengono forniti argomenti al costruttore. Usando questa definizione del costruttore, quando non vengono inseriti argomenti, il costruttore non assegna un valore all'ID e non aggiorna il contatore. Quindi, affinché a un oggetto <code>Employee</code> venga assegnato un ID, è necesario specificare un nome per il dipendente. In questo esempio, l'ID di <code>mac</code> sarà 1.</p>

<h3 id="JavaScript_non_supporta_l'ereditarietà_multipla">JavaScript non supporta l'ereditarietà multipla</h3>

<p>Alcuni linguaggi ad oggetti ammettono l'ereditarietà multipla. Ossia, un oggetto può ereditare proprietà e valori da oggetti genitori non correlati. Javascript non supporta l'ereditarietà multipla.</p>

<p>L'eredità dei valori delle proprietà si ha in fase di esecuzione quando JavaScript cerca attraverso la catena dei prototipo di un oggetto per trovare un valore. Poiché un oggetto ha un unico prototipo associato, JavaScript non può ereditare dinamicamente da più di una catena di prototipi.</p>

<p>In JavaScript, è possibile che una funzione costruttore chiami al suo interno diverse funzioni costruttore. Questo dà l'illusione dell'ereditarietà multipla. Per esempio consideriamo le istruzioni seguenti:</p>

<pre class="brush: js">function Hobbyist (hobby) {
   this.hobby = hobby || "scuba";
}

function Engineer (name, projs, mach, hobby) {
   this.base1 = WorkerBee;
   this.base1(name, "engineering", projs);
   this.base2 = Hobbyist;
   this.base2(hobby);
   this.machine = mach || "";
}
Engineer.prototype = new WorkerBee;

var dennis = new Engineer("Doe, Dennis", ["collabra"], "hugo")
</pre>

<p>Assumiamo inoltre che la definizione di <code>WorkerBee</code> sia quella usata in precedenza in questo capitolo. In questo caso, l'oggetto <code>dennis</code> avrà queste proprietà:</p>

<pre class="brush: js">dennis.name == "Doe, Dennis"
dennis.dept == "engineering"
dennis.projects == ["collabra"]
dennis.machine == "hugo"
dennis.hobby == "scuba"
</pre>

<p>Quindi <code>dennis</code> riceve la proprietà <code>hobby</code> dal costruttore <code>Hobbyist</code>. Però, se in seguito si aggiunge una proprietà al prototipo del costruttore <code>Hobbyist</code>:</p>

<pre class="brush: js">Hobbyist.prototype.equipment = ["mask", "fins", "regulator", "bcd"]
</pre>

<p>L'oggetto <code>dennis</code> non erediterà questa nuova proprietà.</p>

<div>{{PreviousNext("Web/JavaScript/Guide/Working_with_Objects", "Web/JavaScript/Guide/Iterators_and_Generators")}}</div>
