---
title: Ereditarietà e catena dei prototype
slug: Web/JavaScript/Inheritance_and_the_prototype_chain
tags:
  - Intermedio
  - JavaScript
  - OOP
  - ereditarietà
translation_of: Web/JavaScript/Inheritance_and_the_prototype_chain
---
<div>{{jsSidebar("Advanced")}}</div>

<p>JavaScript confonde un po' gli sviluppatori che hanno esperienza di linguaggi basati sulle classi (come Java o C++), siccome è un linguaggio dinamico e non fornisce un'implementazione di <code>class</code> (la keyword <code>class</code> è introdotto in ES2015, ma è zucchero sintattico, Javascript rimarrà basato sui prototipi).</p>

<p>In termini di ereditarietà, Javascript ha solo un costrutto: gli oggetti. Ogni oggetto ha un link interno ad un altro oggetto chiamato <strong>prototype.</strong> Questo oggetto prototype ha a sua volta un suo prototype, e così via finché si raggiunge un oggetto con property <code>null</code>. <code>null</code>, per definizione, non ha un prototype, ed agisce come link finale nella <strong>catena di prototipi</strong>.</p>

<p>Quasi tutti gli oggetti in Javascript sono istanze di {{jsxref("Object")}}, che risiede in cima alla catena dei prototipi.</p>

<p>Nonostante questo sia considerato spesso come una debolezza di Javascript, il modello di ereditarietà prototipale è invece più potente del modello classico. Per esempio, è banale costruire un classico modello sul modello prototipale, mentre il contrario è molto più difficile.</p>

<h2 id="Ereditarietà_con_la_catena_di_prototipi">Ereditarietà con la catena di prototipi</h2>

<h3 id="Ereditare_properties">Ereditare properties</h3>

<p>Gli oggetti javaScript sono "contenitori" dinamici di proprietà (<strong>own properties</strong>). Gli oggetti JavaScript hanno un link ad un oggetto prototype. Provando ad accedere ad una proprietà di un oggetto, la proprietà sarà ricercata sia sull'oggetto, sia sul prototipo, sul prototipo del prototipo e così via fino a trovare una proprietà con il nome specificato fino alla fine della catena stessa.</p>

<div class="note">
<p>Seguendo lo standard ECMAScript, la notazione <code>someObject.[[Prototype]]</code> viene usata per designare il prototype di <code>someObject</code>. Dall'introduzione di ECMAScript 2015, per accedere a <code>[[Protoype]]</code> si utilizzano i metodi {{jsxref("Object.getPrototypeOf()")}} e {{jsxref("Object.setPrototypeOf()")}}. Questo è equivalente ad utilizzare la property <code>__proto__</code>, proprietà non-standard di JavaScript ma di fatto implementata da svaritati browser.</p>

<p>Non dev'essere confusa con la proprietà delle funzioni <code><em>func</em>.prototype</code>, la quale invece specifica il [[Prototype]] da assegnare a tutte le <em>istanze</em> di oggetti creati dalla funzione data quando si usa un costruttore. La proprietà <strong>Object.prototype </strong> rappresenta il prototipo oggetto  {{jsxref("Object")}} .</p>
</div>

<p>Di seguito viene mostrato cosa succede quando si tenta l'accesso ad una proprietà:</p>

<pre class="brush: js">//Creiamo un oggetto o dalla funzione f con le sue properties a e b;
let f = function() {
   this.a = 1;
   this.b = 2;
}
let o = new f(); //{a: 1, b: 2}
//Aggiungiamo delle properties nel prototype di f
f.prototype.b = 3;
f.prototype.c = 4;

//non aggiungere le properties a f mediante f.prototype = {b:3,c:4}; questo romperebbe la prototype chain
// o.[[Prototype]] ha le properties b and c:
// {b: 3, c: 4}
// o.[[Prototype]].[[Prototype]] è Object.prototype.
// Infine, o.[[Prototype]].[[Prototype]].[[Prototype]] é null.
// Questa è la fine della catena di prototipi poiché null, per defini// zione, non ha [[Prototype]].
// Così, l'intera catena di prototipi sarà:
// {a:1, b:2} ---&gt; {b:3, c:4} ---&gt; Object.prototype ---&gt; null

console.log(o.a); // 1
// C'è una property 'a' su o? Si, e il suo valore è 1.

console.log(o.b); // 2
// C'è una property 'b' su o? Si, e il suo valore è 2.
// Il prototype ha anche una property 'b', ma non è visitata.
// Questa è chiamata "Property Shadowing"

console.log(o.c); // 4
// C'è una propria property 'c' su o? No, verifica il suo prototype.
// C'è una propria property 'c' su o.[[Prototype]]? si, il suo valore// è 4.

console.log(o.d); // undefined
// C'è una propria property 'd' su o? No, verifica il suo prototype.
// C'è una propria property 'd' su o.[[Prototype]]? No, verifica il suo prototype.
// o.[[Prototype]].[[Prototype]] è Object.prototype e non è presente nessuna property 'd' di default, verifica il suo prototype.
// o.[[Prototype]].[[Prototype]].[[Prototype]] è null, stop alla ricerca,
// nessuna property trovata, restituisce undefined
</pre>

<p>Impostando una property su un oggetto viene creata una own property. La sola eccezione alle regole di comportamento setting e getting è quando c'è una property ereditata con un <a href="/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters" title="Defining Getters and Setters">getter or a setter</a>.</p>

<h3 id="Metodi_ereditati">"Metodi" ereditati</h3>

<p>JavaScript non ha "metodi" nella forma tipica dei linguaggi basati sulle classi. In JavaScript, qualunque funzione può essere aggiunta ad un oggetto come fosse property. Una funzione ereditata agisce come ogni altra property, incluse le  property shadowing come mostrato di seguito (in questo caso, una forma di <em>sovrascrittura di metodi</em>).</p>

<p>Quando viene eseguita una funzione ereditata, il valore del <a href="/en-US/docs/Web/JavaScript/Reference/Operators/this" title="this"><code>this</code></a> punta all'oggetto ereditante, non all'oggetto prototype dove la funzione è una property proprietaria (own property).</p>

<pre class="brush: js">var o = {
  a: 2,
  m: function(b){
    return this.a + 1;
  }
};

console.log(o.m()); // 3
// Chiamando o.m in questo caso, 'this' si riferisce a o

var p = Object.create(o);
// p è un oggeto che eredita da o

p.a = 12; // crea una propria property 'a' su p
console.log(p.m()); // 13
// quando p.m è chiamata, 'this' si riferisce a p.
// Così quando p eredita la funzione m di o,
// 'this.a' significa p.a, the propria property 'a' di p
</pre>

<h2 id="Luso_di_prototypes_in_Javascript">L'uso di prototypes in Javascript</h2>

<p>Guardiamo cos'è successo dietro le quinte con maggior dettaglio.</p>

<p>In Javascript, come già detto in precedenza, le funzioni possono avere delle properties. Tutte le funzioni hanno una property  speciale chiamata <code>prototype</code>. Si prega di notare che il codice sottostante è autonomo (si può presumere che non ci sia altro codice JavaScript nella pagina web oltre al codice sottostante). Per una migliore esperienza di apprendimento, si consiglia vivamente di aprire una console, navigare fino alla scheda "console", copiare e incollare nel codice JavaScript sottostante ed eseguirlo premendo il tasto Invio. (La console è inclusa nella maggior parte degli strumenti per sviluppatori del browser web. Ulteriori informazioni sono disponibili per <a href="https://wiki.developer.mozilla.org/en-US/docs/Tools">Firefox Developer Tools</a>, <a href="https://developers.google.com/web/tools/chrome-devtools/">Chrome DevTools</a>, and <a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide">Edge DevTools</a>.)</p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="keyword token">function</span> <span class="function token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span> doSomething<span class="punctuation token">.</span>prototype <span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="comment token">// Non importa come dichiari una funzione, una</span>
<span class="comment token">// funzione in JavaScript </span><span class="comment token">avrà sempre una property
// prototype di default.</span>
<span class="keyword token">var</span> <span class="function function-variable token">doSomething</span> <span class="operator token">=</span> <span class="keyword token">function</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span> doSomething<span class="punctuation token">.</span>prototype <span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>

<p>Come visto sopra, <code>doSomething()</code> ha una property <code>prototype</code> predefinita, come visualizzato dalla console. Dopo aver eseguito questo codice, la console dovrebbe aver visualizzato un oggetto simile a questo.</p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="punctuation token">{</span>
    constructor<span class="punctuation token">:</span> ƒ <span class="function token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
    __proto__<span class="punctuation token">:</span> <span class="punctuation token">{</span>
        constructor<span class="punctuation token">:</span> ƒ <span class="function token">Object</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        hasOwnProperty<span class="punctuation token">:</span> ƒ <span class="function token">hasOwnProperty</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        isPrototypeOf<span class="punctuation token">:</span> ƒ <span class="function token">isPrototypeOf</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        propertyIsEnumerable<span class="punctuation token">:</span> ƒ <span class="function token">propertyIsEnumerable</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        toLocaleString<span class="punctuation token">:</span> ƒ <span class="function token">toLocaleString</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        toString<span class="punctuation token">:</span> ƒ <span class="function token">toString</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        valueOf<span class="punctuation token">:</span> ƒ <span class="function token">valueOf</span><span class="punctuation token">(</span><span class="punctuation token">)</span>
    <span class="punctuation token">}</span>
<span class="punctuation token">}</span></code></pre>

<p>Possiamo aggiungere delle properties al prototype di <code>doSomething()</code>, come mostrato in seguito.</p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="keyword token">function</span> <span class="function token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
doSomething<span class="punctuation token">.</span>prototype<span class="punctuation token">.</span>foo <span class="operator token">=</span> <span class="string token">"bar"</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span> doSomething<span class="punctuation token">.</span>prototype <span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>

<p>Il risultato è:</p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="punctuation token">{</span>
    foo<span class="punctuation token">:</span> <span class="string token">"bar"</span><span class="punctuation token">,</span>
    constructor<span class="punctuation token">:</span> ƒ <span class="function token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
    __proto__<span class="punctuation token">:</span> <span class="punctuation token">{</span>
        constructor<span class="punctuation token">:</span> ƒ <span class="function token">Object</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        hasOwnProperty<span class="punctuation token">:</span> ƒ <span class="function token">hasOwnProperty</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        isPrototypeOf<span class="punctuation token">:</span> ƒ <span class="function token">isPrototypeOf</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        propertyIsEnumerable<span class="punctuation token">:</span> ƒ <span class="function token">propertyIsEnumerable</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        toLocaleString<span class="punctuation token">:</span> ƒ <span class="function token">toLocaleString</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        toString<span class="punctuation token">:</span> ƒ <span class="function token">toString</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        valueOf<span class="punctuation token">:</span> ƒ <span class="function token">valueOf</span><span class="punctuation token">(</span><span class="punctuation token">)</span>
    <span class="punctuation token">}</span>
<span class="punctuation token">}</span></code></pre>

<p>Ora possiamo usare l'operatore <code>new</code> per creare un'istanza di <code>doSomething()</code> basata su questo prototipo. Per usare l'operatore <code>new</code>, è sufficiente invocare la funzione normalmente, utilizzando però il prefisso new. Chiamare una funzione con l'operatore <code>new</code> restituisce un oggetto che è un'istanza della funzione. Le proprietà possono poi essere aggiunte a questo oggetto.</p>

<p>Prova ad eseguire il seguente codice:</p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="keyword token">function</span> <span class="function token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
doSomething<span class="punctuation token">.</span>prototype<span class="punctuation token">.</span>foo <span class="operator token">=</span> <span class="string token">"bar"</span><span class="punctuation token">;</span> <span class="comment token">// aggiungo una property alla prototype</span>
<span class="keyword token">var</span> doSomeInstancing <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
doSomeInstancing<span class="punctuation token">.</span>prop <span class="operator token">=</span> <span class="string token">"some value"</span><span class="punctuation token">;</span> <span class="comment token">// aggiungo una property all'oggetto</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span> doSomeInstancing <span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>

<p><span class="punctuation token">Il risultato restituito è simile al seguente:</span></p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="punctuation token">{</span>
    prop<span class="punctuation token">:</span> <span class="string token">"some value"</span><span class="punctuation token">,</span>
    __proto__<span class="punctuation token">:</span> <span class="punctuation token">{</span>
        foo<span class="punctuation token">:</span> <span class="string token">"bar"</span><span class="punctuation token">,</span>
        constructor<span class="punctuation token">:</span> ƒ <span class="function token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
        __proto__<span class="punctuation token">:</span> <span class="punctuation token">{</span>
            constructor<span class="punctuation token">:</span> ƒ <span class="function token">Object</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
            hasOwnProperty<span class="punctuation token">:</span> ƒ <span class="function token">hasOwnProperty</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
            isPrototypeOf<span class="punctuation token">:</span> ƒ <span class="function token">isPrototypeOf</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
            propertyIsEnumerable<span class="punctuation token">:</span> ƒ <span class="function token">propertyIsEnumerable</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
            toLocaleString<span class="punctuation token">:</span> ƒ <span class="function token">toLocaleString</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
            toString<span class="punctuation token">:</span> ƒ <span class="function token">toString</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span>
            valueOf<span class="punctuation token">:</span> ƒ <span class="function token">valueOf</span><span class="punctuation token">(</span><span class="punctuation token">)</span>
        <span class="punctuation token">}</span>
    <span class="punctuation token">}</span>
<span class="punctuation token">}</span></code></pre>

<p>Come visto in precedenza, il <code>__proto__ </code>di <code>doSomeInstancing</code> è <code>doSomething.prototype</code>. Ma, cosa significa? Quando si accede a una proprietà di <code>doSomeInstancing</code>, il browser controlla se <code>doSomeInstancing</code> ha quella proprietà.</p>

<p>Se <code>doSomeInstancing</code> non ha la proprietà, allora il browser cerca la proprietà nel <code>__proto__ </code>di <code>doSomeInstancing</code> (alias doSomething.prototype). Se il <code>__proto__</code> di doSomeInstancing ha la proprietà che si sta cercando, allora quella proprietà presente nel <code>__proto__</code> di doSomeInstancing viene usata.</p>

<p>Altrimenti, se il <code>__proto__</code> di doSomeInstancing non ha la proprietà, allora il <code>__proto__</code> del <code>__proto__ </code>di doSomeInstancing viene controllato per verificare la presenza della proprietà cercata. Di default, il <code>__proto__</code> di ogni proprietà prototype di qualsiasi funzione è <code>window.Object.prototype</code>. Quindi, il <code>__proto__</code> del <code>__proto__</code> di doSomeInstancing (alias il <code>__proto__</code> di doSomething.prototype (alias Object.prototype))  viene poi controllato alla ricerca della proprietà che si sta cercando.</p>

<p>Se la proprietà non si trova nel <code>__proto__</code> del <code>__proto__</code> di doSomeInstancing, allora il <code>__proto__</code> del <code>__proto__</code> del <code>__proto__</code> di doSomeInstancing viene esaminato. Tuttavia, c'è un problema: il <code>__proto__</code> del <code>__proto__</code> del <code>__proto__</code>  di doSomeInstancing non esiste. Quindi, e solo allora, dopo che l'intera catena di prototipi di <code>__proto__</code> è stata esaminata, e non ci sono più <code>__proto__</code>, il browser conferma che la proprietà non esiste e conclude che il valore della proprietà è <code>undefined</code>.</p>

<p>Proviamo ad inserire altro codice nella console:</p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="keyword token">function</span> <span class="function token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
doSomething<span class="punctuation token">.</span>prototype<span class="punctuation token">.</span>foo <span class="operator token">=</span> <span class="string token">"bar"</span><span class="punctuation token">;</span>
<span class="keyword token">var</span> doSomeInstancing <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">doSomething</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
doSomeInstancing<span class="punctuation token">.</span>prop <span class="operator token">=</span> <span class="string token">"some value"</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">"doSomeInstancing.prop:      "</span> <span class="operator token">+</span> doSomeInstancing<span class="punctuation token">.</span>prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">"doSomeInstancing.foo:       "</span> <span class="operator token">+</span> doSomeInstancing<span class="punctuation token">.</span>foo<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">"doSomething.prop:           "</span> <span class="operator token">+</span> doSomething<span class="punctuation token">.</span>prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">"doSomething.foo:            "</span> <span class="operator token">+</span> doSomething<span class="punctuation token">.</span>foo<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">"doSomething.prototype.prop: "</span> <span class="operator token">+</span> doSomething<span class="punctuation token">.</span>prototype<span class="punctuation token">.</span>prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">"doSomething.prototype.foo:  "</span> <span class="operator token">+</span> doSomething<span class="punctuation token">.</span>prototype<span class="punctuation token">.</span>foo<span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>

<p>Il risultato è il seguente:</p>

<pre class="brush: js line-numbers language-js"><code class="language-js">doSomeInstancing<span class="punctuation token">.</span>prop<span class="punctuation token">:</span>      some value
doSomeInstancing<span class="punctuation token">.</span>foo<span class="punctuation token">:</span>       bar
doSomething<span class="punctuation token">.</span>prop<span class="punctuation token">:</span>           <span class="keyword token">undefined</span>
doSomething<span class="punctuation token">.</span>foo<span class="punctuation token">:</span>            <span class="keyword token">undefined</span>
doSomething<span class="punctuation token">.</span>prototype<span class="punctuation token">.</span>prop<span class="punctuation token">:</span> <span class="keyword token">undefined</span>
doSomething<span class="punctuation token">.</span>prototype<span class="punctuation token">.</span>foo<span class="punctuation token">:</span>  bar</code></pre>

<h2 id="Differenti_modi_di_creare_oggetti_e_la_risultante_catena_di_prototype">Differenti modi di creare oggetti e la risultante catena di prototype</h2>

<h3 id="Oggetti_creati_con_i_costrutti_sintattici">Oggetti creati con i costrutti sintattici</h3>

<pre class="brush: js">var o = {a: 1};

// L'oggetto o appena creato ha Object.prototype come proprio [[Prototype]]
// o non ha una propria property chamata 'hasOwnProperty'
// hasOwnProperty è una property propria di Object.prototype.
// Quindi o eredita hasOwnProperty da Object.prototype
// Object.prototype ha null come suo prototype.
// o ---&gt; Object.prototype ---&gt; null

var a = ["yo", "whadup", "?"];

// Arrays ereditato da Array.prototype
// (che metodi come indexOf, forEach, ecc.)
// La catena di prototype si presenta così:
// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null

function f(){
  return 2;
}

// Le funzioni ereditano da Function.prototype
// (che ha metodi come call, bind, ecc.)
// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null
</pre>

<h3 id="Con_un_constructor">Con un constructor</h3>

<p>Un "constructor" (costruttore) in JavaScript è semplicemente una funzione che è stata chiamata con  <a href="/en-US/docs/Web/JavaScript/Reference/Operators/new" title="new">l'operatore new</a>.</p>

<pre class="brush: js">function Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype = {
  addVertex: function(v){
    this.vertices.push(v);
  }
};

var g = new Graph();
// g è un oggetto con proprie properties 'vertices' ed 'edges'.
// g.[[Prototype]] è il valore di Graph.prototype quando viene eseguito new Graph().
</pre>

<h3 id="Con_Object.create">Con <code>Object.create</code></h3>

<p>ECMAScript 5 introduce un nuovo metodo: {{jsxref("Object.create()")}}. Chiamando questo metodo viene creato un nuovo oggetto. Il prototype di questo oggetto è il primo argomento della funzione:</p>

<pre class="brush: js">var a = {a: 1};
// a ---&gt; Object.prototype ---&gt; null

var b = Object.create(a);
// b ---&gt; a ---&gt; Object.prototype ---&gt; null
console.log(b.a); // 1 (ereditato)

var c = Object.create(b);
// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null

var d = Object.create(null);
// d ---&gt; null
console.log(d.hasOwnProperty);
// undefined, perché d non eredita da Object.prototype
</pre>

<div>
<h3 id="Operatore_delete_con_Object.create_e_loperatore_new">Operatore <code>delete</code> con <code>Object.create</code> e l'operatore  <code>new</code></h3>

<p>L'operazione di cancellazione di una proprietà mediante l'utilizzo dell'operatore <code>delete</code> permette di evidenziare l'ereditarietà prototipale di un oggetto creato attraverso <code>Object.create</code> e l'oggetto utilizzato da prototipo del nuovo oggetto creato:</p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="keyword token">var</span> a <span class="operator token">=</span> <span class="punctuation token">{</span>a<span class="punctuation token">:</span> <span class="number token">1</span><span class="punctuation token">}</span><span class="punctuation token">;</span>

<span class="keyword token">var</span> b <span class="operator token">=</span> Object<span class="punctuation token">.</span><span class="function token">create</span><span class="punctuation token">(</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span>

console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>a<span class="punctuation token">.</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// stampa 1 </span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>b<span class="punctuation token">.</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// stampa 1</span>
b<span class="punctuation token">.</span>a<span class="operator token">=</span><span class="number token">5</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>a<span class="punctuation token">.</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// stampa 1</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>b<span class="punctuation token">.</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// stampa 5</span>
<span class="keyword token">delete</span> b<span class="punctuation token">.</span>a<span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>a<span class="punctuation token">.</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// stampa 1</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>b<span class="punctuation token">.</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// stampa 1(b.a di valore 5 è cancellato ma viene visualizzato il valore contenuto nella prototype chain )</span>
<span class="keyword token">delete</span> a<span class="punctuation token">.</span>a<span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>a<span class="punctuation token">.</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// stampa undefined</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>b<span class="punctuation token">.</span>a<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// stampa undefined</span></code></pre>

<p>L'operatore <code>new</code> ha una prototype chain più corta in questo esempio:</p>

<pre class="brush: js line-numbers language-js"><code class="language-js"><span class="keyword token">function</span> <span class="function token">Graph</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="punctuation token">{</span>
  <span class="keyword token">this</span><span class="punctuation token">.</span>vertices <span class="operator token">=</span> <span class="punctuation token">[</span><span class="number token">4</span><span class="punctuation token">,</span><span class="number token">4</span><span class="punctuation token">]</span><span class="punctuation token">;</span>
<span class="punctuation token">}</span>

<span class="keyword token">var</span> g <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">Graph</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>g<span class="punctuation token">.</span>vertices<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// print [4,4]</span>
g<span class="punctuation token">.</span>vertices <span class="operator token">=</span> <span class="number token">25</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>g<span class="punctuation token">.</span>vertices<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// print 25</span>
<span class="keyword token">delete</span> g<span class="punctuation token">.</span>vertices<span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>g<span class="punctuation token">.</span>vertices<span class="punctuation token">)</span><span class="punctuation token">;</span> <span class="comment token">// print undefined</span></code></pre>

<h3 id="Con_la_parola_chiave_class">Con la parola chiave <code>class</code></h3>

<p>ECMAScript 2015 introduce un nuovo gruppo di parole chiave per implementare le <a href="/en-US/docs/Web/JavaScript/Reference/Classes">classi</a>. Sebbene questi costrutti assomiglino a quelli familiari agli sviluppatori di linguaggi basati su classi, in realtà non cambia molto. JavaScript continua ad essere basato su prototype. Le nuove parole chiave includono {{jsxref("Statements/class", "class")}}, {{jsxref("Classes/constructor", "constructor")}}, {{jsxref("Classes/static", "static")}}, {{jsxref("Classes/extends", "extends")}}, e {{jsxref("Operators/super", "super")}}.</p>

<pre class="brush: js">"use strict";

class Polygon {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

class Square extends Polygon {
  constructor(sideLength) {
    super(sideLength, sideLength);
  }
  get area() {
    return this.height * this.width;
  }
  set sideLength(newLength) {
    this.height = newLength;
    this.width = newLength;
  }
}

var square = new Square(2);
</pre>

<h3 id="Prestazioni">Prestazioni</h3>

<p>Il tempo impiegato per la ricerca di proprietá che sono in alto nella catena dei prototype può avere un impatto negativo sulle prestazioni e questo può essere significativo in codice in cui le prestazioni sono critiche. Inoltre il tentativo di accedere a properties non esistenti esamina sempre la catena completa dei prototype.</p>

<p>In più, quando si itera sulle proprietà di un oggetto, <strong>tutte</strong> le properties enumerabili che si trovano nella sua catena dei prototype verranno enumerate. Per controllare se un oggetto ha una property definita da <em>se stesso</em> e non da qualche parte nella catena di prototype<span id="result_box" lang="it"><span>,</span> <span class="hps">è necessario</span> <span class="hps">utilizzare</span> <span class="hps">il metodo</span> </span><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" title="/ru/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>hasOwnProperty</code></a><span lang="it"> che<span class="hps"> tutti gli oggetti</span> <span class="hps">ereditano da</span> <code><span class="hps">Object.prototype</span></code><span>. Per fornire un esempio concreto, analizziamo il codice del grafo visto in precedenza per illustrare quanto detto:</span></span></p>

<pre class="brush: js line-numbers language-js"><code class="language-js">console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>g<span class="punctuation token">.</span><span class="function token">hasOwnProperty</span><span class="punctuation token">(</span><span class="string token">'vertices'</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="comment token">// true</span>

console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>g<span class="punctuation token">.</span><span class="function token">hasOwnProperty</span><span class="punctuation token">(</span><span class="string token">'nope'</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="comment token">// false</span>

console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>g<span class="punctuation token">.</span><span class="function token">hasOwnProperty</span><span class="punctuation token">(</span><span class="string token">'addVertex'</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="comment token">// false</span>

console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>g<span class="punctuation token">.</span>__proto__<span class="punctuation token">.</span><span class="function token">hasOwnProperty</span><span class="punctuation token">(</span><span class="string token">'addVertex'</span><span class="punctuation token">)</span><span class="punctuation token">)</span><span class="punctuation token">;</span>
<span class="comment token">// true</span></code></pre>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" title="/ru/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>hasOwnProperty</code></a> è la sola cosa in JavaScript che opera con le properties <strong>senza</strong> traversare la catena dei prototype.</p>

<p>Nota: <strong>non</strong> è sufficiente controllare se una property è <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" title="/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>. La property potrebbe essere presente comunque e questo capita se il suo valore è stato assegnato <code>undefined.</code></p>
</div>

<h3 id="Cattiva_pratica_Estensione_di_prototypes_nativi">Cattiva pratica: Estensione di prototypes nativi</h3>

<p>Una caratteristica mancante che viene spesso utilizzata è quella di estendere <code>Object.prototype</code> o uno degli altri prototype built-in.</p>

<p>Questa tecnica viene chiamata "monkey patching" e rompe l'<em>incapsulazione</em>. Nonostante sia utilizzata da frameworks popolari come ad esempio Prototype.js, non esistono comunque buone ragioni per appesantire i tipi built-in con funzionalità <em>non-standard</em> aggiuntive.</p>

<p>La <strong>sola</strong> buona ragione per estendere un prototype built-in è per dotare vecchie versioni di JavaScript con funzionalità presenti in quelle nuove; per esempio <code>Array.forEach</code>, etc.</p>

<h3 id="Sommario_dei_metodi_per_lestensione_della_prototype_chain">Sommario dei metodi per l'estensione della prototype chain</h3>

<p>Vengono presentati i 4 i metodi per l'estensione della prototype chain con i loro pro e i loro contro. Tutti gli esempi elencati di seguito creano esattamente lo stesso oggetto <code>inst</code> (ottenendo così gli stessi risultati nella console), ma in modi diversi allo scopo illustrativo.</p>

<table class="standard-table" style="text-align: top;">
 <tbody>
  <tr>
   <td style="width: 1%;">Nome</td>
   <td style="vertical-align: top; width: 1%;">Esempi</td>
   <td style="vertical-align: top;">Pro</td>
   <td style="vertical-align: top; width: 60%;">Contro</td>
  </tr>
  <tr>
   <td>Inizializzazione con New</td>
   <td style="vertical-align: top;">
    <pre class="brush: js line-numbers language-js">
<code class="language-js"><span class="keyword token">function</span> <span class="function token">foo</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
foo<span class="punctuation token">.</span>prototype <span class="operator token">=</span> <span class="punctuation token">{</span>
  foo_prop<span class="punctuation token">:</span> <span class="string token">"foo val"</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span>
<span class="keyword token">function</span> <span class="function token">bar</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
<span class="keyword token">var</span> proto <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">foo</span><span class="punctuation token">;</span>
proto<span class="punctuation token">.</span>bar_prop <span class="operator token">=</span> <span class="string token">"bar val"</span><span class="punctuation token">;</span>
bar<span class="punctuation token">.</span>prototype <span class="operator token">=</span> proto<span class="punctuation token">;</span>
<span class="keyword token">var</span> inst <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">bar</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>foo_prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>bar_prop<span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>
   </td>
   <td style="vertical-align: top;">Supportato in ogni browser immaginabile (il supporto va fino a IE 5.5!). Inoltre, è molto veloce, molto standard e molto JIST-optimizable.</td>
   <td style="vertical-align: top;">Per poter utilizzare questo metodo, la funzione in questione deve essere inizializzata. Durante questa inizializzazione, il costruttore può memorizzare informazioni uniche che devono essere generate per ogni oggetto. Tuttavia, queste informazioni uniche verrebbero generate una sola volta, il che potrebbe portare a problemi. Inoltre, l'inizializzazione del costruttore può inserire metodi indesiderati sull'oggetto. Tuttavia, queste criticità non sono generalmente problemi (in effetti, di solito sono utili) se si tratta di codice proprio e si sa cosa fa cosa e dove.</td>
  </tr>
  <tr>
   <td>Object.create</td>
   <td style="vertical-align: top;">
    <pre class="brush: js line-numbers language-js">
<code class="language-js"><span class="keyword token">function</span> <span class="function token">foo</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
foo<span class="punctuation token">.</span>prototype <span class="operator token">=</span> <span class="punctuation token">{</span>
  foo_prop<span class="punctuation token">:</span> <span class="string token">"foo val"</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span>
<span class="keyword token">function</span> <span class="function token">bar</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
<span class="keyword token">var</span> proto <span class="operator token">=</span> Object<span class="punctuation token">.</span><span class="function token">create</span><span class="punctuation token">(</span>
  foo<span class="punctuation token">.</span>prototype
<span class="punctuation token">)</span><span class="punctuation token">;</span>
proto<span class="punctuation token">.</span>bar_prop <span class="operator token">=</span> <span class="string token">"bar val"</span><span class="punctuation token">;</span>
bar<span class="punctuation token">.</span>prototype <span class="operator token">=</span> proto<span class="punctuation token">;</span>
<span class="keyword token">var</span> inst <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">bar</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>foo_prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>bar_prop<span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>

    <pre class="brush: js line-numbers language-js">
<code class="language-js"><span class="keyword token">function</span> <span class="function token">foo</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
foo<span class="punctuation token">.</span>prototype <span class="operator token">=</span> <span class="punctuation token">{</span>
  foo_prop<span class="punctuation token">:</span> <span class="string token">"foo val"</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span>
<span class="keyword token">function</span> <span class="function token">bar</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
<span class="keyword token">var</span> proto <span class="operator token">=</span> Object<span class="punctuation token">.</span><span class="function token">create</span><span class="punctuation token">(</span>
  foo<span class="punctuation token">.</span>prototype<span class="punctuation token">,</span>
  <span class="punctuation token">{</span>
    bar_prop<span class="punctuation token">:</span> <span class="punctuation token">{</span>
      value<span class="punctuation token">:</span> <span class="string token">"bar val"</span>
    <span class="punctuation token">}</span>
  <span class="punctuation token">}</span>
<span class="punctuation token">)</span><span class="punctuation token">;</span>
bar<span class="punctuation token">.</span>prototype <span class="operator token">=</span> proto<span class="punctuation token">;</span>
<span class="keyword token">var</span> inst <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">bar</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>foo_prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>bar_prop<span class="punctuation token">)</span></code></pre>
   </td>
   <td style="vertical-align: top;">Supporto in tutti i browser in uso oggi, che sono tutti browser non microsoft più IE9 e successivi. Permette l'impostazione diretta di <code>__proto__</code> in modo che il browser possa ottimizzare meglio l'oggetto. Permette anche la creazione di oggetti senza prototype tramite <code>Object.create(null)</code>.</td>
   <td style="vertical-align: top;">Non supportato in IE8 e precedenti. Tuttavia, poiché Microsoft ha interrotto il supporto esteso per i sistemi che utilizzano questi vecchi browser, questo non dovrebbe essere un problema per la maggior parte delle applicazioni. Inoltre, l'inizializzazione lenta dell'oggetto può essere un buco nero per prestazioni se si usa il secondo argomento, perché ogni proprietà del descrittore dell'oggetto ha un proprio oggetto descrittore separato. Quando si ha a che fare con centinaia di migliaia di descrittori di oggetti sotto forma di oggetto, può sorgere un serio problema di ritardo.</td>
  </tr>
  <tr>
   <td>
    <p>Object.setPrototypeOf</p>
   </td>
   <td style="vertical-align: top;">
    <pre class="brush: js line-numbers language-js">
<code class="language-js"><span class="keyword token">function</span> <span class="function token">foo</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
foo<span class="punctuation token">.</span>prototype <span class="operator token">=</span> <span class="punctuation token">{</span>
  foo_prop<span class="punctuation token">:</span> <span class="string token">"foo val"</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span>
<span class="keyword token">function</span> <span class="function token">bar</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
<span class="keyword token">var</span> proto <span class="operator token">=</span> <span class="punctuation token">{</span>
  bar_prop<span class="punctuation token">:</span> <span class="string token">"bar val"</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span>
Object<span class="punctuation token">.</span><span class="function token">setPrototypeOf</span><span class="punctuation token">(</span>
  proto<span class="punctuation token">,</span> foo<span class="punctuation token">.</span>prototype
<span class="punctuation token">)</span><span class="punctuation token">;</span>
bar<span class="punctuation token">.</span>prototype <span class="operator token">=</span> proto<span class="punctuation token">;</span>
<span class="keyword token">var</span> inst <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">bar</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>foo_prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>bar_prop<span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>

    <pre class="brush: js line-numbers language-js">
<code class="language-js"><span class="keyword token">function</span> <span class="function token">foo</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
foo<span class="punctuation token">.</span>prototype <span class="operator token">=</span> <span class="punctuation token">{</span>
  foo_prop<span class="punctuation token">:</span> <span class="string token">"foo val"</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span>
<span class="keyword token">function</span> <span class="function token">bar</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
<span class="keyword token">var</span> proto<span class="punctuation token">;</span>
proto<span class="operator token">=</span>Object<span class="punctuation token">.</span><span class="function token">setPrototypeOf</span><span class="punctuation token">(</span>
  <span class="punctuation token">{</span> bar_prop<span class="punctuation token">:</span> <span class="string token">"bar val"</span> <span class="punctuation token">}</span><span class="punctuation token">,</span>
  foo<span class="punctuation token">.</span>prototype
<span class="punctuation token">)</span><span class="punctuation token">;</span>
bar<span class="punctuation token">.</span>prototype <span class="operator token">=</span> proto<span class="punctuation token">;</span>
<span class="keyword token">var</span> inst <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">bar</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>foo_prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>bar_prop<span class="punctuation token">)</span></code></pre>
   </td>
   <td style="vertical-align: top;">Supporto in tutti i browser in uso oggi, che sono tutti browser non microsoft più IE9 e successivi. Permette la manipolazione dinamica dei prototype degli oggetti e può anche forzare un prototype su un oggetto senza prototype creato con <code>Object.create(null)</code>.</td>
   <td style="vertical-align: top;">Dovrebbe essere deprecato e poco performante. Far girare velocemente il vostro Javascript è completamente fuori questione se pensate di usarlo nel codice di produzione finale perché molti browser ottimizzano il prototype e cercano di indovinare la posizione del metodo nella memoria quando si chiama un'istanza in anticipo, ma impostando il prototype dinamicamente si interrompono tutte queste ottimizzazioni e si può anche forzare alcuni browser a ricompilare per la deottimizzazione il vostro codice solo per farlo funzionare secondo le specifiche. Non è supportato in IE8 e successivi.</td>
  </tr>
  <tr>
   <td>__proto__</td>
   <td style="vertical-align: top;">
    <pre class="brush: js line-numbers language-js">
<code class="language-js"><span class="keyword token">function</span> <span class="function token">foo</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
foo<span class="punctuation token">.</span>prototype <span class="operator token">=</span> <span class="punctuation token">{</span>
  foo_prop<span class="punctuation token">:</span> <span class="string token">"foo val"</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span>
<span class="keyword token">function</span> <span class="function token">bar</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">{</span><span class="punctuation token">}</span>
<span class="keyword token">var</span> proto <span class="operator token">=</span> <span class="punctuation token">{</span>
  bar_prop<span class="punctuation token">:</span> <span class="string token">"bar val"</span><span class="punctuation token">,</span>
  __proto__<span class="punctuation token">:</span> foo<span class="punctuation token">.</span>prototype
<span class="punctuation token">}</span><span class="punctuation token">;</span>
bar<span class="punctuation token">.</span>prototype <span class="operator token">=</span> proto<span class="punctuation token">;</span>
<span class="keyword token">var</span> inst <span class="operator token">=</span> <span class="keyword token">new</span> <span class="class-name token">bar</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>foo_prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>bar_prop<span class="punctuation token">)</span><span class="punctuation token">;</span></code></pre>

    <pre class="brush: js line-numbers language-js">
<code class="language-js"><span class="keyword token">var</span> inst <span class="operator token">=</span> <span class="punctuation token">{</span>
  __proto__<span class="punctuation token">:</span> <span class="punctuation token">{</span>
    bar_prop<span class="punctuation token">:</span> <span class="string token">"bar val"</span><span class="punctuation token">,</span>
    __proto__<span class="punctuation token">:</span> <span class="punctuation token">{</span>
      foo_prop<span class="punctuation token">:</span> <span class="string token">"foo val"</span><span class="punctuation token">,</span>
      __proto__<span class="punctuation token">:</span> <span class="class-name token">Object</span><span class="punctuation token">.</span>prototype
    <span class="punctuation token">}</span>
  <span class="punctuation token">}</span>
<span class="punctuation token">}</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>foo_prop<span class="punctuation token">)</span><span class="punctuation token">;</span>
console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>inst<span class="punctuation token">.</span>bar_prop<span class="punctuation token">)</span></code></pre>
   </td>
   <td style="vertical-align: top;">Compatibilità con tutti i browser in uso oggi, che sono tutti browser non microsoft più IE11 e superiori. L'impostazione di <code>__proto__</code> su qualcosa che non è un oggetto fallisce silenziosamente. Non lancia un'eccezione.</td>
   <td style="vertical-align: top;">Totalmente deprecato e non performante. Far girare velocemente il vostro codice Javascript è completamente fuori questione se pensate di usarlo nel codice di produzione finale perché molti browser ottimizzano il prototype e cercano di indovinare la posizione del metodo nella memoria quando si chiama un'istanza in anticipo, ma impostando il prototipo dinamicamente si interrompono tutte queste ottimizzazioni e si può anche forzare alcuni browser a ricompilare per la deottimizzazione del vostro codice solo per farlo funzionare secondo le specifiche. Non è supportato in IE10 e successivi.</td>
  </tr>
 </tbody>
</table>

<h2 id="prototype_e_Object.getPrototypeOf"><code>prototype</code> e <code>Object.getPrototypeOf</code></h2>

<p>JavaScript confonde un po' gli sviluppatori che provengono da Java o C++, essendo completamente dinamico, valutato tutto a runtime e non avendo classi in senso stretto. Sono tutte istanze di oggetti. Persino le "classi" che simuliamo sono semplicemente degli oggetti funzione.</p>

<p><span lang="it"><span class="hps">Probabilmente hai già</span> <span class="hps">notato</span> <span class="hps">che la nostra</span> <span class="hps">funzione A</span> <span class="hps">ha una propery</span> <span class="hps">speciale chiamata</span> <span class="hps">prototype.</span> <span class="hps">Questa speciale property</span> <span class="hps">funziona con</span> <span class="hps">l'operatore new</span> di <span class="hps">JavaScript</span><span>.</span> <span class="hps">Il riferimento</span> <span class="hps">all'oggetto prototype</span> <span class="hps">viene copiato nella property</span><span class="atn hps"> [</span><span class="atn">[</span><span>Prototype</span><span>]</span><span>] interna alla</span><span class="hps"> nuova istanza</span><span>.</span></span><span lang="it"> <span class="hps">Ad esempio, quando</span> <span class="hps">si fa</span> <span class="hps">var</span> <span class="hps">a1</span> <span class="hps">= new</span> <span class="atn hps">A(</span><span>)</span><span>,</span> <span class="atn hps">JavaScript (</span><span>dopo aver creato</span> <span class="hps">l'oggetto</span> <span class="hps">in memoria</span> <span class="hps">e</span> <span class="hps">prima di eseguire</span> <span class="hps">la funzione</span> <span class="atn hps">A(</span><span>) con this</span> <span class="hps">definito</span> <span class="hps">ad esso</span><span>) imposta</span> <span class="hps">a1</span><span>.</span> <span class="atn hps">[</span><span class="atn">[</span><span>Prototype</span><span>]</span><span>]</span> <span class="hps">=</span> <span class="hps">A.prototype</span><span>.</span></span><span lang="it"> <span class="hps">Quando si</span> <span class="hps">accede</span> <span class="hps">poi</span> alle properties<span class="hps"> dell'istanza</span><span>, </span><span class="hps">JavaScript</span></span> prima controlla se esiste nell'oggetto direttamente e se non c'è guarda in <span lang="it"><span class="atn hps">[</span><span class="atn">[</span><span>Prototype</span><span>]]. Questo significa che tutto ciò che viene definito in prototype viene effettivamente condiviso con tutte le istanze</span></span> ed è possibile anche in seguito cambiare parti del prototype facendo comparire i cambiamenti in tutte le istanze esistenti, se è questo che si desidera.</p>

<p>Se, nell'esempio soprastante, si fa <code>var a1 = new A(); var a2 = new A();</code> <code>a1.doSomething</code> farà riferimento a <code>Object.getPrototypeOf(a1).doSomething</code>, che è il medesimo di <code>A.prototype.doSomething che è stato definito, perciò </code><code>Object.getPrototypeOf(a1).doSomething == Object.getPrototypeOf(a2).doSomething == A.prototype.doSomething</code>.</p>

<p>In breve, prototype è per i tipi, mentre <code>Object.getPrototypeOf() da lo stesso risultato per le istanze.</code></p>

<p><code>[[Prototype]]</code> viene esaminato <em>ricorsivamente</em>, ad esempio <code>a1.doSomething</code>, <code>Object.getPrototypeOf(a1).doSomething</code>, <code>Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething</code> ecc., finché viene trovato oppure<code> Object.getPrototypeOf </code>restituisce null.</p>

<p>Così, quando si chiama</p>

<pre class="brush: js">var o = new Foo();</pre>

<p>JavaScript in realtà esegue</p>

<pre class="brush: js">var o = new Object();
o.[[Prototype]] = Foo.prototype;
Foo.call(o);</pre>

<p>(o qualcosa di simile) e quando successivamente si esegue</p>

<pre class="brush: js">o.someProp;</pre>

<p>controlla se o ha pa property someProp. Se non c'è controlla <code>Object.getPrototypeOf(o).someProp</code> e se non c'è ancora controlla <code>Object.getPrototypeOf(Object.getPrototypeOf(o)).someProp e via di seguito.</code></p>

<div>
<h2 id="In_conclusione">In conclusione</h2>

<p>È <strong>essenziale</strong> capire il funzionamento dell'ereditarietà basata sul modello dei prototype prima di scrivere codice complesso che ne fa uso. Bisogna anche fare attenzione alla lunghezza della catena di prototype nel proprio codice ed accorciarla in caso di necessità per evitare possibili problemi di prestazioni. Infine, i prototype nativi non dovrebbero <strong>mai</strong> venire estesi per evitare problemi di compatibilità con nuove funzionalità JavaScript che potrebbero essere introdotte.</p>
</div>
