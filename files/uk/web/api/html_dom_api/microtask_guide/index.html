---
title: Використання мікрозадач у JavaScript за допомогою queueMicrotask()
slug: Web/API/HTML_DOM_API/Microtask_guide
tags:
  - API
  - JavaScript
  - ServiceWorker
  - SharedWorker
  - Window
  - Worker
  - queueMicrotask
  - Довідник
  - асинхронний
  - мікрозадача
  - пакет
  - черга
translation_of: Web/API/HTML_DOM_API/Microtask_guide
---
<p>{{APIRef("HTML DOM")}}</p>

<p><span class="seoSummary"><strong>Мікрозадача</strong> - це коротка функція, яка виконується після того, як функція чи програма, яка її створила, завершується, <em>та</em> тільки якщо стек виконання JavaScript порожній, але перед поверненням контролю до циклу подій {{Glossary("user agent", "користувацького агента")}} для керування середовищем виконання скрипта.</span> Даний цикл подій може бути або головним циклом подій веб-переглядача, або циклом подій, що керує <a href="/uk/docs/Web/API/Web_Workers_API">веб-виконавцем</a>. Це дозволяє даній функції виконуватись без ризику втрутитись у виконання іншого скрипта, в той же час гарантує, що мікрозадача виконається до того, як користувацький агент матиме змогу відреагувати на дії, виконані цією мікрозадачею.</p>

<p><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise">Проміси</a> JavaScript та <a href="/uk/docs/Web/API/Mutation_Observer_API">Mutation Observer API</a> використовують чергу мікрозадач для виконання своїх зворотніх викликів, але бувають інші випадки, коли здатність відкласти роботу до завершення поточного проходу циклу подій може бути корисна. Щоб дозволити стороннім бібліотекам, фреймворкам та поліфілам використовувати мікрозадачі, метод {{domxref("WindowOrWorkerGlobalScope.queueMicrotask", "queueMicrotask()")}} доступний у інтерфейсах {{domxref("Window")}} та {{domxref("Worker")}} через домішку {{domxref("WindowOrWorkerGlobalScope")}}.</p>

<h2 id="Задачі_та_мікрозадачі">Задачі та мікрозадачі</h2>

<p>Щоб належно обговорювати мікрозадачі, насамперед, корисно знати, що таке задача JavaScript та чим мікрозадачі відрізняються від задач. Це швидке, спрощене пояснення, але якщо вам потрібно більше подробиць, ви можете їх дізнатись у статті <a href="/uk/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">В подробицях: мікрозадачі та середовище виконання JavaScript</a>.</p>

<h3 id="Задачі">Задачі</h3>

<p><strong>Задача</strong> - це будь-який код JavaScript, що запланований до запуску стандартними механізмами, такими як початковий запуск програми, запуск зворотного виклику для події, або запуск таймера чи інтервалу. Всі вони розташовуються у <strong>черзі задач</strong>.</p>

<p>Задачі додаються до черги задач, коли:</p>

<ul>
 <li>Безпосередньо виконується нова програма чи підпрограма JavaScript (наприклад, з консолі чи запуском коду у елементі {{HTMLElement("script")}}).</li>
 <li>Спрацьовує подія, додаючи функцію зворотного виклику події до черги задач.</li>
 <li>Доходить черга таймера чи інтервалу, створеного методом {{domxref("WindowOrWorkerGlobalScope.setTimeout", "setTimeout()")}} чи {{domxref("WindowOrWorkerGlobalScope.setInterval", "setInterval()")}}, що спричиняє додавання відповідного зворотного виклику до черги задач.</li>
</ul>

<p>Цикл подій, що керує вашим кодом, обробляє ці задачі одна за одною, в тому порядку, в якому вони були додані у чергу. Лише ті задачі, які <em>вже знаходились у черзі задач</em>, коли почався прохід циклу подій, будуть виконані протягом поточної ітерації. Решті доведеться зачекати наступної ітерації.</p>

<h3 id="Мікрозадачі">Мікрозадачі</h3>

<p>Спершу різниця між мікрозадачами та задачами здається незначною. І вони дійсно схожі; і те, й інше - код JavaScript, який розміщується у черзі та запускається у належний час. Однак, в той час, як цикл подій запускає лише задачі, наявні у черзі на момент початку ітерації, одна за одною, з мікрозадачами він поводиться зовсім по-іншому.</p>

<p>Є дві ключові відмінності.</p>

<p>По-перше, кожен раз, коли задача завершується, цикл подій перевіряє, чи задача повертає контроль іншому коду JavaScript. Якщо ні, він запускає всі мікрозадачі з черги мікрозадач. Таким чином, черга мікрозадач обробляється багаторазово протягом однієї ітерації циклу подій, в тому числі після обробки подій та інших зворотних викликів.</p>

<p>По-друге, якщо мікрозадача додає інші мікрозадачі до черги, викликаючи метод {{domxref("WindowOrWorkerGlobalScope.queueMicrotask", "queueMicrotask()")}}, ці додані мікрозадачі <em>виконуються перед запуском наступної задачі</em>. Все тому, що цикл подій викликатиме мікрозадачі, доки у черзі не залишиться жодної, навіть якщо при цьому додаються нові.</p>

<div class="blockIndicator warning">
<p><strong>Застереження:</strong> Оскільки мікрозадачі можуть ставити у чергу інші мікрозадачі, а цикл подій продовжуватиме обробляти мікрозадачі, доки черга не спорожніє, існує реальний ризик спричинити нескінченну обробку мікрозадач циклом подій. Будьте обережні, додаючи мікрозадачі рекурсивно.</p>
</div>

<h2 id="Використання_мікрозадач">Використання мікрозадач</h2>

<p>Перед тим, як продовжити, важливо зазначити ще раз, що більшість програмістів нечасто використовують мікрозадачі, якщо взагалі використовують. Це вузькоспеціалізована функціональність сучасної JavaScript-розробки для переглядачів, що дозволяє вам запланувати виконання коду попереду чогось іншого у довгому списку речей, що чекають на виконання комп'ютером користувача. Зловживання цією можливістю призведе до проблем з продуктивністю.</p>

<h3 id="Додавання_мікрозадач_у_чергу">Додавання мікрозадач у чергу</h3>

<p>Таким чином, вам варто використовувати мікрозадачі лише тоді, коли немає іншого рішення, або при створенні фреймворків чи бібліотек, які мають використовувати мікрозадачі для створення функціональності, яку реалізують. Хоча раніше існували трюки, які дозволяли ставити мікрозадачі в чергу (наприклад, створення проміса, який негайно вирішується), введення методу {{domxref("WindowOrWorkerGlobalScope.queueMicrotask", "queueMicrotask()")}} додає стандартний спосіб створення мікрозадач безпечно та без допомоги трюків.</p>

<p>Введення методу <code>queueMicrotask()</code> дозволяє уникнути вивертів, що трапляються під час такого проникнення у чергу мікрозадач за допомогою промісів. Наприклад, при використанні промісів для створення мікрозадач, винятки, викинуті зворотним викликом, повідомляються як відхилені проміси, а не як стандартні винятки. Також, створення та знищення промісів потребує додаткових витрат як часу, так і пам'яті, цього уникає функція, яка належним чином ставить мікрозадачі у чергу.</p>

<p>Просто передайте {{jsxref("Function","функцію")}} JavaScript, яку треба викликати, коли контекст обробляє мікрозадачі, у метод <code>queueMicrotask()</code>, доступний у глобальному контексті, як визначено у інтерфейсі {{domxref("Window")}} або {{domxref("Worker")}}, в залежності від поточного контексту виконання.</p>

<pre class="brush: js">queueMicrotask(() =&gt; {
  /* тут код, який виконує мікрозадача */
});
</pre>

<p>Сама функція мікрозадачі не приймає параметрів та не повертає значення.</p>

<h3 id="Коли_використовувати_мікрозадачі">Коли використовувати мікрозадачі</h3>

<p>У цьому розділі ми розглянемо сценарії, в яких мікрозадачі є особливо корисними. Загалом, мова йде про отримання та перевірку результатів, або прибирання, після того, як головне тіло контексту виконання JavaScript завершується, але перед тим, як опрацьовуються будь-які обробники подій, таймери та інтервали, чи інші зворотні виклики.</p>

<p>Коли це корисно?</p>

<p>Головна причина використання мікрозадач проста: забезпечити послідовний порядок виконання задач, навіть коли результати чи дані доступні синхронно, одночасно знижуючи ризик помітних користувачу затримок у операціях.</p>

<h4 id="Забезпечення_порядку_виконання_при_використанні_промісів_в_умовних_конструкціях">Забезпечення порядку виконання при використанні промісів в умовних конструкціях</h4>

<p>Одна з ситуацій, в якій можуть використовуватись мікрозадачі - це забезпечення завжди послідовного порядку виконання у ситуації, коли проміси використовуються у одному блоці конструкції <code>if...else</code> (чи іншої умовної конструкції), але не в іншому блоці. Розглянемо наступний код:</p>

<pre class="brush: js">customElement.prototype.getData = url =&gt; {
  if (this.cache[url]) {
    this.data = this.cache[url];
    this.dispatchEvent(new Event("load"));
  } else {
    fetch(url).then(result =&gt; result.arrayBuffer()).then(data =&gt; {
      this.cache[url] = data;
      this.data = data;
      this.dispatchEvent(new Event("load"));
    });
  }
};</pre>

<p>Проблема тут полягає в тому, що, використовуючи задачу в одній гілці конструкції <code>if...else</code> (у випадку, коли зображення доступне з кешу), але маючи проміси у блоці <code>else</code>, ми отримуємо ситуацію, в якій порядок операцій може бути різним; наприклад, як показано нижче.</p>

<pre class="brush: js">element.addEventListener("load", () =&gt; console.log("Завантажені дані"));
console.log("Отримання даних...");
element.getData();
console.log("Дані отримано");
</pre>

<p>Виконання цього коду два рази підряд дає результати, наведені у таблиці:</p>

<table class="standard-table">
 <caption>Результати, коли дані не кешовані (зліва) та коли дані знайдені в кеші</caption>
 <thead>
  <tr>
   <th scope="col">Дані не кешовані</th>
   <th scope="col">Дані кешовані</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>
    <pre>
Отримання даних
Дані отримано
Завантажені дані
</pre>
   </td>
   <td>
    <pre>
Отримання даних
Завантажені дані
Дані отримано
</pre>
   </td>
  </tr>
 </tbody>
</table>

<p>Навіть гірше, іноді властивість елементів <code>data</code> буде встановлена, а іноді не буде, на той момент, коли цей код завершує виконання.</p>

<p>Ми можемо забезпечити послідовний порядок цих операцій використанням мікрозадачі у блоці <code>if</code>, щоб збалансувати два блоки:</p>

<pre class="brush: js">customElement.prototype.getData = url =&gt; {
  if (this.cache[url]) {
    queueMicrotask(() =&gt; {
      this.data = this.cache[url];
      this.dispatchEvent(new Event("load"));
    });
  } else {
    fetch(url).then(result =&gt; result.arrayBuffer()).then(data =&gt; {
      this.cache[url] = data;
      this.data = data;
      this.dispatchEvent(new Event("load"));
    });
  }
};</pre>

<p>Це збалансовує два блоки, бо тепер в обох ситуаціях встановлення значення <code>data</code> та запуск події <code>load</code> відбувається всередині мікрозадачі (за допомогою <code>queueMicrotask()</code> у блоці <code>if</code> та за допомогою промісів, що використовуються методом {{domxref("WindowOrWorkerGlobalScope.fetch", "fetch()")}}, у блоці <code>else</code>).</p>

<h4 id="Пакетне_виконання_операцій">Пакетне виконання операцій</h4>

<p>Ви також можете використати мікрозадачі, щоб зібрати множину запитів з різних джерел у єдиний пакет, уникаючи можливих затрат, пов'язаних з багатьма викликами задля виконання задач одного типу.</p>

<p>Фрагмент коду, наведений нижче, створює функцію, яка збирає множину повідомлень у масив, використовуючи мікрозадачу, щоб відправити їх як єдиний об'єкт по завершенні контексту.</p>

<pre class="brush: js">const messageQueue = [];

let sendMessage = message =&gt; {
  messageQueue.push(message);

  if (messageQueue.length === 1) {
    queueMicrotask(() =&gt; {
      const json = JSON.stringify(messageQueue);
      messageQueue.length = 0;
      fetch("url-of-receiver", json);
    });
  }
};
</pre>

<p>Коли викликається <code>sendMessage()</code>, вказане повідомлення спочатку додається у масив черги повідомлень. А далі відбувається цікаве.</p>

<p>Якщо повідомлення, яке ми додали до масиву, є першим, ми додаємо мікрозадачу, яка відправлятиме пакет. Мікрозадача виконається, як завжди, коли шлях виконання JavaScript сягне верхнього рівня, одразу перед зворотними викликами. Це означає, що будь-які подальші виклики <code>sendMessage()</code>, зроблені в цей час, додадуть свої повідомлення до черги повідомлень, але, завдяки перевірці довжини масиву перед додаванням мікрозадачі, нових мікрозадач у чергу не буде додано.</p>

<p>Коли запускається мікрозадача, то вона має масив, потенційно, багатьох повідомлень, які на неї очікують. Вона починається кодуванням його як JSON за допомогою методу {{jsxref("JSON.stringify()")}}. Після цього вміст масиву більше не потрібний, а отже, ми спорожнюємо масив <code>messageQueue</code>. Нарешті, ми використовуємо метод {{domxref("WindowOrWorkerGlobalScope.fetch", "fetch()")}}, щоб відправити рядок JSON на сервер.</p>

<p>Це дозволяє кожному виклику <code>sendMessage()</code>, зробленому під час тієї самої ітерації циклу подій, додавати свої повідомлення до тієї самої операції <code>fetch()</code>, без потенційних затримок трансмісії іншими задачами, такими як таймери та подібні.</p>

<p>Сервер отримає рядок JSON, далі, ймовірно, декодує його та обробить повідомлення, які знайде у отриманому масиві.</p>

<h2 id="Приклади">Приклади</h2>

<h3 id="Простий_приклад_мікрозадачі">Простий приклад мікрозадачі</h3>

<p>У цьому простому прикладі ми бачимо, що додавання мікрозадачі у чергу спричиняє запуск зворотного виклику мікрозадачі після того, як тіло цього скрипта верхнього рівня завершує виконання.</p>

<div class="hidden">
<h4 id="HTML">HTML</h4>

<pre class="brush: html">&lt;pre id="log"&gt;
&lt;/pre&gt;</pre>
</div>

<h4 id="JavaScript">JavaScript</h4>

<div class="hidden">
<p>Наведений нижче код використовується для логування результату.</p>

<pre class="brush: js">let logElem = document.getElementById("log");
let log = s =&gt; logElem.innerHTML += s + "&lt;br&gt;";</pre>
</div>

<p>У наступному коді ми бачимо виклик {{domxref("WindowOrWorkerGlobalScope.queueMicrotask", "queueMicrotask()")}}, що використовується для планування запуску мікрозадачі. Цей виклик оточують виклики <code>log()</code>, користувацької функції, яка просто виводить текст на екран.</p>

<pre class="brush: js">log("До розміщення мікрозадачі в черзі");
queueMicrotask(() =&gt; {
  log("Мікрозадача запустилась.")
});
log("Після розміщення мікрозадачі в черзі");</pre>

<h4 id="Результат">Результат</h4>

<p>{{EmbedLiveSample("Простий_приклад_мікрозадачі", 640, 80)}}</p>

<h3 id="Таймер_та_приклад_мікрозадачі">Таймер та приклад мікрозадачі</h3>

<p>У цьому прикладі встановлюється таймер для запуску через нуль мілісекунд (або "якомога швидше"). Це демонструє різницю між тим, що означає "якомога швидше" при плануванні нової задачі (наприклад, при використанні <code>setTimeout()</code>) у порівнянні з використанням мікрозадачі.</p>

<div class="hidden">
<h4 id="HTML_2">HTML</h4>

<pre class="brush: html">&lt;pre id="log"&gt;
&lt;/pre&gt;</pre>
</div>

<h4 id="JavaScript_2">JavaScript</h4>

<div class="hidden">
<p>Наведений нижче код використовується для логування результату.</p>

<pre class="brush: js">let logElem = document.getElementById("log");
let log = s =&gt; logElem.innerHTML += s + "&lt;br&gt;";</pre>
</div>

<p>У наступному коді ми бачимо виклик {{domxref("WindowOrWorkerGlobalScope.queueMicrotask", "queueMicrotask()")}}, який використовується для планування запуску мікрозадачі. Цей виклик розташований між викликами <code>log()</code>, користувацької функції, яка просто виводить текст на екран.</p>

<p>Наступний код встановлює таймер, який має запуститися через нуль мілісекунд, після чого додає у чергу мікрозадачу. Він оточений викликами <code>log()</code> для виводу додаткових повідомлень.</p>

<pre class="brush: js">let callback = () =&gt; log("Запустився звичайний зворотний виклик таймера");

let urgentCallback = () =&gt; log("*** О, ні! Запустився терміновий зворотний виклик!");

log("Початок головної програми");
setTimeout(callback, 0);
queueMicrotask(urgentCallback);
log("Кінець головної програми");</pre>

<h4 id="Результат_2">Результат</h4>

<p>{{EmbedLiveSample("Таймер_та_приклад_мікрозадачі", 640, 100)}}</p>

<p>Зауважте, що текст, який виводиться головною програмою, з'являється першим, далі текст, виведений мікрозадачею, а за ним текст зворотного виклику таймера. Все тому, що, коли задача, що керує виконанням головної програми, завершується, черга мікрозадач обробляється раніше черги задач, в якій розташований зворотний виклик таймера. Знання того, що задачі та мікрозадачі розташовуються у різних чергах, і те, що мікрозадачі виконуються першими, допомагає легше в цьому розібратись.</p>

<h3 id="Мікрозадача_з_функції">Мікрозадача з функції</h3>

<p>Цей приклад трохи розширює попередній додаванням функції, яка виконує певну роботу. Ця функція використовує <code>queueMicrotask()</code>, щоб додати мікрозадачу. Важливий момент, який варто з нього винести - мікрозадача не виконується, коли завершується функція, а тільки коли завершується головна програма.</p>

<div class="hidden">
<h4 id="HTML_3">HTML</h4>

<pre class="brush: html">&lt;pre id="log"&gt;
&lt;/pre&gt;</pre>
</div>

<h4 id="JavaScript_3">JavaScript</h4>

<div class="hidden">
<p>Наведений нижче код використовується для логування результату.</p>

<pre class="brush: js">let logElem = document.getElementById("log");
let log = s =&gt; logElem.innerHTML += s + "&lt;br&gt;";</pre>
</div>

<p>Код головної програми наступний. Функція <code>doWork()</code> викликає <code>queueMicrotask()</code>, але мікрозадача не запускається, доки вся програма не завершується, оскільки саме тоді завершується задача і не залишається нічого іншого у стеку виконання.</p>

<pre class="brush: js">let callback = () =&gt; log("Запустився звичайний зворотний виклик таймера");

let urgentCallback = () =&gt; log("*** О, ні! Запустився терміновий зворотний виклик!");

let doWork = () =&gt; {
  let result = 1;

  queueMicrotask(urgentCallback);

  for (let i=2; i&lt;=10; i++) {
    result *= i;
  }
  return result;
};

log("Початок головної програми");
setTimeout(callback, 0);
log(`10! дорівнює ${doWork()}`);
log("Кінець головної програми");</pre>

<h4 id="Результат_3">Результат</h4>

<p>{{EmbedLiveSample("Мікрозадача_з_функції", 640, 100)}}</p>

<h2 id="Див._також">Див. також</h2>

<ul>
 <li><a href="/uk/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">В подробицях: мікрозадачі та середовище виконання JavaScript</a></li>
 <li>{{domxref("WindowOrWorkerGlobalScope.queueMicrotask", "queueMicrotask()")}}</li>
 <li><a href="/en-US/docs/Learn/JavaScript/Asynchronous">Asynchronous JavaScript</a>
  <ul>
   <li><a href="/en-US/docs/Learn/JavaScript/Asynchronous/Concepts">General asynchronous programming concepts</a></li>
   <li><a href="/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">Introducing asynchronous JavaScript</a></li>
   <li><a href="/en-US/docs/Learn/JavaScript/Asynchronous/Timeouts_and_intervals">Cooperative asynchronous JavaScript: Timeouts and intervals</a></li>
   <li><a href="/en-US/docs/Learn/JavaScript/Asynchronous/Promises">Graceful asynchronous programming with Promises</a></li>
   <li><a href="/en-US/docs/Learn/JavaScript/Asynchronous/Choosing_the_right_approach">Choosing the right approach</a></li>
  </ul>
 </li>
</ul>
