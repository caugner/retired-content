---
title: Вирази та оператори
slug: Web/JavaScript/Guide/Вирази_та_оператори
tags:
  - JavaScript
  - Оператори
  - Посібник
  - вирази
translation_of: Web/JavaScript/Guide/Expressions_and_Operators
---
<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>

<p class="summary">Цей розділ описує вирази та оператори JavaScript, такі як присвоювання, порівняння, арифметичні оператори, бітові, логічні, рядкові, тернарний та інші.</p>

<p>Повний та детальний список операторів та виразів також доступний за <a href="/uk/docs/Web/JavaScript/Reference/Operators">посиланням</a>.</p>

<h2 id="Оператори">Оператори</h2>

<p>JavaScript має наступні типи операторів. Ця секція описує оператори, а також містить інформацію щодо їхніх пріоритетів.</p>

<ul>
 <li>{{ web.link("#Оператори_присвоєння", "Оператори присвоєння") }}</li>
 <li>{{ web.link("#Оператори_порівняння", "Оператори порівняння") }}</li>
 <li>{{ web.link("#Арифметичні_оператори", "Арифметичні оператори") }}</li>
 <li>{{ web.link("#Бітові_оператори", "Бiтові оператори") }}</li>
 <li>{{ web.link("#Логічні_оператори", "Логічні оператори") }}</li>
 <li>{{ web.link("#Рядкові_оператори", "Рядкові оператори") }}</li>
 <li>{{ web.link("#Умовний_тернарний_оператор", "Умовний (тернарний) оператор")}}</li>
 <li>{{ web.link("#Comma_operator", "Оператор кома")}}</li>
 <li>{{ web.link("#Унарні_оператори", "Унарні оператори")}}</li>
 <li>{{ web.link("#Оператори_відношення", "Оператори відношення")}}</li>
</ul>

<p>JavaScript має як <em>бінарні</em>, так і <em>унарні</em> оператори, а також один особливий тернарний оператор - умовний оператор. Бінарному оператору потрібні два операнди - один перед оператором, інший після оператора:</p>

<pre class="syntaxbox"><em>операнд1 </em><em>оператор</em> <em>операнд2</em>
</pre>

<p>Наприклад, <code>3+4</code> чи <code>x*y</code>.</p>

<p>Унарний оператор потребує лише одного операнду до чи після оператора:</p>

<pre class="syntaxbox"><em>оператор</em> <em>операнд</em>
</pre>

<p>чи</p>

<pre class="syntaxbox"><em>операнд оператор</em>
</pre>

<p>Наприклад, <code>x++</code> чи <code>++x</code>.</p>

<h3 id="Оператори_присвоєння">Оператори присвоєння</h3>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Оператор присвоєння</a> присвоює своєму лівому операнду значення на підставі значення правого операнда. Простим оператором присвоєння є оператор дорівнює (<code>=</code>), який присвоює значення свого правого операнда лівому операнду. Таким чином, <code>x = y</code> присвоює значення змінної <code>y</code> змінній <code>x</code>.</p>

<p>Також існують складені оператори присвоєння, які є скороченнями для операцій, перелічених у наступній таблиці:</p>

<table class="standard-table">
 <caption>Складені оператори присвоювання</caption>
 <thead>
  <tr>
   <th>Назва</th>
   <th>Оператор скороченого запису</th>
   <th>Значення</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння#Assignment">Присвоєння</a></td>
   <td><code>x = y</code></td>
   <td><code>x = y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Addition_assignment/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Присвоєння з додаванням</a></td>
   <td><code>x += y</code></td>
   <td><code>x = x + y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Subtraction_assignment/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Присвоєння з відніманням</a></td>
   <td><code>x -= y</code></td>
   <td><code>x = x - y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Multiplication_assignment/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Присвоєння з множенням</a></td>
   <td><code>x *= y</code></td>
   <td><code>x = x * y</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння#Division_assignment">Присвоєння з діленням</a></td>
   <td><code>x /= y</code></td>
   <td><code>x = x / y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Remainder_assignment/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Присвоєння остачі</a></td>
   <td><code>x %= y</code></td>
   <td><code>x = x % y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Exponentiation_assignment/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Присвоєння з піднесенням до степеня</a>{{experimental_inline}}</td>
   <td><code>x **= y</code></td>
   <td><code>x = x ** y</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння#Left_shift_assignment">Присвоєння з лівим зсувом</a></td>
   <td><code>x &lt;&lt;= y</code></td>
   <td><code>x = x &lt;&lt; y</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння#Right_shift_assignment">Присвоєння з правим зсувом</a></td>
   <td><code>x &gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Unsigned_right_shift_assignment/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Присвоєння з беззнаковим правим зсувом</a></td>
   <td><code>x &gt;&gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Bitwise_AND_assignment/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Присвоєння з побітовим І</a></td>
   <td><code>x &amp;= y</code></td>
   <td><code>x = x &amp; y</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння#Bitwise_XOR_assignment">Присвоєння з виключним побітовим АБО</a></td>
   <td><code>x ^= y</code></td>
   <td><code>x = x ^ y</code></td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators#Bitwise_OR_assignment/uk/docs/Web/JavaScript/Reference/Operators/Оператори_присвоєння">Присвоєння з побітовим АБО</a></td>
   <td><code>x |= y</code></td>
   <td><code>x = x | y</code></td>
  </tr>
 </tbody>
</table>

<h4 id="Деструктуризація">Деструктуризація</h4>

<p>Для більш складних присвоювань використовується синтаксис <a href="/uk/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">деструктуризації</a>. Це вираз JavaScript, який надає можливість витягувати дані з масивів та об'єктів, використовуючи синтаксис, що віддзеркалює конструкцію масивів та об'єктних літералів. </p>

<pre class="brush: js">var foo = ['один', 'два', 'три'];

// без деструктуризації
var one   = foo[0];
var two   = foo[1];
var three = foo[2];

// із деструктуризацією
var [one, two, three] = foo;
</pre>

<h3 id="Оператори_порівняння">Оператори порівняння</h3>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння">Оператор порівняння</a> порівнює свої операнди та повертає логічне значення, базуючись на істинності порівняння. Операнди можуть бути числовими, рядковими, логічними значеннями або об'єктами. Рядки порівнюються згідно стандартного лексикографічного порядку, з використанням значень Unicode. У більшості випадків, якщо два операнди не належать до одного типу, JavaScript намагається привести їх до належного для порівняння типу. Зазвичай це призводить до числового порівняння операндів. Єдиними винятками у конвертації типів під час порівняння є оператори <code>===</code> та <code>!==</code>, які виконують перевірку на строгу рівність та строгу нерівність. Ці оператори не намагаються перед перевіркою на рівність привести операнди до спільного типу. Наступна таблиця наводить оператори порівняння у контексті цього фрагменту коду:</p>

<pre class="brush: js">var var1 = 3;
var var2 = 4;
</pre>

<table class="standard-table">
 <caption>Оператори порівняння</caption>
 <thead>
  <tr>
   <th scope="col">Оператор</th>
   <th scope="col">Опис</th>
   <th scope="col">Приклади, які повертають true</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Рівність">Рівність</a> (<code>==</code>)</td>
   <td>Повертає <code>true</code>, якщо оператори рівні.</td>
   <td><code>3 == var1</code>
    <p><code>"3" == var1</code></p>
    <code>3 == '3'</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Нерівність_!">Нерівність</a> (<code>!=</code>)</td>
   <td>Повертає <code>true</code>, якщо оператори нерівні.</td>
   <td><code>var1 != 4<br>
    var2 != "3"</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Ідентичність_строга_рівність">Строга рівність</a> (<code>===</code>)</td>
   <td>Повертає <code>true</code> якщо оператори рівні та належать до одного типу. Дивіться також {{jsxref("Object.is")}} та <a href="/uk/docs/Web/JavaScript/Перевірка_на_рівність_та_однаковість">однаковість у JS</a>.</td>
   <td><code>3 === var1</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Неідентичність_строга_нерівність_!">Строга нерівність</a> (<code>!==</code>)</td>
   <td>Повертає <code>true</code>, якщо оператори належать до одного типу, але нерівні, або належать до різних типів.</td>
   <td><code>var1 !== "3"<br>
    3 !== '3'</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Більше_ніж_>">Більше ніж</a> (<code>&gt;</code>)</td>
   <td>Повертає <code>true</code>, якщо лівий операнд більший за правий.</td>
   <td><code>var2 &gt; var1<br>
    "12" &gt; 2</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Більше_чи_дорівнює_>">Більше чи дорівнює</a> (<code>&gt;=</code>)</td>
   <td>Повертає <code>true</code>, якщо значення лівого операнда більше або дорівнює значенню правого операнда.</td>
   <td><code>var2 &gt;= var1<br>
    var1 &gt;= 3</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Менше_ніж_&lt;">Менше ніж</a> (<code>&lt;</code>)</td>
   <td>Повертає <code>true</code>, якщо лівий операнд менший за правий.</td>
   <td><code>var1 &lt; var2<br>
    "2" &lt; 12</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Оператори_порівняння#Менше_чи_дорівнює_&lt;">Менше чи дорівнює</a> (<code>&lt;=</code>)</td>
   <td>Повертає <code>true</code>, якщо значення лівого операнда менше або дорівнює значенню правого операнда.</td>
   <td><code>var1 &lt;= var2<br>
    var2 &lt;= 5</code></td>
  </tr>
 </tbody>
</table>

<div class="note">
<p><strong>Заувага: </strong>(<strong>=&gt;</strong>) не оператор, а позначення для <a href="/uk/docs/Web/JavaScript/Reference/Functions/Стрілкові_функції">стрілкових функцій</a>.</p>
</div>

<h3 id="Арифметичні_оператори">Арифметичні оператори</h3>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators">Арифметичний оператор</a> приймає числові значення (літерали чи змінні) в якості операндів та повертає єдине числове значення. Стандартними арифметичними операторами є додавання (<code>+</code>), віднімання (<code>-</code>), множення (<code>*</code>) та ділення (<code>/</code>). Ці оператори працюють так само, як і в більшості інших мов програмування при використанні з числами з рухомою комою (зокрема, зауважте, що ділення на нуль повертає {{jsxref("Infinity")}}). Наприклад:</p>

<pre class="brush: js">1 / 2; // 0.5
1 / 2 == 1.0 / 2.0; // це дорівнює true
</pre>

<p>На додачу до стандартних арифметичних операцій (+, -, * /), JavaScript надає арифметичні операції, перечислені у наведеній нижче таблиці:</p>

<table class="fullwidth-table">
 <caption>Арифметичні оператори</caption>
 <thead>
  <tr>
   <th scope="col">Оператор</th>
   <th scope="col">Опис</th>
   <th scope="col">Приклад</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder">Остача</a> (<code>%</code>)</td>
   <td>Бінарний оператор. Повертає цілочисельну остачу від ділення двох операндів.</td>
   <td>12 % 5 повертає 2.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment">Інкремент</a> (<code>++</code>)</td>
   <td>Унарний оператор. Додає до операнда одиницю. Якщо використовується як префіксний оператор (<code>++x</code>), повертає значення операнда після додавання одиниці; якщо використовується як постфіксний оператор (<code>x++</code>), повертає значення операнда перед додаванням одиниці.</td>
   <td>Якщо <code>x</code> дорівнює 3, тоді <code>++x</code> присвоює <code>x</code> значення 4 та повертає 4, в той час, як <code>x++</code> повертає 3 і лише тоді присвоює <code>x</code> значення 4.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Decrement">Декремент</a> (<code>--</code>)</td>
   <td>Унарний оператор. Віднімає одиницю від свого операнда. Повернене значення аналогічне поверненому значенню оператора інкременту.</td>
   <td>Якщо <code>x</code> дорівнює 3, тоді <code>--x</code> присвоює <code>x</code> значення 2 та повертає 2, в той час, як <code>x--</code> повертає 3 і тільки тоді присвоює <code>x</code> значення 2.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_negation">Унарний мінус</a> (<code>-</code>)</td>
   <td>Унарний оператор. Повертає операнд з протилежним знаком.</td>
   <td>Якщо <code>x</code> дорівнює 3, то <code>-x</code> повертає -3.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Унарний_плюс">Унарний плюс</a> (<code>+</code>)</td>
   <td>Унарний оператор. Намагається перетворити операнд на число, якщо він не є числом.</td>
   <td><code>+"3"</code> повертає <code>3</code>.<br>
    <code>+true</code> повертає <code>1.</code></td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Exponentiation">Піднесення до степеня</a> (<code>**</code>) {{experimental_inline}}</td>
   <td>Підносить <code>основу степеня</code> до <code>показника</code> степеня, тобто, <code>основа<sup>показник</sup></code></td>
   <td><code>2 ** 3</code> повертає <code>8</code>.<br>
    <code>10 ** -1</code> повертає <code>0.1</code>.</td>
  </tr>
 </tbody>
</table>

<h3 id="Бітові_оператори">Бітові оператори</h3>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">Бітовий оператор</a> опрацьовує свої операнди як послідовність 32-х бітів (нулів та одиниць), а не як десяткові, шістнадцяткові або вісімкові числа. Наприклад, десяткове число дев'ять має бітове представлення 1001. Бітові оператори виконують операції над цими бітовими представленнями, але повертають стандартні числові значення JavaScript.</p>

<p>Наступна таблиця наводить перелік бітових операторів JavaScript.</p>

<table class="standard-table">
 <caption>Бітові оператори</caption>
 <thead>
  <tr>
   <th scope="col">Оператор</th>
   <th scope="col">Застосування</th>
   <th scope="col">Опис</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Побітове_І">Побітове І (AND)</a></td>
   <td><code>a &amp; b</code></td>
   <td>Повертає одиницю на кожній позиції, де відповідні біти обох операндів дорівнюють одиницям.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Побітове_АБО">Побітове АБО (OR)</a></td>
   <td><code>a | b</code></td>
   <td>Повертає нуль на кожній позиції, де відповідні біти обох операндів дорівнюють нулям.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Виключне_побітове_АБО">Виключне побітове АБО (XOR)</a></td>
   <td><code>a ^ b</code></td>
   <td>Повертає нуль на кожній позиції, де відповідні біти однакові.<br>
    [Повертає один на кожній позиції, де відповідні біти мають різні значення.]</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Побітове_НЕ">Побітове НЕ (NOT)</a></td>
   <td><code>~ a</code></td>
   <td>Виконує інверсію бітів операнду.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#&lt;&lt;_Лівий_зсув">Лівий зсув</a></td>
   <td><code>a &lt;&lt; b</code></td>
   <td>Зсуває <code>a</code> у двійковому представленні на <code>b</code> бітів ліворуч, заповнюючи позиції справа нулями.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#>>_Правий_зсув_з_розширенням_знаку">Правий зсув з розширенням знаку</a></td>
   <td><code>a &gt;&gt; b</code></td>
   <td>Зсуває <code>a</code> у двійковому представленні на <code>b</code> бітів праворуч, відкидаючи зсунуті біти.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#>>>_Правий_зсув_із_заповненням_нулями">Правий зсув із заповненням нулями</a></td>
   <td><code>a &gt;&gt;&gt; b</code></td>
   <td>Зсуває <code>a</code> у двійковому представленні на <code>b</code> бітів праворуч, відкидаючи зсунуті біти та заповнюючи позиції зліва нулями.</td>
  </tr>
 </tbody>
</table>

<h4 id="Bitwise_Logical_Operators" name="Bitwise_Logical_Operators">Побітові логічні оператори</h4>

<p>Концептуально побітові логічні оператори працюють наступним чином:</p>

<ul>
 <li>Операнди перетворюються на 32-бітні цілі числа та виражаються послідовністю бітів (нулів та одиниць). Числа, що мають більше 32 бітів, втрачають свої старші біти. Наприклад, наступне ціле число, що має більше 32 бітів, буде перетворено на 32-бітне ціле число:
  <pre>До:     11100110111110100000000000000110000000000001
Після:              10100000000000000110000000000001</pre>
 </li>
 <li>Кожен біт першого операнду ставиться у пару до відповідного біту другого операнду: перший біт до першого біту, другий біт до другого, і так далі.</li>
 <li>Оператор застосовується до кожної пари бітів, а результат будується побітово.</li>
</ul>

<p>Наприклад, бінарним представленням числа дев'ять є 1001, а бінарним представленням п'ятнадцяти є 1111. Отже, коли бітові оператори застосовуються до цих величин, результати будуть наступні:</p>

<table class="standard-table">
 <caption>Приклади бітових операторів</caption>
 <thead>
  <tr>
   <th scope="col">Вираз</th>
   <th scope="col">Результат</th>
   <th scope="col">Двійковий опис</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>15 &amp; 9</code></td>
   <td><code>9</code></td>
   <td><code>1111 &amp; 1001 = 1001</code></td>
  </tr>
  <tr>
   <td><code>15 | 9</code></td>
   <td><code>15</code></td>
   <td><code>1111 | 1001 = 1111</code></td>
  </tr>
  <tr>
   <td><code>15 ^ 9</code></td>
   <td><code>6</code></td>
   <td><code>1111 ^ 1001 = 0110</code></td>
  </tr>
  <tr>
   <td><code>~15</code></td>
   <td><code>-16</code></td>
   <td><code>~</code><code>00000000...</code><code>00001111 = </code><code>1111</code><code>1111</code><code>...</code><code>11110000</code></td>
  </tr>
  <tr>
   <td><code>~9</code></td>
   <td><code>-10</code></td>
   <td><code>~</code><code>00000000</code><code>...</code><code>0000</code><code>1001 = </code><code>1111</code><code>1111</code><code>...</code><code>1111</code><code>0110</code></td>
  </tr>
 </tbody>
</table>

<p>Зауважте, що усі 32 біти інвертуються побітовим оператором НЕ, і що значення, в яких найстарший (перший зліва) біт дорівнює 1, відображають від'ємні числа (формат доповняльного коду).</p>

<h4 id="Bitwise_Shift_Operators" name="Bitwise_Shift_Operators">Оператори бітового зсуву</h4>

<p>Оператори бітового зсуву приймають два операнди: перший є величиною, в якій треба виконати зсув, а другий вказує кількість бітових позицій для зсуву. Напрямок операції зсуву контролюється застосованим оператором.</p>

<p>Оператори зсуву перетворюють свої операнди на 32-бітні цілі числа та повертають результат того самого типу, до якого належить лівий операнд.</p>

<p>Оператори зсуву наведені у наступній таблиці.</p>

<table class="fullwidth-table">
 <caption>Оператори бітового зсуву</caption>
 <thead>
  <tr>
   <th scope="col">Оператор</th>
   <th scope="col">Опис</th>
   <th scope="col">Приклад</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#&lt;&lt;_Лівий_зсув">Лівий зсув</a><br>
    (<code>&lt;&lt;</code>)</td>
   <td>Цей оператор виконує зсув першого операнду на вказану кількість бітів ліворуч. Надлишкові біти, зсунуті ліворуч, відкидаються. Біти, додані справа, заповнюються нулями.</td>
   <td><code>9&lt;&lt;2</code> вертає 36, тому що число 1001, зсунуте на 2 біти ліворуч, стає 100100, тобто, 36.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#>>_Правий_зсув_з_розширенням_знаку">Правий зсув з розширенням знаку</a> (<code>&gt;&gt;</code>)</td>
   <td>
    <p>Цей оператор виконує зсув першого операнду на вказану кількість бітів праворуч. Надлишкові біти, зсунуті праворуч, відкидаються. Біти, додані зліва, заповнюються значенням старшого біта.</p>
   </td>
   <td><code>9&gt;&gt;2</code> вертає 2, тому що число 1001, зсунуте на 2 біти праворуч, стає 10, тобто 2. Аналогічно, <code>-9&gt;&gt;2</code> вертає -3,  тому що знак зберігається.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#>>>_Правий_зсув_із_заповненням_нулями">Правий зсув із заповненням нулями</a>(<code>&gt;&gt;&gt;</code>)</td>
   <td>
    <p>Цей оператор виконує зсув першого операнду на вказану кількість бітів праворуч. Надлишкові біти, зсунуті праворуч, відкидаються. Біти, додані зліва, заповнюються нулями.</p>
   </td>
   <td><code>19&gt;&gt;&gt;2</code> вертає 4, тому що число 10011, зсунуте на 2 бітів праворуч, стає 100, тобто 4. Для невід'ємних чисел, правий зсув із заповненням нулями та правий зсув з розширенням знаку дають однаковий результат.</td>
  </tr>
 </tbody>
</table>

<h3 id="Логічні_оператори">Логічні оператори</h3>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/Logical_Operators">Логічні оператори</a> застосовуються до булевих (логічних) значень; в цьому випадку вони повертають значення типу Boolean. Однак, оператори <code>&amp;&amp;</code> та <code>||</code> насправді повертають значення одного з заданих операндів, тому, якщо ці оператори використовуються зі значеннями не булевого типу, вони повернуть значення не булевого типу. Логічні оператори описані у наведеній нижче таблиці.</p>

<table class="fullwidth-table">
 <caption>Логічні оператори</caption>
 <thead>
  <tr>
   <th scope="col">Оператор</th>
   <th scope="col">Застосування</th>
   <th scope="col">Опис</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Логічне_І">Логічне І</a> (<code>&amp;&amp;</code>)</td>
   <td><code>expr1 &amp;&amp; expr2</code></td>
   <td>Вертає вираз <code>expr1</code>, якщо він може бути перетворений на <code>false</code>; інакше, повертає <code>expr2</code>. Таким чином, при використанні з булевими значеннями <code>&amp;&amp;</code> вертає <code>true</code>, якщо обидва операнди дорівнюють true; інакше, вертає <code>false</code>.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Логічне_АБО">Логічне АБО </a>(<code>||</code>)</td>
   <td><code>expr1 || expr2</code></td>
   <td>Вертає вираз <code>expr1</code>, якщо він може бути перетворений на <code>true</code>; інакше, вертає <code>expr2</code>. Таким чином, при використанні з булевими значеннями <code>||</code> вертає <code>true</code>, якщо будь-який з операндів дорівнює true; якщо обидва дорівнюють false, вертає <code>false</code>.</td>
  </tr>
  <tr>
   <td><a href="/uk/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Логічне_НЕ_!">Логічне НЕ </a>(<code>!</code>)</td>
   <td><code>!expr</code></td>
   <td>Вертає <code>false</code>, якщо його єдиний операнд може бути перетворений на <code>true</code>; інакше, вертає <code>true</code>.</td>
  </tr>
 </tbody>
</table>

<p>Прикладами виразів, які можуть бути перетворені на <code>false</code>, є ті, які повертають null, 0, NaN, порожній рядок ("") або undefined.</p>

<p>Наступний код демонструє приклади оператора <code>&amp;&amp;</code> (логічне І).</p>

<pre class="brush: js">var a1 =  true &amp;&amp; true;     // t &amp;&amp; t вертає true
var a2 =  true &amp;&amp; false;    // t &amp;&amp; f вертає false
var a3 = false &amp;&amp; true;     // f &amp;&amp; t вертає false
var a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f вертає false
var a5 = 'Кіт' &amp;&amp; 'Пес';    // t &amp;&amp; t вертає Пес
var a6 = false &amp;&amp; 'Кіт';    // f &amp;&amp; t вертає false
var a7 = 'Кіт' &amp;&amp; false;    // t &amp;&amp; f вертає false
</pre>

<p>Наступний код демонструє приклади оператора <code>||</code> (логічне АБО).</p>

<pre class="brush: js">var o1 =  true || true;     // t || t вертає true
var o2 = false || true;     // f || t вертає true
var o3 =  true || false;    // t || f вертає true
var o4 = false || (3 == 4); // f || f вертає false
var o5 = 'Кіт' || 'Пес';    // t || t вертає Кіт
var o6 = false || 'Кіт';    // f || t вертає Кіт
var o7 = 'Кіт' || false;    // t || f вертає Кіт
</pre>

<p>Наступний код демонструє приклади оператора <code>!</code> (логічне НЕ).</p>

<pre class="brush: js">var n1 = !true;  // !t вертає false
var n2 = !false; // !f вертає true
var n3 = !'Кіт'; // !t вертає false
</pre>

<h4 id="Short-Circuit_Evaluation" name="Short-Circuit_Evaluation">Коротке замикання обчислення</h4>

<p>Оскільки логічні вирази обчислюються зліва направо, вони перевіряються на можливе "коротке замикання" обчислення за наступними правилами:</p>

<ul>
 <li><code>false</code> &amp;&amp; <em>будь-що</em> обчислюється як false.</li>
 <li><code>true</code> || <em>будь-що</em> обчислюється як true.</li>
</ul>

<p>Правила логіки гарантують, що ці обчислення завжди будуть правильними. Зауважте, що частина виразу <em>будь-що</em> не обчислюється, тому будь-які побічні ефекти від цих обчислень не відбудуться.</p>

<h3 id="Рядкові_оператори">Рядкові оператори</h3>

<p>На додачу до операторів порівняння, які можуть застосовуватись до рядкових значень, оператор конкатенації (+) об'єднує значення двох рядків, повертаючи інший рядок, який є об'єднанням рядків двох операндів.</p>

<p>Наприклад,</p>

<pre class="brush: js">console.log('мій ' + 'рядок'); // консоль виводить рядок "мій рядок".</pre>

<p>Скорочений оператор присвоєння += також може застосовуватись для конкатенації рядків.</p>

<p>Наприклад,</p>

<pre class="brush: js">var mystring = 'алфа';
mystring += 'віт'; // повертає "алфавіт" та присвоює це значення mystring.</pre>

<h3 id="Умовний_тернарний_оператор">Умовний (тернарний) оператор</h3>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">Умовний оператор</a> - єдиний оператор у JavaScript, який приймає три операнди. У оператора може бути одне чи два значення, в залежності від умови. Використовує наступний синтакс:</p>

<pre class="syntaxbox"><em>умова</em> ? значення<em>1</em> : значення<em>2</em>
</pre>

<p>Якщо <code>умова</code> дорівнює true, оператор повертає <code>значення1</code>.  В іншому випадку - <code>значення2</code>. Умовний оператор можна використовувати будь-де, де використовується звичайний оператор. Наприклад:</p>

<pre class="brush: js">var status = (age &gt;= 18) ? 'дорослий' : 'неповнолітній';
</pre>

<p>Ця інструкція присвоює значення "дорослий" змінній <code>status</code>, якщо значення <code>age</code> (вік) більше чи дорівнює 18. Інакше, вона присвоює змінній <code>status</code> значення "неповнолітній".</p>

<h3 id="Comma_operator" name="Comma_operator">Оператор кома</h3>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/Comma_Operator">Оператор кома</a> (<code>,</code>) просто обчислює обидва свої операнди та повертає значення останнього операнда. Цей оператор найчастіше використовується всередині циклу <code>for</code>, що дозволяє оновлювати більше однієї змінної на кожному проході циклу.</p>

<p>Наприклад, якщо <code>a</code> є двовимірним масивом з 10 елементами по кожній стороні, наступний код використовує оператор кома, щоб оновити дві змінні одночасно. Код виводить значення діагональних елементів масиву:</p>

<pre class="brush: js">for (var i = 0, j = 9; i &lt;= j; i++, j--)
  console.log('a[' + i + '][' + j + ']= ' + a[i][j]);
</pre>

<h3 id="Унарні_оператори">Унарні оператори</h3>

<p>Унарна операція - це операція лише з одним операндом.</p>

<h4 id="delete" name="delete"><code>delete</code></h4>

<p>Оператор <code><a href="/uk/docs/Web/JavaScript/Reference/Operators/delete">delete</a></code> видаляє об'єкт, властивість об'єкта або елемент за вказаним індексом у масиві. Синтаксис наступний:</p>

<pre class="brush: js">delete objectName;
delete objectName.property;
delete objectName[index];
delete property; // працює лише всередині конструкції with
</pre>

<p>де <code>objectName</code> є іменем об'єкта, <code>property</code> - існуюча властивість, а <code>index</code> - ціле число, що вказує розташування елемента у масиві.</p>

<p>Четверта форма працює лише всередині блоку <code><a href="/uk/docs/Web/JavaScript/Reference/Statements/with">with</a></code> для видалення властивості об'єкта.</p>

<p>Ви можете використовувати оператор <code>delete</code> для видалення змінних, оголошених неявно, але не тих, що були оголошені оператором <code>var</code>.</p>

<p>Якщо оператор <code>delete</code> відпрацьовує успішно, значенням властивості чи елемента стає <code>undefined</code>. Оператор <code>delete</code> повертає <code>true</code>, якщо операція можлива; він повертає <code>false</code>, якщо операція неможлива.</p>

<pre class="brush: js">x = 42;
var y = 43;
myobj = new Number();
myobj.h = 4;    // створює властивість h
delete x;       // вертає true (можна видалити властивість, оголошену неявно)
delete y;       // вертає false (не можна видалити властивість, оголошену через var)
delete Math.PI; // вертає false (не можна видаляти попередньо визначені властивості)
delete myobj.h; // вертає true (можна видалити властивість, визначену користувачем)
delete myobj;   // вертає true (можна видалити, якщо властивість оголошена неявно)
</pre>

<h5 id="Видалення_елементів_масиву">Видалення елементів масиву</h5>

<p>Коли ви видаляєте елемент масиву, це не впливає на довжину масиву. Для прикладу, якщо ви видалите <code>a[3]</code>, <code>a[4]</code> досі є <code>a[4]</code>, а <code>a[3]</code> дорівнює undefined.</p>

<p>Коли оператор <code>delete</code> видаляє елемент масиву, цей елемент більше не існує у масиві. У наступному прикладі <code>trees[3]</code> видаляється оператором <code>delete</code>. Однак, адреса <code>trees[3]</code> досі доступна та повертає <code>undefined</code>.</p>

<pre class="brush: js">var trees = ['секвоя', 'лавр', 'кедр', 'дуб', 'клен'];
delete trees[3];
if (3 in trees) {
  // це не виконається
}
</pre>

<p>Якщо вам потрібно, щоб елемент існував, але мав значення undefined, скористайтесь ключовим словом <code>undefined</code> замість оператора <code>delete</code>. У наступному прикладі <code>trees[3]</code> присвоюється значення <code>undefined</code>, але елемент масиву досі існує:</p>

<pre class="brush: js">var trees = ['секвоя', 'лавр', 'кедр', 'дуб', 'клен'];
trees[3] = undefined;
if (3 in trees) {
  // це виконається
}
</pre>

<h4 id="typeof" name="typeof"><code>typeof</code></h4>

<p>Оператор <a href="/uk/docs/Web/JavaScript/Reference/Operators/typeof"><code>typeof</code></a> використовується наступним чином:</p>

<pre class="syntaxbox">typeof операнд
typeof (операнд)
</pre>

<p>Оператор <code>typeof</code> повертає рядок, що вказує тип необчисленого операнда. <code>Операнд</code> є рядком, змінною, ключовим словом чи об'єктом, для якого треба повернути тип. Круглі дужки є необов'язковими.</p>

<p>Припустимо, ви визначили наступні змінні:</p>

<pre class="brush: js">var myFun = new Function('5 + 2');
var shape = 'коло';
var size = 1;
var foo = ['Яблуко', 'Манго', 'Апельсин'];
var today = new Date();
</pre>

<p>Оператор <code>typeof</code> вертає наступні результати для цих змінних:</p>

<pre class="brush: js">typeof myFun;       // вертає "function"
typeof shape;       // вертає "string"
typeof size;        // вертає "number"
typeof foo;         // вертає "object"
typeof today;       // вертає "object"
typeof doesntExist; // вертає "undefined"
</pre>

<p>Для ключових слів <code>true</code> та <code>null</code> оператор <code>typeof</code> вертає наступні результати:</p>

<pre class="brush: js">typeof true; // вертає "boolean"
typeof null; // вертає "object"
</pre>

<p>Для числа та рядка оператор <code>typeof</code> вертає наступні результати:</p>

<pre class="brush: js">typeof 62;            // вертає "number"
typeof 'Hello world'; // вертає "string"
</pre>

<p>Для значень властивостей оператор <code>typeof</code> вертає тип значення, яке містить ця властивість:</p>

<pre class="brush: js">typeof document.lastModified; // вертає "string"
typeof window.length;         // вертає "number"
typeof Math.LN2;              // вертає "number"
</pre>

<p>Для методів та функцій оператор <code>typeof</code> вертає наступні результати:</p>

<pre class="brush: js">typeof blur;        // вертає "function"
typeof eval;        // вертає "function"
typeof parseInt;    // вертає "function"
typeof shape.split; // вертає "function"
</pre>

<p>Для попередньо визначених об'єктів оператор <code>typeof</code> вертає наступні результати:</p>

<pre class="brush: js">typeof Date;     // вертає "function"
typeof Function; // вертає "function"
typeof Math;     // вертає "object"
typeof Option;   // вертає "function"
typeof String;   // вертає "function"
</pre>

<h4 id="void" name="void"><code>void</code></h4>

<p>Оператор <a href="/uk/docs/Web/JavaScript/Reference/Operators/void"><code>void</code></a> використовується наступним чином:</p>

<pre class="syntaxbox">void (вираз)
void вираз
</pre>

<p>Оператор <code>void</code> вказує, що вираз має бути обчислений без повернення значення. <code>Вираз</code> є виразом JavaScript, який треба обчислити. Дужки, що оточують вираз, є необов'язковими, але вживати їх є гарним стилем.</p>

<p>Ви можете скористатись оператором <code>void</code>, щоб вказати вираз як гіпертекстове посилання. Вираз обчислюється, але не завантажується на місці відкритого документа.</p>

<p>Наступний код створює гіпертекстове посилання, яке нічого не робить, коли користувач на нього натискає. Коли користувач натискає на посилання, <code>void(0)</code> обчислюється як <code>undefined</code>, що не має жодного ефекту у JavaScript.</p>

<pre class="brush: html">&lt;a href="javascript:void(0)"&gt;Натисніть сюди, щоб нічого не робити&lt;/a&gt;
</pre>

<p>Наступний код створює гіпертекстове посилання, яке відправляє форму, коли користувач натискає на нього.</p>

<pre class="brush: html">&lt;a href="javascript:void(document.form.submit())"&gt;
Натисніть сюди, щоб відправити&lt;/a&gt;</pre>

<h3 id="Оператори_відношення">Оператори відношення</h3>

<p>Оператор відношення порівнює свої операнди та повертає значення <code>Boolean</code>, на підставі того, чи є порівняння істиною.</p>

<h4 id="in"><code>in</code></h4>

<p>Оператор <a href="/uk/docs/Web/JavaScript/Reference/Operators/in"><code>in</code></a> повертає <code>true</code>, якщо вказана властивість існує на вказаному об'єкті. Синтаксис наступний:</p>

<pre class="brush: js">propNameOrNumber in objectName
</pre>

<p>де <code>propNameOrNumber</code> є рядковим або числовим виразом, який відображає ім'я властивості або індекс у масиві, а <code>objectName</code> є ім'ям об'єкта.</p>

<p>Наступний приклад демонструє варіанти використання оператора <code>in</code>.</p>

<pre class="brush: js">// Масиви
var trees = ['секвоя', 'лавр', 'кедр', 'дуб', 'клен'];
0 in trees;        // вертає true
3 in trees;        // вертає true
6 in trees;        // вертає false
'лавр' in trees;    // вертає false (ви маєте вказати індекс,
                   // а не значення за цим індексом)
'length' in trees; // вертає true (length є властивістю масиву)

// вбудовані об'єкти
'PI' in Math;          // вертає true
var myString = new String('корал');
'length' in myString;  // вертає true

// Користувацькі об'єкти
var mycar = { make: 'Honda', model: 'Accord', year: 1998 };
'make' in mycar;  // вертає true
'model' in mycar; // вертає true
</pre>

<h4 id="instanceof" name="instanceof"><code>instanceof</code></h4>

<p>Оператор <a href="/uk/docs/Web/JavaScript/Reference/Operators/instanceof"><code>instanceof</code></a> повертає <code>true</code>, якщо вказаний об'єкт належить до вказаного типу. Синтаксис наступний:</p>

<pre class="syntaxbox">objectName instanceof objectType
</pre>

<p>де <code>objectName</code> є ім'ям об'єкта, який порівнюється з <code>objectType</code>, а <code>objectType</code> є типом об'єкта, наприклад, {{jsxref("Date")}} або {{jsxref("Array")}}.</p>

<p>Використовуйте <code>instanceof</code>, коли вам необхідно підтвердити тип об'єкта під час виконання. Наприклад, перехоплюючи винятки, ви можете зробити відгалуження до іншого коду обробки винятків, в залежності від типу викинутого винятку.</p>

<p>Наприклад, наступний код використовує <code>instanceof</code> для визначення того, чи <code>theDay</code> є об'єктом <code>Date</code>. Оскільки <code>theDay</code> є об'єктом <code>Date</code>, інструкції у блоці <code>if</code> будуть виконані.</p>

<pre class="brush: js">var theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // інструкції для виконання
}
</pre>

<h3 id="Пріоритет_операторів">Пріоритет операторів</h3>

<p><em>Пріоритет</em> операторів визначає порядок, у якому вони застосовуються під час обчислення виразу. Ви можете змінити пріоритет оператора, використавши дужки.</p>

<p>Наступна таблиця наводить пріоритети операторів, від найвищого до найнижчого.</p>

<table class="standard-table">
 <caption>Пріоритет операторів</caption>
 <thead>
  <tr>
   <th scope="col">Тип оператора</th>
   <th scope="col">Окремі оператори</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>властивість</td>
   <td><code>. []</code></td>
  </tr>
  <tr>
   <td>виклик / створення екземпляра</td>
   <td><code>() new</code></td>
  </tr>
  <tr>
   <td>заперечення / інкремент</td>
   <td><code>! ~ - + ++ -- typeof void delete</code></td>
  </tr>
  <tr>
   <td>множення / ділення</td>
   <td><code>* / %</code></td>
  </tr>
  <tr>
   <td>додавання / віднімання</td>
   <td><code>+ -</code></td>
  </tr>
  <tr>
   <td>бітовий зсув</td>
   <td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
  </tr>
  <tr>
   <td>відношення</td>
   <td><code>&lt; &lt;= &gt; &gt;= in instanceof</code></td>
  </tr>
  <tr>
   <td>рівність</td>
   <td><code>== != === !==</code></td>
  </tr>
  <tr>
   <td>побітове-і</td>
   <td><code>&amp;</code></td>
  </tr>
  <tr>
   <td>виключне-побітове-або</td>
   <td><code>^</code></td>
  </tr>
  <tr>
   <td>побітове-або</td>
   <td><code>|</code></td>
  </tr>
  <tr>
   <td>логічне-і</td>
   <td><code>&amp;&amp;</code></td>
  </tr>
  <tr>
   <td>логічне-або</td>
   <td><code>||</code></td>
  </tr>
  <tr>
   <td>умовний</td>
   <td><code>?:</code></td>
  </tr>
  <tr>
   <td>присвоєння</td>
   <td><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=</code></td>
  </tr>
  <tr>
   <td>кома</td>
   <td><code>,</code></td>
  </tr>
 </tbody>
</table>

<p>Більш детальну версію цієї таблиці, доповнену посиланнями на додаткові подробиці щодо кожного оператора, можна знайти у <a href="/uk/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">довіднику з JavaScript</a>.</p>

<h2 id="Вирази">Вирази</h2>

<p><em>Виразом</em> є будь-яка одиниця коду, яка вирішується з певним значенням.</p>

<p>Кожний синтаксично коректний вираз вирішується з якимось значенням, але, концептуально, існують два типи виразів: з побічними ефектами (наприклад: ті, що присвоюють значення змінній) та такі, що обчислюються і, таким чином, вирішуються з певним значенням.</p>

<p>Вираз <code>x = 7</code> є прикладом першого типу. Цей вираз використовує <em>оператор</em> = для присвоєння семи змінній<em> </em><code>x</code>. Сам вираз обчислюється з результатом сім.</p>

<p>Код <code>3 + 4</code> є прикладом другого типу виразів. Цей вираз за допомогою оператора + складає три та чотири без присвоєння результату, семи, змінній.<br>
 <br>
 JavaScript має наступні категорії виразів:</p>

<ul>
 <li>Арифметичні: обчислюються як число, наприклад, 3.14159. (Загалом, використовують {{ web.link("#Арифметичні_оператори", "арифметичні оператори") }}.)</li>
 <li>Рядкові: обчислюються як рядок, наприклад, "Фред" або "234". (Загалом, використовують {{ web.link("#Рядкові_оператори", "рядкові оператори") }}.)</li>
 <li>Логічні: обчислюються як true або false. (Часто використовують {{ web.link("#Логічні_оператори", "логічні оператори") }}.)</li>
 <li>Первинні вирази: Базові ключові слова та загальні вирази у JavaScript.</li>
 <li>Лівосторонні вирази: значення зліва є призначенням присвоєння.</li>
</ul>

<h3 id="Первинні_вирази">Первинні вирази</h3>

<p>Базові ключові слова та загальні вирази у JavaScript.</p>

<h4 id="this" name="this"><code>this</code></h4>

<p>Використовуйте <a href="/uk/docs/Web/JavaScript/Reference/Operators/this">ключове слово <code>this</code></a> для посилання на поточний об'єкт. Загалом, <code>this</code> у методі посилається на об'єкт, що його викликав. Використовуйте <code>this</code> або з крапкою, або з дужковою нотацією:</p>

<pre class="syntaxbox">this['propertyName']
this.propertyName
</pre>

<p>Припустимо, функція на ім'я <code>validate</code> перевіряє властивість об'єкта <code>value</code>, маючи найменше та найбільше значення:</p>

<pre class="brush: js">function validate(obj, lowval, hival) {
  if ((obj.value &lt; lowval) || (obj.value &gt; hival))
    console.log('Некоректне значення!');
}
</pre>

<p>Ви можете викликати <code>validate</code> в кожному обробнику подій елементів форми <code>onChange</code>, використовуючи <code>this</code>, щоб передати йому елемент форми, як у наступному прикладі:</p>

<pre class="brush: html">&lt;p&gt;Введіть число між 18 та 99:&lt;/p&gt;
&lt;input type="текст" name="вік" size=3 onChange="validate(this, 18, 99);"&gt;
</pre>

<h4 id="Оператор_групування">Оператор групування</h4>

<p>Оператор групування <code>( )</code> контролює пріоритет обчислення у виразах. Наприклад, ви можете змінити обчислення спочатку множення та ділення, а потім додавання та віднімання, щоб обчислити спочатку додавання.</p>

<pre class="brush:js">var a = 1;
var b = 2;
var c = 3;

// пріоритет за замовчуванням
a + b * c     // 7
// обчислюється наступним чином
a + (b * c)   // 7

// тепер змінюємо пріоритет
// додавання перед множенням
(a + b) * c   // 9

// що є рівнозначним
a * c + b * c // 9
</pre>

<h3 id="Лівосторонні_вирази">Лівосторонні вирази</h3>

<p>Значення зліва є призначенням присвоєння.</p>

<h4 id="new" name="new"><code>new</code></h4>

<p>Ви можете скористатись <a href="/uk/docs/Web/JavaScript/Reference/Operators/new">оператором <code>new</code></a>, щоб створити екземпляр визначеного користувачем типу об'єкта або одного з вбудованих типів. Використовуйте <code>new</code> наступним чином:</p>

<pre class="brush: js">var objectName = new objectType([param1, param2, ..., paramN]);
</pre>

<h4 id="super">super</h4>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/super">Ключове слово super</a> використовується для виклику функцій батьківського об'єкта. Воно корисне для використання з <a href="/uk/docs/Web/JavaScript/Reference/Classes">класами</a>, для виклику батьківського конструктора, наприклад.</p>

<pre class="syntaxbox">super([arguments]); // викликає батьківський конструктор.
super.functionOnParent([arguments]);
</pre>

<h4 id="Оператор_розпакування">Оператор розпакування</h4>

<p><a href="/uk/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Оператор розпакування</a> дозволяє розкласти вираз там, де очікується більше одного аргументу (для викликів функцій) або більше одного елемента (для масивних літералів).</p>

<p><strong>Приклад:</strong> Сьогодні, якщо ви маєте масив та бажаєте створити новий масив, використавши існуючий масив як його частину, синтаксису масивного літералу більше недостатньо, і вам доводиться повертатись до імперативного коду, використовуючи комбінацію з <code>push</code>, <code>splice</code>, <code>concat</code>, і т. д. З оператором розпакування все стає набагато лаконічнішим:</p>

<pre class="brush: js">var parts = ['плечі', 'коліна'];
var lyrics = ['голова', ...parts, 'та', 'пальці'];</pre>

<p>Схожим чином оператор розпакування працює з викликами функцій:</p>

<pre class="brush: js">function f(x, y, z) { }
var args = [0, 1, 2];
f(...args);</pre>

<div>{{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>
