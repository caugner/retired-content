---
title: Граматика та типи
slug: Web/JavaScript/Guide/Grammar_and_types
tags:
  - JavaScript
  - 'l10n:priority'
  - Посібник
translation_of: Web/JavaScript/Guide/Grammar_and_types
---
<p>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}</p>

<p class="summary">В цьому розділі розглядаються основи граматики JavaScript, оголошення змінних, типи даних і літерали.</p>

<h2 id="Основи">Основи</h2>

<p>Більшість свого синтаксису JavaScript запозичає у Java, C та C++, але на нього вплинули також Awk, Perl і Python.</p>

<p>Мова JavaScript <strong>чутлива до регістру</strong> і використовує <span class="short_text" id="result_box" lang="uk"><span>набір</span> <span>символів</span></span> <strong>Unicode</strong>. Наприклад, слово Früh (що німецькою означає "рано") може використовуватись як ім'я змінної.</p>

<pre class="brush: js notranslate">let Früh = "foobar"</pre>

<p>Проте, змінна <code>früh</code> не одне й те саме, що <code>Früh</code>, тому що мова JavaScript чутлива до регістру.</p>

<p>У JavaScript команди називаються <a href="/uk/docs/Glossary/Інструкція">інструкціями</a> і розділяються крапкою з комою (;).</p>

<p>Немає необхідності ставити крапку з комою після інструкції, якщо вона написана на своєму власному рядку. Проте, якщо ви бажаєте мати більш, ніж одну інструкцію в рядку, тоді потрібно їх відділяти крапкою з комою.</p>

<div class="blockIndicator note">
<p>ECMAScript також має правила для автоматичної вставки крапки з комою (<a href="/uk/docs/Web/JavaScript/Reference/Lexical_grammar#Автоматична_вставка_крапки_з_комою">ASI</a>, Automatic semicolon insertion) в кінці інструкцій. (Щоб отримати більше інформації, перегляньте детальну довідку щодо <a href="/uk/docs/Web/JavaScript/Reference/Lexical_grammar">лексичної граматики</a> JavaScript.)</p>
</div>

<p>Однак, вважається найкращою практикою завжди ставити крапку з комою після інструкції, навіть якщо вона не вимагається. Ця практика зменшує шанси отримати помилки у коді.</p>

<p>Текст скрипта у JavaScript сканується зліва направо та конвертується у послідовність вхідних елементів, якими є <em>токени</em>, <em>керівні символи, символи розриву рядка, коментарі,</em> або <a href="/uk/docs/Glossary/Whitespace">пробільні символи</a>. (Символи пробілів, табуляції та символи нового рядка вважаються пробільними символами).</p>

<h2 id="Коментарі">Коментарі</h2>

<p>Синтаксис <strong>коментарів</strong> такий самий, як у C++ та багатьох інших мовах програмування:</p>

<pre class="brush: js notranslate">// однорядковий коментар

/* а це довший,
* багаторядковий коментар
*/

/* Однак, не можна, /* вкладати коментарі */ SyntaxError */</pre>

<p>Коментарі поводяться як пробіли та відкидаються під час виконання скрипта.</p>

<div class="blockIndicator note">
<p><strong>Заувага</strong>: Ви можете також побачити третій тип синтаксису коментарів на початку деяких файлів JavaScript, який виглядає приблизно так: <code>#!/usr/bin/env node.</code></p>

<p>Цей синтаксис називається <strong>шебанг</strong>, це спеціальний коментар, який використовується, щоб вказати шлях до певного рушія JavaScript, який має виконати скрипт. Дивіться <a href="/uk/docs/Web/JavaScript/Reference/Lexical_grammar#Коментарі_шебанг">коментарі шебанг</a> для більш детальної інформації.</p>
</div>

<h2 id="Оголошення">Оголошення</h2>

<p>Існують три види оголошення змінних у JavaScript.</p>

<dl>
 <dt>{{jsxref("Statements/var", "var")}}</dt>
 <dd>Оголошує змінну та необов'язково ініціалізує її значенням.</dd>
 <dt>{{jsxref("Statements/let", "let")}}</dt>
 <dd>Оголошує локальну змінну блочної області видимості, необов'язково ініціалізуючи її значенням.</dd>
 <dt>{{jsxref("Statements/const","const")}}</dt>
 <dd>Оголошує константу блочної області видимості, доступну тільки для читання.</dd>
</dl>

<h3 id="Змінні">Змінні</h3>

<p><span id="result_box" lang="uk"><span>Ви використовуєте змінні, як символічні імена для значень у вашій програмі.</span></span> Назви змінних, <a href="/uk/docs/Glossary/ідентифікатор">ідентифікатори</a>, відповідають певним правилам.</p>

<p>Ідентифікатори JavaScript повинні починатися з літери, знаку підкреслення (<code>_</code>) або знаку долара (<code>$</code>). Н<span class="short_text" id="result_box" lang="uk"><span>аступні символи можуть також бути цифрами</span></span> (<code>0</code>-<code>9</code>).</p>

<p>Оскільки мова JavaScript чутлива до регістру, літери включають у себе символи від "<code>A</code>" до "<code>Z</code>" (у верхньому регістрі) та символи від  "<code>a</code>" до "<code>z</code>" (у нижньому регістрі).</p>

<p>Ви можете використовувати більшу частину літер ISO 8859-1 або Юнікоду, такі як <code>å</code> та <code>ü</code> у ідентифікаторах. (Для більш детальної інформації дивіться <a href="https://mathiasbynens.be/notes/javascript-identifiers-es6">цю статтю</a>.) Ви також можете використовувати <a href="/uk/docs/Web/JavaScript/Reference/Lexical_grammar#Рядкові_літерали">екрановані послідовності Юнікоду </a>в якості символів у ідентифікаторах.</p>

<p>Деякі приклади допустимих назв: <code>Number_hits</code>, <code>temp99</code>, <code>$credit</code> та <code>_name</code>.</p>

<h3 id="Оголошення_змінних">Оголошення змінних</h3>

<p>Ви можете оголосити змінну двома шляхами:</p>

<ul>
 <li>За допомогою ключого слова {{jsxref("Statements/var", "var")}}. Наприклад,<code>var x = 42</code>. <span id="result_box" lang="uk"><span>Цей синтаксис може використовуватись для оголошення як <strong>локальних</strong>, так і <strong>глобальних </strong>змінних, в залежності від <em>контексту виконання</em>.</span></span></li>
 <li><span class="short_text" id="result_box" lang="uk"><span>За допомогою ключового слова {{jsxref("Statements/const", "const")}} або {{jsxref("Statements/let", "let")}}.Наприклад, <code>let y = 13</code>. Цей синтаксис може бути використаний для оголошення локальної змінної блочної області видимості. (Дивіться <a href="#Область_видимості_змінної">Область видимості змінної</a> нижче).</span></span></li>
</ul>

<p>Ви також можете просто присвоїти змінній значення. Наприклад, <code>x = 42</code>. Ця форма створює <strong><a href="/uk/docs/Web/JavaScript/Reference/Statements/var#Опис">неоголошену глобальну</a> </strong>змінну. Вона також генерує попередження у JavaScript. Неоголошені глобальні змінні можуть привести до неочікуваної поведінки. Тому не рекомендується використовувати неоголошені глобальні змінні.</p>

<h3 id="Обчислення_змінних">Обчислення змінних</h3>

<p>Змінна, оголошена за допомогою <code>var</code> або <code>let</code>, без початкового значення, має значення {{jsxref("undefined")}}.</p>

<p>Спроба звернення до неоголошеної змінної призведе до викидання винятку {{jsxref("ReferenceError")}}:</p>

<pre class="brush: js notranslate">var a;
console.log('Значення a дорівнює ' + a); // Значення a дорівнює undefined

console.log('Значення b дорівнює ' + b); // Значення b дорівнює undefined
var b;
// Це може спантеличити, доки ви не прочитаєте 'Підняття змінних' нижче

console.log('Значення c дорівнює ' + c); // Uncaught ReferenceError: c is not defined

let x;
console.log('Значення x дорівнює ' + x); // Значення x дорівнює undefined

console.log('Значення y дорівнює ' + y); // Uncaught ReferenceError: y is not defined
let y; </pre>

<p><span id="result_box" lang="uk"><span>Можна використати <code>undefined</code>, щоб з'ясувати, чи має змінна значення.</span> <span>У наступному коді змінній <code>input</code> не присвоюється значення, і умова в операторі </span></span><code><a href="/uk/docs/Web/JavaScript/Reference/Statements/if...else" title="uk/docs/JavaScript/Reference/Statements/if...else">if</a></code> набуває значення<span lang="uk"><span> <code>true</code>.</span></span></p>

<pre class="brush: js notranslate">var input;
if (input === undefined) {
  doThis();
} else {
  doThat();
}</pre>

<p>Значення <code>undefined</code> поводить себе як <code>false</code>, коли використовується в булевому контексті. Наприклад, <span id="result_box" lang="uk"><span>наступний код виконує функцію <code>myFunction</code>, оскільки елемент <code>myArray</code> дорівнює <code>undefined</code></span></span>:</p>

<pre class="brush: js notranslate">var myArray = [];
if (!myArray[0]) myFunction(); </pre>

<p>Значення <code>undefined</code> перетворюється на <code>NaN</code>, коли використовується у числовому контексті.</p>

<pre class="brush: js notranslate">var a;
a + 2;  // Обчислюється як NaN</pre>

<p>Коли ви обчислюєте змінну {{jsxref("null")}}, значення null поводить себе як 0 у числовому контексті, та як false - у булевому. Наприклад:</p>

<pre class="brush: js notranslate">var n = null;
console.log(n * 32); // Виведе 0 у консоль</pre>

<h3 id="Область_видимості_змінної"> Область видимості змінної</h3>

<p><span id="result_box" lang="uk">Коли ви оголошуєте змінну за межами будь-яких функцій, вона називається <em>глобальною</em> змінною, позаяк доступна для будь-якого іншого коду у поточному документі. Коли ви оголошуєте змінну всередині функції, вона називається <em>локальною </em>змінною, позаяк доступна лише в межах цієї функції.</span></p>

<p>JavaScript до ECMAScript 2015 не має <a href="/uk/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#Блокова_інструкція">блочної</a> області видимості. Точніше, змінна, оголошена всередині блоку, є локальною для <em>функції</em> <em>(або глобальної області видимості)</em>, в якій розміщено цей блок.</p>

<p>Наприклад, наступний код виведе <code>5</code>, тому що областю видимості <code>x</code> є глобальний контекст (або контекст функції, якщо код є частиною функції). Область видимості <code>x</code> не обмежується найближчим блоком конструкції <code>if</code>.</p>

<pre class="brush: js notranslate">if (true) {
  var x = 5;
}
console.log(x);  // x дорівнює 5</pre>

<p><span id="result_box" lang="uk"><span>Ця поведінка змінюється при використанні ключового слова <code>let</code>, (представленого в ECMAScript 2015).</span></span></p>

<pre class="brush: js notranslate">if (true) {
  let y = 5;
}
console.log(y);  // ReferenceError: y is not defined</pre>

<h3 id="Підняття_змінних">Підняття змінних</h3>

<p><span id="result_box" lang="uk"><span>Ще однією особливістю змінних у JavaScript є те, що ви можете посилатися на змінну, оголошену пізніше, і це не призведе до винятку.</span></span></p>

<p>Ця концепція має назву <strong>підняття (hoisting)</strong>. Змінні у JavaScript, <span id="result_box" lang="uk"><span>в певному сенсі, "піднімаються" на вершину функції або інструкції у коді.</span></span> <span id="result_box" lang="uk"><span>Однак, підняті змінні повертають значення</span></span> <code>undefined</code>. <span id="result_box" lang="uk"><span>Тому, навіть якщо ви оголосите та ініціалізуєте змінну після використання або посилання на цю змінну, вона все одно поверне <code>undefined</code>.</span></span></p>

<pre class="brush: js notranslate">/**
* Приклад 1
*/
console.log(x === undefined); // true
var x = 3;

/**
* Приклад 2
*/
// поверне значення undefined
var myvar = 'моє значення';

(function() {
  console.log(myvar); // undefined
  var myvar = 'локальна змінна';
})();</pre>

<p><span id="result_box" lang="uk"><span>Наведені вище приклади будуть тлумачитися так само, як</span></span>:</p>

<pre class="brush: js notranslate">/**
* Приклад 1
*/
var x;
console.log(x === undefined); // true
x = 3;

/**
* Приклад 2
*/
var myvar = 'моє значення';

(function() {
  var myvar;
  console.log(myvar); // undefined
  myvar = 'локальна змінна';
})();</pre>

<p>Враховуючи підняття, всі оголошення через <code>var</code> всередині функції мають знаходитись якомога ближче до вершини функції. Така практика покращує зрозумілість коду.</p>

<p>В ECMAScript 2015 <code>let</code> та <code>const</code> <strong>підіймаються, але не ініціалізуються. </strong>Результатом посилання на змінну в блоці до оголошення цієї змінної буде {{jsxref("ReferenceError")}}, тому що змінна перебуває у "тимчасовій мертвій зоні" від початку блоку до обробки її оголошення.</p>

<pre class="brush: js notranslate">console.log(x); // ReferenceError
let x = 3;</pre>

<h3 id="Підняття_функції">Підняття функції</h3>

<p>У випадку з функціями, лише <em>оголошення</em> функцій піднімаються, але <em>не</em> <em>функціональні вирази</em>.</p>

<pre class="brush: js notranslate">/* Оголошення функції */

foo(); // "ква"

function foo() {
  console.log('ква');
}

/* Функціональний вираз */

baz(); // TypeError: baz is not a function

var baz = function() {
  console.log('кря');
};</pre>

<h3 id="Глобальні_змінні">Глобальні змінні</h3>

<p>Глобальні змінні насправді є властивостями <em>глобального об'єкта</em>.</p>

<p>На веб-сторінках глобальним об'єктом є <code><a href="/uk/docs/Web/API/Window">window</a></code>, тому ви можете присвоювати значення та звертатись до глобальних змінних за допомогою синтаксису <code>window.<em>змінна</em></code>.</p>

<p>Відповідно, ви можете звертатись до глобальних змінних, оголошених в одному вікні або фреймі, з іншого вікна або фрейму, вказавши при цьому ім'я цього вікна чи фрейму. Наприклад, якщо в документі оголошена змінна під назвою <code>phoneNumber</code>, ви можете звернутися до неї з <code>iframe</code> так: <code>parent.phoneNumber</code>.</p>

<h3 id="Константи">Константи</h3>

<p>Ви можете створити іменовану константу, призначену лише для читання, за допомогою ключового слова {{jsxref("Statements/const", "const")}}.</p>

<p>Синтаксис ідентифікатора константи такий самий, як і синтаксис будь-якого ідентифікатора змінної: він повинен починатися з літери, підкреслення або знака долара (<code>$</code>) та може містити букви, цифри або символи підкреслення.</p>

<pre class="brush: js notranslate">const PI = 3.14;</pre>

<p>Константа не може змінювати значення за допомогою присвоювання або повторно оголошуватися протягом виконання скрипта. Вона повинна бути ініціалізована початковим значенням.</p>

<p>Правила області видимості для констант такі ж, як для <code>let</code>-змінних блочної області видимості. Якщо ключове слово <code>const</code> не вказане, ідентифікатор вважається ідентифікатором змінної.</p>

<p>Не можна оголошувати константу з таким самим ім'ям, як функція або змінна в тій самій області видимості. Наприклад:</p>

<pre class="brush: js notranslate">// ЦЕ СПРИЧИНИТЬ ПОМИЛКУ
function f() {};
const f = 5;

// ЦЕ ТАКОЖ СПРИЧИНИТЬ ПОМИЛКУ
function f() {
  const g = 5;
  var g;

  //інструкції
}</pre>

<p>Однак, властивості об'єктів, присвоєних константам, не захищені, тому наступна інструкція виконується без проблем.</p>

<pre class="brush: js notranslate">const MY_OBJECT = {'key': 'значення'};
MY_OBJECT.key = 'іншезначення';</pre>

<p>Вміст будь-якого масиву також не захищений, тому наступна інструкція виконується без проблем.</p>

<pre class="brush: js notranslate">const MY_ARRAY = ['HTML','CSS'];
MY_ARRAY.push('JAVASCRIPT');
console.log(MY_ARRAY); //виведе ['HTML','CSS','JAVASCRIPT'];
</pre>

<h2 id="Структури_та_типи_даних">Структури та типи даних</h2>

<h3 id="Типи_даних">Типи даних</h3>

<p>Останній стандарт ECMAScript визначає вісім типів даних:</p>

<ul>
 <li>Сім типів даних, які є <a href="/uk/docs/Glossary/Primitive">простими типами</a>:

  <ol>
   <li><a href="/uk/docs/Glossary/Boolean">Boolean</a>. <code>true</code> та <code>false</code>.</li>
   <li><a href="/uk/docs/Glossary/null">null</a>. Спеціальне ключове слово, що позначає нульове значення. (Оскільки мова JavaScript чутлива до регістру, <code>null</code> це <em>не </em>одне й те саме, що <code>Null</code>, <code>NULL</code> чи будь-який інший варіант).</li>
   <li><a href="/uk/docs/Glossary/undefined">undefined</a>. Властивість верхнього рівня, чиє значення не визначене.</li>
   <li><a href="/uk/docs/Glossary/Number">Number</a>. Число, ціле або з плаваючою комою. Наприклад: <code>42</code> або <code>3.14159</code>.</li>
   <li><a href="/uk/docs/Glossary/BigInt">BigInt</a>. Ціле число з довільною точністю. Наприклад:  <code>9007199254740992n</code>.</li>
   <li><a href="/uk/docs/Glossary/String">String</a>. Послідовність символів, що представляють текстове значення. Наприклад: "Привіт".</li>
   <li><a href="/uk/docs/Glossary/Символ">Symbol</a> (новий в ECMAScript 2015). Тип даних, екземпляри якого унікальні та незмінні.</li>
  </ol>
 </li>
 <li>та <a href="/uk/docs/Glossary/Object">Object</a></li>
</ul>

<p>Хоча цих типів даних відносно мало, вони дозволяють виконувати корисні функції у ваших застосунках. {{jsxref("Object", "Об'єкти")}} та {{jsxref("Function", "функції")}} - це інші фундаментальні елементи мови. Об'єкти можна розглядати, як іменовані контейнери для значень, а функції - як процедури, які може виконувати скрипт. </p>

<h3 id="Перетворення_типів_даних">Перетворення типів даних</h3>

<p>JavaScript - це мова з <em>динамічною типізацією</em>. Це означає, що при оголошенні змінної не потрібно вказувати, якого вона типу. Це також означає, що типи даних автоматично перетворюються за необхідності під час виконання скрипта. </p>

<p>Наприклад, ви можете визначити змінну таким чином:</p>

<pre class="brush: js notranslate">var answer = 42;</pre>

<p>А пізніше цій же змінній можна присвоїти значення рядкового типу даних, наприклад:</p>

<pre class="brush: js notranslate">answer = 'Дякуємо за рибу...';</pre>

<p>Оскільки JavaScript динамічно типізована мова, таке присвоєння не спричиняє повідомлення про помилку.</p>

<h3 id="Числа_та_оператор">Числа та оператор '+'</h3>

<p>У виразах, що включають числові й рядкові значення з оператором <code>+</code>, JavaScript перетворює числові значення на рядки. Наприклад:</p>

<pre class="brush: js notranslate">x = 'Відповідь - ' + 42 // "Відповідь - 42"
y = 42 + ' - це відповідь' // "42 - це відповідь"</pre>

<p>З усіма іншими операторами JavaScript <em>не</em> перетворює числові значення на рядки. Наприклад:</p>

<pre class="brush: js notranslate">'37' - 7 // 30
'37' + 7 // "377"</pre>

<h3 id="Перетворення_рядків_на_числа">Перетворення рядків на числа</h3>

<p>У випадку, коли значення, що представляє число, є в пам'яті у вигляді рядка, існують методи для перетворення.</p>

<ul>
 <li id="parseInt()_and_parseFloat()">{{jsxref("parseInt", "parseInt()")}}</li>
 <li>{{jsxref("parseFloat", "parseFloat()")}}</li>
</ul>

<p><code>parseInt</code> повертає тільки цілі числа, тому його використання для десяткових чисел обмежене.</p>

<div class="blockIndicator note">
<p>Крім того, найкращою практикою для <code>parseInt</code> є завжди включати параметр <em>radix</em> (основа). Параметр radix вказує, яка система числення має використовуватись.</p>
</div>

<pre class="brush: js notranslate">parseInt('101', 2) // 5</pre>

<p>Альтернативним методом отримання числа з рядка є використання оператора <code>+</code> (унарний плюс):</p>

<pre class="brush: js notranslate">'1.1' + '1.1' // '1.11.1'
(+'1.1') + (+'1.1') // 2.2
// Зауважте: дужки не обов'язкові, вони додаються для ясності</pre>

<h2 id="Літерали">Літерали</h2>

<p><em>Літерали</em> (<em>англ.</em> literal - "буквальний") відображають значення у JavaScript. Це фіксовані значення, не змінні, які ви буквально вказуєте у сценарії. У цьому розділі описані наступні типи літералів:</p>

<ul>
 <li><a href="#Масивні_літерали">Масивні літерали</a></li>
 <li><a href="#Булеві_літерали">Булеві літерали</a></li>
 <li><a href="#Літерали_з_рухомою_крапкою">Літерали з рухомою крапкою</a></li>
 <li><a href="#Числові_літерали">Числові літерали</a></li>
 <li><a href="#Обєктні_літерали">Об'єктні літерали</a></li>
 <li><a href="#Літерали_регулярних_виразів_RegExp">Літерали регулярних виразів</a></li>
 <li><a href="#Рядкові_літерали">Рядкові літерали</a></li>
</ul>

<h3 id="Масивові_літерали">Масивові літерали</h3>

<p>Масивовий літерал - це список з нуля чи більше виразів, які представляють елементи масиву, вкладений у квадратні дужки (<code>[]</code>). Коли ви створюєте масив, використовуючи масивовий літерал, він ініціалізується вказаними значеннями в якості своїх елементів, а його довжина дорівнює кількості вказаних аргументів.</p>

<p>Наступний приклад створює масив <code>coffees</code> (кава) з трьома елементами та довжиною, що дорівнює три:</p>

<pre class="brush: js notranslate">let coffees = ['Французька', 'Колумбійська', 'Кона'];</pre>

<div class="note">
<p><strong>Заувага:</strong> Літерал масиву - це тип <em>об'єктного ініціалізатора</em>. Дивіться <a href="/uk/docs/Web/JavaScript/Guide/Working_with_Objects#Використання_обєктних_ініціалізаторів" title="uk/docs/JavaScript/Guide/Working with Objects#Using Object Initializers">Використання об'єктних ініціалізаторів</a>.</p>
</div>

<p>Якщо масив створюється за допомогою літералів у скрипті верхнього рівня, JavaScript інтерпретує масив кожного разу, коли обчислює вираз, що містить літерал масиву. На додачу, літерал, що використовується у функції, створюється кожного разу, коли викликається функція.</p>

<div class="blockIndicator note">
<p><strong>Заувага:</strong>  Літерали масиву також є об'єктами <code>Array</code>. Більш детальну інформацію щодо об'єктів <code>Array</code> дивіться у статтях {{jsxref("Array")}} та <a href="/uk/docs/Web/JavaScript/Guide/Indexed_collections">Індексовані колекції</a>.</p>
</div>

<h4 id="Додаткові_коми_у_масивних_літералах">Додаткові коми у масивних літералах</h4>

<p>Вам не обов'язково вказувати всі елементи у масивному літералі. Якщо помістити дві коми поспіль, масив заповнить невказані елементи значеннями <code>undefined</code>. Наступний приклад створює масив <code>fish</code> (риба):</p>

<pre class="brush: js notranslate">let fish = ['Крилатка', , 'Лящ'];</pre>

<p>Цей масив має два елементи зі значеннями та один порожній елемент:</p>

<ul>
 <li><code>fish[0]</code> дорівнює "Крилатка",</li>
 <li><code>fish[1]</code> дорівнює <code>undefined</code></li>
 <li><code>fish[2]</code> дорівнює "Лящ"</li>
</ul>

<p>Якщо в кінці списку елементів ви додаєте кінцеву кому, вона ігнорується.</p>

<p>У наступному прикладі довжина масиву дорівнює трьом. Не існує елемента <code>myList[3]</code>. Усі інші коми у списку позначають новий елемент.</p>

<div class="note">
<p><strong>Заувага:</strong> коми в кінці можуть створювати помилки у старих версіях веб-переглядачів, тому краще їх видаляти.</p>
</div>

<pre class="brush: js notranslate">let myList = ['дім', , 'школа', ];</pre>

<p>У наступному прикладі довжина масиву становить чотири, а елементи <code>myList[0]</code> та <code>myList[2]</code> відсутні.</p>

<pre class="brush: js notranslate">let myList = [ ,'дім', , 'школа'];</pre>

<p>У наступному прикладі довжина масиву становить чотири, а елементи <code>myList[1]</code> та <code>myList[3]</code> відсутні. <strong>Ігнорується лише остання кома</strong>.</p>

<pre class="brush: js notranslate">let myList = ['дім', , 'школа', , ];</pre>

<p>Розуміння поведінки додаткових ком важливе для розуміння JavaScript як мови. </p>

<p>Однак, при написанні власного коду, варто однозначно оголошувати відсутні елементи як <code>undefined</code>. Це підвищить зрозумілість та надійність вашого коду.</p>

<h3 id="Булеві_літерали">Булеві літерали</h3>

<p>Тип Boolean має два значення літералів: <code>true</code> та <code>false</code>.</p>

<div class="blockIndicator note">
<p><strong>Будьте обережні:</strong> Не плутайте примітивні булеві значення <code>true</code> та <code>false</code> зі значеннями true та false об'єкта {{jsxref("Boolean")}}.</p>
Об'єкт Boolean - це обгортка навколо примітивного булевого типу даних. Дивіться {{jsxref("Boolean")}} для отримання додаткової інформації.</div>

<h3 id="Числові_літерали">Числові літерали</h3>

<p>Типи <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Число"><code>Number</code></a> та <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a> можна виразити у десятковій (основа 10), шістнадцятковій (основа 16), вісімковій (основа 8) та двійковій (основа 2) формі.</p>

<ul>
 <li><em>Десятковий</em> числовий літерал - це послідовність цифр без <code>0</code> (нуля) на початку.</li>
 <li>Початковий <code>0</code> (нуль) або <code>0o</code> (або <code>0O</code>) у числовому літералі вказує, що він заданий у <em>вісімковій </em>системі числення. Вісімкове число може включати лише цифри <code><em>0</em></code>–<code><em>7</em></code>.</li>
 <li>Символи <code><em>0x</em></code> (або <code>0X</code>) на початку вказують на <em>шістнадцяткове </em>представлення числа. Шістнадцяткове число може включати цифри (<code>0</code>–<code>9</code>) та літери <code>a</code> – <code>f</code> та <code>A</code> – <code>F</code>. (Регістр символу не має значення. Тому: <code>0xa</code> = <code>0xA</code> = <code>10</code> і <code>0xf</code> = <code>0xF</code> = <code>15</code>.)</li>
 <li>Символи <code>0b</code> (або <code>0B</code>) на початку вказують на <em>двійкове </em>представлення. Двійкові числа можуть включати лише цифри <code>0</code> і <code>1</code>.</li>
</ul>

<p>Деякі приклади числових літералів:</p>

<pre class="brush: js notranslate">0, 117, -345, 123456789123456789n             (десятковий, основа 10)
015, 0001, -0o77, 0o777777777777n             (вісімковий, основа 8)
0x1123, 0x00111, -0xF1A7, 0x123456789ABCDEFn  (шістнадцятковий, "hex" чи основа 16)
0b11, 0b0011, -0b11, 0b11101001010101010101n  (двійковий, основа 2)</pre>

<p>Для отримання додаткової інформації дивіться <a href="/uk/docs/Web/JavaScript/Reference/Lexical_grammar#Числові_літерали">Числові літерали в довідці про лексичну граматику.</a></p>

<h3 id="Літерали_з_рухомою_крапкою">Літерали з рухомою крапкою</h3>

<p>Літерал з рухомою крапкою може мати такі частини:</p>

<ul>
 <li>Десяткове ціле число, яке може мати знак ("<code>+</code>" або "<code>-</code>" перед ним),</li>
 <li>Десяткову крапку ("<code>.</code>"),</li>
 <li>Дробову частину (інше десяткове число),</li>
 <li>Порядок.</li>
</ul>

<p>Порядок позначається через "<code>e</code>" або "<code>E</code>", за яким іде ціле число, яке може мати знак ("<code>+</code>" або "<code>-</code>" перед ним). Літерал з рухомою крапкою повинен мати принаймні одну цифру, а також або десяткову крапку, або "<code>e</code>" (чи "<code>E</code>").</p>

<p>Якщо стисло, синтаксис наступний:</p>

<pre class="brush: js notranslate">[(+|-)][цифри].[цифри][(E|e)[(+|-)]цифри]</pre>

<p>Наприклад:</p>

<pre class="brush: js notranslate">3.1415926
-.123456789
-3.1E+12
.1e-23</pre>

<h3 id="Обєктні_літерали">Об'єктні літерали</h3>

<p>Об'єктні літерали - це список з нуля або більше пар імен властивостей та асоційованих з ними значень об'єкта, взятих у фігурні дужки  (<code>{}</code>).</p>

<div class="blockIndicator warning">
<p><strong>Не використовуйте об'єктні літерали на початку інструкції! </strong>Це призведе до помилки (або не поводитиметься так, як ви очікували), оскільки <code>{</code> буде інтерпретуватися як початок блоку.</p>
</div>

<p>Нижче наведений приклад об’єктного літералу. Перший елемент об'єкта <code>car</code> (автомобіль) визначає властивість <code>myCar</code> та присвоює йому новий рядок "<code>Saturn</code>"; другому елементу, властивості <code>getCar</code>, негайно присвоюється результат виклику функції <code>(carTypes("Honda"))</code>; третій елемент, властивість <code>special</code>, використовує існуючу змінну (<code>sales</code>).</p>

<pre class="brush: js notranslate">var sales = 'Toyota';

function carTypes(name) {
  if (name === 'Honda') {
    return name;
  } else {
    return "Вибачте, ми не продаємо автомобілі " + name + ".";
  }
}

var car = { myCar: 'Saturn', getCar: carTypes('Honda'), special: sales };

console.log(car.myCar);   // Saturn
console.log(car.getCar);  // Honda
console.log(car.special); // Toyota </pre>

<p>Крім того, ви можете використовувати числовий або рядковий літерал в якості імені властивості, чи вкладати один об'єкт у інший. У наступному прикладі використовуються ці можливості.</p>

<pre class="brush: js notranslate">var car = { manyCars: {a: 'Saab', b: 'Jeep'}, 7: 'Mazda' };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda</pre>

<p><span>Іменем властивості об'єкта може бути будь-який рядок, в тому числі порожній. Якщо ім'я властивості не є дозволеним <a href="/uk/docs/Glossary/ідентифікатор">ідентифікатором</a> JavaScript або числом, воно має бути записане в лапках.</span></p>

<p>До імен властивостей, які не є дозволеними ідентифікаторами, не можна звертатись через крапку (<code>.</code>), але <em>можна </em>звертатись та присвоювати значення за допомогою подібної до масиву нотації ("<code>[]</code>").</p>

<pre class="brush: js notranslate">var unusualPropertyNames = {
  '': 'Порожній рядок',
  '!': 'Бум!'
}
console.log(unusualPropertyNames.'');   // SyntaxError: Unexpected string
console.log(unusualPropertyNames['']);  // Порожній рядок
console.log(unusualPropertyNames.!);    // SyntaxError: Unexpected token !
console.log(unusualPropertyNames['!']); // Бум!</pre>

<h4 id="Покращені_обєктні_літерали">Покращені об'єктні літерали</h4>

<p>У ES2015 об'єктні літерали розширюються для підтримки встановлення прототипу при конструюванні, скороченого запису присвоєнь типу <code>foo: foo</code>, визначення методів, здійснення викликів <code>super</code> та обчислення імен властивостей з виразами.</p>

<p>Разом вони також зближують об'єктні літерали та оголошення класів (<code>class</code>) і дозволяють об'єктно-орієнтованому дизайну користуватися деякими з тих самих зручностей.</p>

<pre class="brush: js notranslate">var obj = {
    // __proto__
    __proto__: theProtoObj,
    // Скорочений запис для ‘handler: handler’
    handler,
    // Методи
    toString() {
     // Виклики super
     return 'd ' + super.toString();
    },
    // Обчислювані (динамічні) імена властивостей
    [ 'prop_' + (() =&gt; 42)() ]: 42
};</pre>

<h3 id="Літерали_регулярних_виразів_RegExp">Літерали регулярних виразів (RegExp)</h3>

<p>Літерал регулярного виразу (який докладно визначається <a href="/uk/docs/Web/JavaScript/Guide/Regular_Expressions">пізніше</a>) - це шаблон, записаний між слешами. Нижче наведено приклад літерала регулярного виразу:</p>

<pre class="brush: js notranslate">var re = /ab+c/;</pre>

<h3 id="Рядкові_літерали">Рядкові літерали</h3>

<p>Рядковий літерал - це нуль або більше символів всередині подвійних (<code>"</code>) або одинарних (<code>'</code>) лапок. Рядок повинен бути позначений лапками одного типу (тобто, або двома одинарними лапками, або двома подвійними лапками).</p>

<p>Нижче наведено приклади рядкових літералів:</p>

<pre class="brush: js notranslate">'раз'
"два"
'1234'
'один рядок \n другий рядок'
"Мар'яна має кота"</pre>

<p>Ви можете викликати будь-який з методів об'єкта {{jsxref("String")}} на рядковому літералі. JavaScript автоматично перетворює рядковий літерал на тимчасовий об'єкт String, викликає метод, а потім прибирає тимчасовий об'єкт String. Ви також можете використовувати властивість <code>String.length</code> з рядковим літералом:</p>

<pre class="brush: js notranslate">// Надрукує кількість символів у рядку, враховуючи пробіли.
console.log("Мар'яна має кота".length)  // В цьому випадку, 16.</pre>

<p>У ES2015 також доступні <em>шаблонні літерали</em>. Шаблонні літерали пишуться у зворотніх лапках  (<code>`</code>) (<a class="external external-icon" href="https://uk.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%B2%D1%96%D1%81_(%D0%B4%D1%96%D0%B0%D0%BA%D1%80%D0%B8%D1%82%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D0%B7%D0%BD%D0%B0%D0%BA)" rel="noopener">гравіс</a>) замість одинарних або подвйних лапок.</p>

<p>Шаблонні рядки надають синтаксичний цукор для конструювання рядків. (Це схоже на функції інтерполяції рядків у Perl, Python та інших).</p>

<p>За бажанням може бути додано тег, що дозволить налаштовувати побудову рядка, уникаючи атак типу впровадження або конструюючи структури даних більш високого рівня з вмісту рядка.</p>

<pre class="brush: js notranslate">// Створення базового рядкового літералу
`У JavaScript '\n' - це символ переводу рядка.`

// Багаторядковий запис
`У JavaScript шаблонні рядки можуть бути записані
у кількох рядках, а текст в одинарних
чи подвійних лапках не може.`

// Інтерполяція рядків
var name = 'Боб', time = 'сьогодні';
`Привіт, ${name}, як ти ${time}?`

// Створення префіксу HTTP-запиту, який інтерпретує заміни та конструювання
POST`http://foo.org/bar?a=${a}&amp;b=${b}
     Content-Type: application/json
     X-Credentials: ${credentials}
     { "foo": ${foo},
       "bar": ${bar}}`(myOnReadyStateChangeHandler);</pre>

<p>Вам варто використовувати рядкові літерали, якщо немає потреби використовувати конкретно об'єкт String. Дивіться {{jsxref("String")}} для більш детальної інформації про об'єкти <code>String</code>.</p>

<h4 id="Використання_спеціальних_символів_у_рядках">Використання спеціальних символів у рядках</h4>

<p>Окрім звичайних символів, ви можете також включати до рядків спеціальні символи, як показано в наступному прикладі.</p>

<pre class="brush: js notranslate">'один рядок \n другий рядок'</pre>

<p>Наступна таблиця наводить спеціальні символи, які можна використовувати у рядках JavaScript.</p>

<table class="standard-table">
 <caption>Таблиця: спеціальні символи JavaScript</caption>
 <thead>
  <tr>
   <th scope="col">Символ</th>
   <th scope="col">Значення</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>\0</code></td>
   <td>Нуль-символ</td>
  </tr>
  <tr>
   <td><code>\b</code></td>
   <td>Повернення на крок</td>
  </tr>
  <tr>
   <td><code>\f</code></td>
   <td>Зміна сторінки</td>
  </tr>
  <tr>
   <td><code>\n</code></td>
   <td>Новий рядок</td>
  </tr>
  <tr>
   <td><code>\r</code></td>
   <td>Повернення каретки</td>
  </tr>
  <tr>
   <td><code>\t</code></td>
   <td>Горизонтальна табуляція</td>
  </tr>
  <tr>
   <td><code>\v</code></td>
   <td>Вертикальна табуляція</td>
  </tr>
  <tr>
   <td><code>\'</code></td>
   <td>Апостроф або одинарні лапки</td>
  </tr>
  <tr>
   <td><code>\"</code></td>
   <td>Подвійні лапки</td>
  </tr>
  <tr>
   <td><code>\\</code></td>
   <td>Зворотній слеш</td>
  </tr>
  <tr>
   <td><code>\<em>XXX</em></code></td>
   <td>Символ у кодуванні Latin-1, який містить до трьох цифр у вісімковій системі числення <em>XXX</em> між <code>0</code> та <code>377</code>. Наприклад, <code>\251</code> - це вісімкова послідовність для знаку охорони авторського права.</td>
  </tr>
  <tr>
  </tr>
  <tr>
   <td><code>\x<em>XX</em></code></td>
   <td>Символ у кодуванні Latin-1, вказаний двома цифрами у шістнадцятковій системі числення <em>XX</em> між <code>00</code> та <code>FF</code>. Наприклад, <code>\xA9</code> - це шістнадцяткова послідовність  для знаку охорони авторського права.</td>
  </tr>
  <tr>
  </tr>
  <tr>
   <td><code>\u<em>XXXX</em></code></td>
   <td>Символ Юнікоду, вказаний чотирма цифрами у шістнадцятковій системі числення <em>XXXX</em>. Наприклад, <code>\u00A9</code> - це Юнікодова послідовність для знаку охорони авторського права. Дивіться <a href="/uk/docs/Web/JavaScript/Reference/Lexical_grammar#Рядкові_літерали">екрановані послідовності Юнікоду</a>.</td>
  </tr>
  <tr>
   <td><code>\u<em>{XXXXX}</em></code></td>
   <td>Екранування кодів символів Юнікоду. Наприклад, <code>\u{2F804}</code> - це те саме, що й прості екранування Юнікоду <code>\uD87E\uDC04</code>.</td>
  </tr>
 </tbody>
</table>

<h4 id="Екранування_символів">Екранування символів</h4>

<p>Для символів, не перелічених у таблиці, зворотній слеш перед символом ігнорується, але таке використання не рекомендоване, і його слід уникати.</p>

<p>Ви можете вставити лапки у рядок, поcтавивши перед ними зворотній слеш. Це називається <em>екрануванням</em> лапок. Наприклад:</p>

<pre class="brush: js notranslate">var quote = "Він читав \"Кремацію Сема МакҐі\" Р.Дж. Сервіса.";
console.log(quote);</pre>

<p>Результатом цього буде:</p>

<pre class="brush: js notranslate">Він читав "Кремацію Сема МакҐі" Р.Дж. Сервіса.</pre>

<p>Щоб включити у рядок сам зворотний слеш, ви маєте його екранувати. Наприклад, щоб присвоїти рядкові шлях до файлу <code>c:\temp</code>, використовуйте наступне:</p>

<pre class="brush: js notranslate">var home = 'c:\\temp';</pre>

<p>Ви також можете екранувати розрив рядка, поставивши перед ним зворотній слеш. І зворотній слеш, і розрив рядка видаляються зі значення рядка.</p>

<pre class="brush: js notranslate">var str = 'цей текст \
розбито \
на кілька \
рядків.'
console.log(str);   // цей текст розбито на кілька рядків.</pre>

<p>Хоча у JavaScript немає синтаксису "heredoc", ви можете наблизитися до нього, додавши в кінці кожного рядка екранування розриву рядка та екранування символа нового рядка:</p>

<pre class="brush: js notranslate">var poem =
'Roses are red,\n\
Violets are blue.\n\
Sugar is sweet,\n\
and so is foo.'</pre>

<p>ECMAScript 2015 вводить новий тип літералів, а саме <a href="/uk/docs/Web/JavaScript/Reference/Template_literals"><strong>шаблонні літерали</strong></a>. Це додає багато нових функцій, в тому числі багаторядковий запис!</p>

<pre class="brush: js notranslate" dir="rtl">var poem =
`Roses are red,
Violets are blue.
Sugar is sweet,
and so is foo.` </pre>

<h2 id="Більше_інформації">Більше інформації</h2>

<p>Цей розділ фокусується на базовому синтаксисі оголошень та типів. Щоб дізнатися більше про мовні конструкції JavaScript, дивіться також наступні розділи цього посібника:</p>

<ul>
 <li><a href="/uk/docs/Web/JavaScript/Guide/Control_flow_and_error_handling">Потік керування та обробка помилок</a></li>
 <li><a href="/uk/docs/Web/JavaScript/Guide/Loops_and_iteration">Цикли та ітерації</a></li>
 <li><a href="/uk/docs/Web/JavaScript/Guide/Functions">Функції</a></li>
 <li><a href="/uk/docs/Web/JavaScript/Guide/Вирази_та_оператори">Вирази та оператори</a></li>
</ul>

<p>У наступному розділі ми розглянемо конструкції потоку керування та обробку помилок.</p>

<p>{{PreviousNext("Web/JavaScript/Guide/Introduction", "Web/JavaScript/Guide/Control_flow_and_error_handling")}}</p>
