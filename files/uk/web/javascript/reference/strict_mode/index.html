---
title: Строгий режим
slug: Web/JavaScript/Reference/Strict_mode
tags:
  - ECMAScript5
  - JavaScript
  - Строгий режим
translation_of: Web/JavaScript/Reference/Strict_mode
---
<div>{{JsSidebar("More")}}</div>

<p>Строгий режим (<em>strict mode</em>) у <a class="external" href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript 5</a> — це спосіб використання обмеженого варіанта JavaScript. Строгий режим є не просто підмножиною JavaScript: це семантика, яка <em>навмисно</em> відрізняється від звичайного коду. Переглядачі, що не підтримують строгий режим, виконуватимуть його код у дещо інший спосіб, аніж ті переглядачі, що таку підтримку мають. Отже, перш ніж покладатися на строгий режим, перевірте наявність підтримки його окремих складників. Код у строгому режимі та код поза ним можуть співіснувати, тому скрипти можна переводити у строгий режим поступово.</p>

<p>Строгий режим вносить декілька змін до звичної семантики JavaScript. По-перше, деякі помилки, що в звичайному режимі лишаються непомітними, натомість у строгому режимі викидаються в явний спосіб. По-друге, строгий режим виправляє помилки, що ускладнюють або унеможливлюють виконання певних оптимізацій рушіями JavaScript: код у строгому режимі іноді можна змусити виконуватися швидше, ніж такий самий код у звичайному режимі. По-третє, строгий режим забороняє деякий синтаксис, який, скоріше за все, буде визначено у майбутніх версіях ECMAScript.</p>

<p>Дивіться "Перехід до строгого режиму" (<a href="/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode">transitioning to strict mode</a>), якщо бажаєте змінити свій код так, щоб він працював із обмеженим варіантом JavaScript.</p>

<div class="note">
<p>Іноді ви побачите посилання на стандартний, не строгий режим, як на “брудний режим”. Це неофіційний термін, але вам краще знати про нього, про всяк випадок.</p>
</div>

<h2 id="Виклик_строгого_режиму">Виклик строгого режиму</h2>

<p>Строгий режим застосовується до <em>цілих скриптів</em>, або до <em>індивідуальних функцій</em>. Він не застосовується до блочних виразів, замкнених у фігурних дужках {}; спроба застосувати його в такому контексті не дасть результату. <code>eval</code> код, <code>Function</code> код, атрибути обробника подій, рядки, що передаються у {{domxref("WindowTimers.setTimeout()")}}, і подібні до них є повноцінними скриптами, і виклик строгого режиму в них працює, як і очікується.</p>

<h3 id="Строгий_режим_у_скриптах">Строгий режим у скриптах</h3>

<p>Щоб увімкнути строгий режим у цілому скрипті, запишіть <em>точний</em> вираз “use strict”; (або ‘use strict’;) перед будь-якими іншими виразами.</p>

<pre class="brush: js">// Синтаксис строгого режиму для цілого скрипта
"use strict";
var v = "Привіт! Я скрипт у строгому режимі!";
</pre>

<p>Цей синтаксис приховує пастку, в яку <a class="link-https" href="https://bugzilla.mozilla.org/show_bug.cgi?id=579119">вже втрапив</a> <a class="link-https" href="https://bugzilla.mozilla.org/show_bug.cgi?id=627531">один великий сайт</a>: неможливо наосліп поєднати не суперечливі скрипти. Розглянемо об'єднання скрипту у строгому режимі із скриптом у звичайному режимі: вся конкатенація виходить у строгому режимі! Зворотнє теж правда: скрипт у звичайному режимі, поєднаний із скриптом у строгому режимі, призводить до звичайного режиму. Об'єднання скриптів у строгому та звичайному режимах є проблематичним. Тому рекомендується включати строгий режим у кожній функції окремо (принаймні, на час переміщення).</p>

<p>Ви також можете застосувати підхід із загортанням всього вмісту скрипту у функцію та наданням цій зовнішній функції строгого режиму. Це позбавляє проблеми конкатенації, але це означає, що вам доведеться явно експортувати будь-які глобальні змінні поза область видимості функції.</p>

<h3 id="Строгий_режим_у_функціях">Строгий режим у функціях</h3>

<p>Таким самим чином, щоб застосувати строгий режим у функції, напишіть <em>точний</em> вираз “use strict”; (або 'use strict';) у тілі функції перед будь-якими іншими виразами.</p>

<pre class="brush: js">function strict() {
  // Синтаксис строгого режиму на рівні функції
  'use strict';
  function nested() { return "І я також!"; }
  return "Привіт!  Я функція у строгому режимі!  " + nested();
}
function notStrict() { return "А я ні."; }
</pre>

<h2 id="Зміни_у_строгому_режимі">Зміни у строгому режимі</h2>

<p>Строгий режим змінює як синтаксис, так і поведінку під час виконання. Зміни загалом підпадають під такі категорії: зміни, що перетворюють похибки<font color="#ff0000"> </font>на помилки (такі, як помилки синтаксису під час виконання), зміни, що спрощують обчислення конкретної змінної для заданого використання імені, зміни, що спрощують <code>eval</code> та <code>arguments</code>, зміни, що спрощують написання “безпечного” коду JavaScript, а також зміни, що передбачають майбутню еволюцію ECMAScript.</p>

<h3 id="Перетворення_похибок_на_помилки">Перетворення похибок на помилки</h3>

<p>Строгий режим перетворює деякі раніше прийнятні похибки на помилки. JavaScript був розроблений таким чином, щоб бути простим для програмістів-початківців, й іноді позначає операції, які мали б бути помилками, як не помилкові. Іноді це вирішує невідкладну проблему, але іноді створює ще гірші проблеми в майбутньому. Строгий режим позначає ці похибки як помилки, що дозволяє виявляти їх та вчасно виправляти.</p>

<p>По-перше, строгий режим робить неможливим випадкове створення глобальних змінних. В звичайному режимі JavaScript неправильно написане ім'я змінної під час присвоювання створює нову властивість у глобальному об’єкті та продовжує “працювати” (хоча в майбутньому можливе не спрацювання: ймовірно, у новій версії JavaScript). Присвоювання, які могли випадково створити глобальні змінні, у строгому режимі генерують помилку:</p>

<pre class="brush: js">"use strict";
                       // Припускаючи, що глобальна змінна mistypedVariable
mistypedVariable = 17; // існує, ця строка згенерує помилку ReferenceError
                       // через неправильне написання змінної
</pre>

<p>По-друге, строгий режим змушує присвоювання, які б в іншому випадку непомітно не спрацювали, генерувати помилку. Наприклад, <code>NaN</code> є глобальною змінною, яку не можна редагувати. В нормальному коді присвоювання у <code>NaN</code> нічого не робить; розробник отримує неуспішний результат. У строгому режимі присвоювання у <code>NaN</code> викликає виняток. Будь-яке присвоювання, яке непомітно не спрацює у нормальному коді (присвоювання властивості, яку не можна редагувати, присвоювання властивості, яка має лише геттер, присвоювання нової властивості <a href="/uk/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" title="en-US/JavaScript/Reference/Global Objects/Object/preventExtensions">нерозширюваного</a> об'єкту) згенерує виняток у строгому режимі:</p>

<pre class="brush: js">"use strict";

// Присвоєння у властивість, яку не можна редагувати
var obj1 = {};
Object.defineProperty(obj1, "x", { value: 42, writable: false });
obj1.x = 9; // генерує помилку TypeError

// Присвоєння у властивість, яка має лише геттер
var obj2 = { get x() { return 17; } };
obj2.x = 5; // генерує помилку TypeError

// Присвоєння властивості нерозширюваного об'єкту
var fixed = {};
Object.preventExtensions(fixed);
fixed.newProp = "ohai"; // генерує помилку TypeError
</pre>

<p>По-третє, строгий режим генерує винятки при намаганні видалити властивість, яку не можна видаляти (раніше така спроба просто не мала б ніякого ефекту):</p>

<pre class="brush: js">"use strict";
delete Object.prototype; // генерує помилку TypeError
</pre>

<p>По-четверте, строгий режим до версії<font color="#ff0000"> </font>Gecko 34 вимагає, щоб усі властивості у літералі об’єкту були унікальними. В звичайному коді можливо дублювати імена властивостей, при цьому останній запис встановлює значення властивості. Але, оскільки лише останній запис має значення, дублювання — це просто джерело помилок, якщо в коді змінюється значення властивості не в останньому запису. Дублювання імен властивостей є синтаксичною помилкою у строгому режимі:</p>

<div class="note">
<p>Більше не працює у ECMAScript 2015 ({{bug(1041128)}}).</p>
</div>

<pre class="brush: js">"use strict";
var o = { p: 1, p: 2 }; // !!! синтаксична помилка
</pre>

<p>По-п’яте, строгий режим вимагає, щоб імена параметрів функцій були унікальними. В звичайному коді останній дубльований аргумент ховає попередні ідентично названі аргументи. Ці попередні аргументи лишаються доступними через <code>arguments[i]</code>, тому вони не остаточно недоступні. Однак, таке приховання не має сенсу і, скоріше за все, є небажаним (воно може, наприклад, ховати помилку у написанні), тому у строгому режимі дублювання імен аргументів є синтаксичною помилкою:</p>

<pre class="brush: js">function sum(a, a, c) { // !!! синтаксична помилка
  "use strict";
  return a + b + c; // неправильно, якщо виконати цей код
}
</pre>

<p>По-шосте, строгий режим у ECMAScript 5 забороняє вісімковий синтаксис. Вісімковий синтаксис не є частиною ECMAScript 5, але він підтримується у всіх веб-переглядачах додаванням нуля попереду вісімкового числа: <code>0644 === 420</code> and <code>"\045" === "%"</code>. У ECMAScript 5 вісімкове число підтримується з допомогою додавання "<code>0</code>o", тобто </p>

<pre class="brush: js">var a = 0o10; // ES2015: вісімкове число</pre>

<p>Програмісти-початківці вважають, що нуль попереду числа не має семантичного значення, тому вони використовують його для вирівнювання строки — але це змінює значення числа! Вісімковий синтаксис рідко використовується і може бути використаний помилково, тому строгий режим позначає вісімковий запис як синтаксичну помилку:</p>

<pre class="brush: js">"use strict";
var sum = 015 + // !!! синтаксична помилка
          197 +
          142;
</pre>

<p>По-сьоме, строгий режим у ECMAScript 5 забороняє присвоєння властивостей {{Glossary("primitive", "примітивним")}} значенням. Без строгого режиму, присвоєння таких властивостей просто ігнорується (no-op), однак, у строгому режимі генерується помилка {{jsxref("TypeError")}}.</p>

<pre class="brush: js">(function() {
"use strict";

false.true = "";         // TypeError
(14).sailing = "home";     // TypeError
"with".you = "far away"; // TypeError

})();</pre>

<h3 id="Спрощення_використання_змінних">Спрощення використання змінних</h3>

<p>Строгий режим спрощує прив'язку імен змінних до певних визначень змінних у коді. Багато оптимізацій компілятора покладаються на спроможність сказати, що змінна Х зберігається у <em>цій</em> локації: це критично для повної оптимізації кода JavaScript. Іноді JavaScript робить базову прив'язку імені до визначення змінної в коді неможливим до запуску коду. Строгий режим усуває більшість випадків, в яких це відбувається, тому компілятор може краще оптимізувати код у строгому режимі.</p>

<p>По-перше, строгий режим забороняє <code>with</code>. Проблема з <code>with</code> полягає в тому, що будь-яке ім’я всередині блоку може вказувати або на властивість об’єкта, який йому передають, або на змінну з поточної (або навіть з глобальної) області видимості під час виконання: неможливо знати наперед. Строгий режим робить <code>with</code> синтаксичною помилкою і не дає можливості імені з <code>with</code> посилатися на невідому локацію під час виконання:</p>

<pre class="brush: js">"use strict";
var x = 17;
with (obj) // !!! синтаксична помилка
{
  // Якби це не був строгий режим, була б це змінна x, або
  // це була б властивість obj.x?  Неможливо заздалегідь
  // сказати, не запустивши код, тому ім'я не можна
  // оптимізувати.
  x;
}
</pre>

<p>Проста альтернатива присвоювання об’єкта змінній з коротким ім’ям, з отриманням доступу до відповідної властивості через цю змінну, здатна замінити <code>with</code>.</p>

<p>По-друге, <a class="external" href="http://whereswalden.com/2011/01/10/new-es5-strict-mode-support-new-vars-created-by-strict-mode-eval-code-are-local-to-that-code-only/"><code>eval</code> у строгому режимі не додає нові змінні у поточну область видимості</a>. У звичайному коді <code>eval("var x;")</code> створює змінну <code>x</code> у області видимості поточної функції або глобального об'єкту. Це означає, що, в цілому, у функції, що містить виклик <code>eval</code> кожне ім’я, яке не посилається на аргумент або на локальну змінну, мусить бути прив'язане до певного оголошення під час виконання (тому що <code>eval</code> міг створити нову змінну, яка сховає зовнішню змінну). У строгому режимі <code>eval</code> створює змінні лише для коду, який обчислюється, тому <code>eval</code> не може впливати на те, посилається ім’я на зовнішню змінну, чи на якусь локальну змінну:</p>

<pre class="brush: js">var x = 17;
var evalX = eval("'use strict'; var x = 42; x");
console.assert(x === 17);
console.assert(evalX === 42);
</pre>

<p>Відповідно, якщо функція <code>eval</code> викликається виразом у вигляді <code>eval(...)</code> у строгому режимі, код буде оцінюватися як код у строгому режимі. Код може явно увімкнути строгий режим, але в цьому нема необхідності.</p>

<pre class="brush: js">function strict1(str) {
  "use strict";
  return eval(str); // str буде вважатися кодом у строгому режимі
}
function strict2(f, str) {
  "use strict";
  return f(str); // not eval(...): str матиме строгий режим тільки в тому
                 // випадку, якщо він його вмикає
}
function nonstrict(str) {
  return eval(str); // str матиме строгий режим тільки в тому випадку,
                    // якщо він його вмикає
}

strict1("'Код у строгому режимі!'");
strict1("'use strict'; 'Код у строгому режимі!'");
strict2(eval, "'Код у звичайному режимі.'");
strict2(eval, "'use strict'; 'Код у строгому режимі!'");
nonstrict("'Код у звичайному режимі.'");
nonstrict("'use strict'; 'Код у строгому режимі!'");
</pre>

<p>Таким чином, імена у <code>eval</code> коді строгого режиму поводяться ідентично іменам у строгому режимі, які не оцінюються як результат <code>eval</code>.</p>

<p>По-третє, строгий режим забороняє видалення простих імен. <code>delete name</code> у строгому режимі є синтаксичною помилкою:</p>

<pre class="brush: js">"use strict";

var x;
delete x; // !!! синтаксична помилка

eval("var y; delete y;"); // !!! синтаксична помилка</pre>

<h3 id="Спрощення_eval_та_arguments">Спрощення <code>eval</code> та <code>arguments</code></h3>

<p>Строгий режим робить <code>arguments</code> та <code>eval</code> менш химерно магічними. Обидва поводяться досить загадково в нормальному коді: <code>eval</code> для додавання або видалення зв’язків або для зміни значень зв’язків, та <code>arguments</code> з його індексованими властивостями в якості псевдонімів імен аргументів. Строгий режим робить величезний крок до поводження з <code>eval</code> та <code>arguments</code> як з ключовими словами, хоча остаточні зміни з’являться не раніше майбутнього видання ECMAScript.</p>

<p>По-перше, згідно з синтаксисом, імена <code>eval</code> та <code>arguments</code> не можуть бути прив’язані або отримати присвоєння. Всі спроби це зробити згенерують синтаксичні помилки:</p>

<pre class="brush: js">"use strict";
eval = 17;
arguments++;
++eval;
var obj = { set p(arguments) { } };
var eval;
try { } catch (arguments) { }
function x(eval) { }
function arguments() { }
var y = function eval() { };
var f = new Function("arguments", "'use strict'; return 17;");
</pre>

<p>По-друге, у строгому режимі властивості створених в ньому об’єктів <code>arguments</code> не є псевдонімами. У звичайному коді у функції із першим аргументом <code>arg</code>, зміна значення <code>arg</code> також змінює значення <code>arguments[0]</code>, і навпаки (крім випадку, коли аргументи відсутні, або <code>arguments[0]</code> було видалено). Об'єкти <code>arguments</code> у строгому режимі зберігають у функціях початкові аргументи на момент, коли функція була викликана. <code>arguments[i]</code> не відслідковує значення відповідного іменованого аргументу, також іменований аргумент не відслідковує значення відповідного <code>arguments[i]</code>.</p>

<pre class="brush: js">function f(a) {
  "use strict";
  a = 42;
  return [a, arguments[0]];
}
var pair = f(17);
console.assert(pair[0] === 42);
console.assert(pair[1] === 17);
</pre>

<p>По-третє, <code>arguments.callee</code> більше не підтримується. В звичайному коді <code>arguments.callee</code> посилається на замкнену функцію. Цей випадок використання дуже слабкий: просто назвіть цю функцію! Більше того, <code>arguments.callee</code> ґрунтовно перешкоджає оптимізаціям, наприклад, вбудові функції, тому що має бути можливість надати посилання на не вбудовану функцію, якщо трапляється <code>arguments.callee</code>. У функціях строгого режиму <code>arguments.callee</code> є властивістю, яку не можна видаляти, вона генерує помилку при присвоюванні або виклику:</p>

<pre class="brush: js">"use strict";
var f = function() { return arguments.callee; };
f(); // генерує помилку TypeError
</pre>

<h3 id="Убезпечення_JavaScript">"Убезпечення" JavaScript</h3>

<p>Строгий режим спрощує написання “безпечного” коду в JavaScript. Деякі веб-сайти зараз надають користувачам можливість писати код JavaScript, який буде виконуватися на цій сторінці <em>від імені інших користувачів</em>. JavaScript у веб-переглядачах може мати доступ до приватної інформації користувачів, тому такий код має бути частково перетворений перед виконанням, щоб контролювати доступ до забороненої функціональності. Гнучкість JavaScript робить це практично неможливим без купи перевірок під час виконання. Певні функції мови настільки розповсюджені, що перевірки під час виконання призводять до суттєвих втрат у продуктивності. Кілька вивертів строгого режиму, плюс вимога, щоб код JavaScript, наданий користувачем, був у строгому режимі і щоб він запускався певним чином, суттєво зменшують необхідність в таких перевірках.</p>

<p>По-перше, значення, що передається у функцію як <code>this,</code> в строгому режимі не зобов'язане бути об'єктом (т. зв. “обгорнуте” значення). У звичайній функції <code>this</code> завжди є об'єктом: це або переданий об'єкт, якщо функція викликається із <code>this</code>, що є об'єктом; обгорнуте значення, якщо функція викликається із логічним (Boolean), строковим (string) або числовим (number) <code>this</code>; або глобальний об'єкт, якщо функція викликається із <code>this, </code>що дорівнює <code>undefined</code> або <code>null</code> . (Використовуйте <a href="/uk/Web/JavaScript/Reference/Global_Objects/Function/call" title="en-US/JavaScript/Reference/Global_Objects/Function/call"><code>call</code></a>, <a href="/uk/Web/JavaScript/Reference/Global_Objects/Function/apply" title="en-US/JavaScript/Reference/Global_Objects/Function/apply"><code>apply</code></a>, або <a href="/uk/Web/JavaScript/Reference/Global_Objects/Function/bind" title="en-US/JavaScript/Reference/Global_Objects/Function/bind"><code>bind</code></a> щоб вказати конкретний <code>this</code>.) Автоматичне обгортання не лише призводить до втрат продуктивності. Викриття глобального об'єкту у веб-переглядачах є небезпечним, тому що глобальний об'єкт надає доступ до функціональності, яку “безпечний” JavaScript код має обмежувати. Таким чином, для функції у строгому режимі заданий <code>this</code> не обгортається у об'єкт, а якщо він не заданий, <code>this</code> буде мати значення <code>undefined</code>:</p>

<pre class="brush: js">"use strict";
function fun() { return this; }
console.assert(fun() === undefined);
console.assert(fun.call(2) === 2);
console.assert(fun.apply(null) === null);
console.assert(fun.call(undefined) === undefined);
console.assert(fun.bind(true)() === true);
</pre>

<p>Це означає, окрім іншого, що у веб-переглядачах більше неможливо посилатися на об'єкт <code>window</code> через <code>this</code> всередині функції строгого режиму.</p>

<p>По-друге, у строгому режимі більше неможливо “пройтися” через стек JavaScript за допомогою часто вживаних розширень ECMAScript. В звичайному коді із цими розширеннями, коли функція <code>fun</code> знаходиться у процесі виклику, <code>fun.caller</code> – це функція, яка останньою викликала <code>fun</code>, а <code>fun.arguments</code>– це аргументи для цього виклику <code>fun</code>. Обидва розширення є проблематичними для “безпечного” коду JavaScript, тому що вони дозволяють “безпечному” коду мати доступ до “привілейованих” функцій та їхніх (потенційно небезпечних) аргументів. Якщо <code>fun</code> знаходиться у строгому режимі, <code>fun.caller</code> та <code>fun.arguments</code> є властивостями, які не можна видаляти, і генерують помилку під час присвоєння або виклику:</p>

<pre class="brush: js">function restricted()
{
  "use strict";
  restricted.caller;    // викидає TypeError
  restricted.arguments; // викидає TypeError
}
function privilegedInvoker()
{
  return restricted();
}
privilegedInvoker();
</pre>

<p>По-третє, <code>arguments</code> у строгому режимі функції більше не надають доступу до відповідних змінних викликаної функції. В деяких старих версіях ECMAScript <code>arguments.caller</code> був об'єктом, чиї властивості були псевдонімами змінних у цій функції. Це <a class="external" href="http://stuff.mit.edu/iap/2008/facebook/">небезпечно</a>, тому що порушує можливість приховувати привілейовані значення через абстракцію функції; це також перешкоджає більшості оптимізацій. З цих причин сучасні переглядачі не мають цієї можливості. Тим не менш, через свою історичну функціональність, <code>arguments.caller</code> у функції строгого режиму також є властивістю, яку не можна видаляти, і генерує помилку під час присвоєння або виклику:</p>

<pre class="brush: js">"use strict";
function fun(a, b)
{
  "use strict";
  var v = 12;
  return arguments.caller; // генерує помилку TypeError
}
fun(1, 2); // не викриває v (або a, або b)
</pre>

<h3 id="Прокладання_шляху_для_майбутніх_версій_ECMAScript">Прокладання шляху для майбутніх версій ECMAScript</h3>

<p>Майбутні версії ECMAScript, скоріше за все, запропонують новий синтаксис, а строгий режим у ECMAScript 5 застосовує деякі обмеження, щоб спростити перехід. Буде простіше внести деякі зміни, якщо основи цих змін заборонені у строгому режимі.</p>

<p>По-перше, у строгому режимі деякі ідентифікатори стають зарезервованими ключовими словами. Ці слова: <code>implements</code>, <code>interface</code>, <code>let</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>, та <code>yield</code>. Тоді у строгому режимі ви не зможете називати ними або використовувати змінні або аргументи з такими іменами.</p>

<pre class="brush: js">function package(protected) { // !!!
  "use strict";
  var implements; // !!!

  interface: // !!!
  while (true) {
    break interface; // !!!
  }

  function private() { } // !!!
}
function fun(static) { 'use strict'; } // !!!

</pre>

<p>Два застереження для Mozilla: по-перше, якщо ваш код використовує JavaScript версії 1.7 або вище (наприклад, у коді хрома, або при використанні <code>&lt;script type=""&gt;</code>) та використовує строгий режим, <code>let</code> та <code>yield</code> матимуть функціональність, яку вони мали з тих пір, як ці ключові слова були вперше введені. Але код у строгому режимі у мережі, завантажений з допомогою <code>&lt;script src=""&gt;</code> або <code>&lt;script&gt;...&lt;/script&gt;</code>, не зможуть використовувати <code>let</code>/<code>yield</code> як ідентифікатори. По-друге, в той час, як ES5 безумовно резервує слова <code>class</code>, <code>enum</code>, <code>export</code>, <code>extends</code>, <code>import</code>, та <code>super</code>, раніше Firefox 5 Mozilla резервував їх лише у строгому режимі.</p>

<p>По-друге, <a class="external" href="http://whereswalden.com/2011/01/24/new-es5-strict-mode-requirement-function-statements-not-at-top-level-of-a-program-or-function-are-prohibited/">строгий режим забороняє функціональні вирази не на верхньому рівні скрипта чи функції</a>. В звичайному коді в переглядачах функціональні вирази дозволені “будь-де”. <em>Це не є частиною</em><em>ES5 (</em><em>або навіть</em><em>ES3)!</em> Це розширення з несумісною семантикою у різних переглядачах. Є надія, що в майбутніх версіях ECMAScript буде введено нову семантику для функціональних виразів не на верхньому рівні скрипта або функції. <a class="external" href="http://wiki.ecmascript.org/doku.php?id=conventions:no_non_standard_strict_decls">Заборона таких функціональних виразів у строгому режимі</a> "розчищає поле" для специфікації майбутнього випуску ECMAScript:</p>

<pre class="brush: js">"use strict";
if (true) {
  function f() { } // !!! синтаксична помилка
  f();
}

for (var i = 0; i &lt; 5; i++) {
  function f2() { } // !!! синтаксична помилка
  f2();
}

function baz() { // кошерно
  function eit() { } // теж кошерно
}
</pre>

<p>Ця заборона не є правильною для строгого режиму, тому що такі функціональні вирази є розширенням базового ES5. Але це рекомендація комітету ECMAScript, і бразуери будуть її впроваджувати.</p>

<h2 id="Строгий_режим_у_веб-переглядачах">Строгий режим у веб-переглядачах</h2>

<p>У більшості переглядачів в наш час реалізовано строгий режим. Однак, не покладайтеся на нього наосліп, оскільки досі існує велика кількість <a class="external" href="http://caniuse.com/use-strict" rel="external" title="caniuse.com availability of strict mode">версій переглядачів, які лише частково підтримують строгий режим </a>або взагалі його не підтримують (наприклад, Internet Explorer нижче 10-ї версії!). <em>Строгий режим змінює семантику.</em> Покладання на строгий режим призведе до численних помилок у переглядачах, в яких не реалізовано строгий режим. Використовуйте строгий режим з обережністю, та, опираючись на строгий режим, підстраховуйтесь тестуванням функціональності, яке перевірить, чи реалізовані відповідні частини строгого режиму. Нарешті, переконайтеся, що <em>протестували свій код у переглядачах, які підтримують та не підтримують строгий режим</em>. Якщо ви тестуєте лише у тих переглядачах, які не підтримують строгий режим, ви, ймовірно, будете мати проблеми у переглядачах, які його підтримують, та навпаки.</p>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Специфікація</th>
   <th scope="col">Статус</th>
   <th scope="col">Коментар</th>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-10.1.1', 'Strict Mode Code')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>Базове визначення. Дивіться також: <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-C">Strict mode restriction and exceptions</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-strict-mode-code', 'Strict Mode Code')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-mode-of-ecmascript">Strict mode restriction and exceptions</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-strict-mode-code', 'Strict Mode Code')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td><a href="https://tc39.github.io/ecma262/#sec-strict-mode-of-ecmascript">Strict mode restriction and exceptions</a></td>
  </tr>
 </tbody>
</table>

<h2 id="Дивіться_також">Дивіться також</h2>

<ul>
 <li><a class="external" href="http://whereswalden.com/2010/09/08/new-es5-strict-mode-support-now-with-poison-pills/" title="http://whereswalden.com/2010/09/08/new-es5-strict-mode-support-now-with-poison-pills/">Where's Walden? » New ES5 strict mode support: now with poison pills!</a></li>
 <li><a class="external" href="http://whereswalden.com/2011/01/24/new-es5-strict-mode-requirement-function-statements-not-at-top-level-of-a-program-or-function-are-prohibited/" title="http://whereswalden.com/2011/01/24/new-es5-strict-mode-requirement-function-statements-not-at-top-level-of-a-program-or-function-are-prohibited/">Where's Walden? » New ES5 strict mode requirement: function statements not at top level of a program or function are prohibited</a></li>
 <li><a class="external" href="http://whereswalden.com/2011/01/10/new-es5-strict-mode-support-new-vars-created-by-strict-mode-eval-code-are-local-to-that-code-only/" title="http://whereswalden.com/2011/01/10/new-es5-strict-mode-support-new-vars-created-by-strict-mode-eval-code-are-local-to-that-code-only/">Where's Walden? » New ES5 strict mode support: new vars created by strict mode eval code are local to that code only</a></li>
 <li><a href="http://qnimate.com/javascript-strict-mode-in-nutshell/">JavaScript "use strict" tutorial for beginners.</a></li>
 <li><a class="external" href="http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/" title="http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/">John Resig - ECMAScript 5 Strict Mode, JSON, and More</a></li>
 <li><a class="external" href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/">ECMA-262-5 in detail. Chapter 2. Strict Mode.</a></li>
 <li><a class="external" href="http://kangax.github.io/compat-table/es5/#Strict_mode">Strict mode compatibility table</a></li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode">Transitioning to strict mode</a></li>
</ul>
