---
title: Ініціалізатор об’єкта
slug: Web/JavaScript/Reference/Operators/Ініціалізація_об’єктів
tags:
  - ECMAScript 2015
  - JSON
  - JavaScript
  - Об'єкт
  - властивості
  - літерал
  - методи
  - мутація
  - обчислені
translation_of: Web/JavaScript/Reference/Operators/Object_initializer
---
<div>{{JsSidebar("Operators")}}</div>

<p>Об'єкти можна ініціалізувати через <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>new Object()</code></a>, <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a></code>, або за допомогою <em>літеральної</em> нотації (нотації <em>ініціалізатора</em>). Ініціалізатор об'єкта - це список з нуля або більше розділених комою пар імен властивостей та асоційованих з ними значень об'єкта, записаних у фігурних дужках (<code>{}</code>).</p>

<p>{{EmbedInteractiveExample("pages/js/expressions-objectinitializer.html", "taller")}}</p>

<div class="hidden">
<p>The source for this interactive example is stored in a GitHub repository. If you'd like to contribute to the interactive examples project, please clone <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> and send us a pull request.</p>
</div>

<h2 id="Синтаксис">Синтаксис</h2>

<pre class="brush: js notranslate">let o = {}
let o = {a: 'няв', b: 42, c: {}}

let a = 'няв', b = 42, c = {}
let o = {a: a, b: b, c: c}

let o = {
  <var>property: function </var>([<var>parameters</var>]) {},
  get <var>property</var>() {},
  set <var>property</var>(<var>value</var>) {}
};
</pre>

<h3 id="Нові_позначення_у_ECMAScript_2015">Нові позначення у ECMAScript 2015</h3>

<p>Будь ласка, перевірте підтримку цих позначень у таблиці сумісностей. У тих середовищах, де вони не підтримуються, вони призведуть до синтаксичних помилок.</p>

<pre class="brush: js notranslate">// Скорочений запис імен властивостей (ES2015)
let a = 'привіт', b = 42, c = {};
let o = {a, b, c}

// Скорочений запис імен методів (ES2015)
let o = {
  <var>property</var>([<var>parameters</var>]) {}
}

// Обчислювані імена властивостей (ES2015)
let prop = 'foo'
let o = {
  [prop]: 'як',
  ['b' + 'ar']: 'справи'
}</pre>

<h2 id="Опис">Опис</h2>

<p>Ініціалізатор об'єкта - це вираз, який описує ініціалізацію {{jsxref("Object","об'єкта")}}. Об'єкт складається з <em>властивостей</em>, які описують цей об'єкт. Значення властивостей об'єкта можуть містити або {{Glossary("primitive","прості")}} типи даних, або інші об'єкти.</p>

<h3 id="Літеральна_нотація_обєкта_та_JSON">Літеральна нотація об'єкта та JSON</h3>

<p>Літеральна нотація об'єкта - це не те саме, що запис об'єктів JavaScript (<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation, <a href="/uk/docs/Glossary/JSON">JSON</a>). Хоча вони схожі, між ними є кілька відмінностей:</p>

<ul>
 <li>JSON дозволяє визначення властивості <em>тільки</em> у форматі <code>"property": value</code>. Ім'я властивості має бути записане у подвійних лапках, а визначення не може бути скороченим.</li>
 <li>У JSON значення можуть бути тільки рядками, числами, масивами, <code>true</code>, <code>false</code>, <code>null</code> або іншими об'єктами (JSON).</li>
 <li>Функція (дивіться "Визначення методів") не може бути присвоєна як значення у JSON.</li>
 <li>Об'єкти типу {{jsxref("Date")}} перетворяться на рядок після виклику {{jsxref("JSON.parse()")}}.</li>
 <li>{{jsxref("JSON.parse()")}} відхилить обчислювані імена властивостей, буде викинута помилка.</li>
</ul>

<h2 id="Приклади">Приклади</h2>

<h3 id="Створення_обєктів">Створення об'єктів</h3>

<p>Порожній об'єкт без властивостей може бути створений так:</p>

<pre class="brush: js notranslate">let object = {}</pre>

<p>Однак, перевагою <em>літералу</em> або <em>ініціалізатора</em> об'єкта є те, що ви можете швидко створити об'єкт з властивостями всередині фігурних дужок. Ви просто позначаєте список пар <code>key: value</code>, розділених комами.</p>

<p>Наступний код створює об'єкт з трьома властивостями, його ключами є <code>"foo"</code>, <code>"age"</code> та <code>"baz"</code>. Значеннями цих ключів є рядок <code>"bar"</code>, число <code>42</code>, а третя властивість має інший об'єкт в якості свого значення.</p>

<pre class="brush: js notranslate">let object = {
  foo: 'bar',
  age: 42,
  baz: {myProp: 12}
}</pre>

<h3 id="Доступ_до_властивостей">Доступ до властивостей</h3>

<p>Коли ви створили об'єкт, ви можете захотіти прочитати чи змінити його. До властивостей об'єкта можна звертатись, використовуючи крапкову нотацію або дужкову нотацію. Читайте <a href="/uk/docs/Web/JavaScript/Reference/Operators/Property_Accessors">Доступ до властивостей</a>, щоб дізнатись більше.</p>

<pre class="brush: js notranslate">object.foo // "bar"
object['age'] // 42

object.foo = 'baz'
</pre>

<h3 id="Визначення_властивостей">Визначення властивостей</h3>

<p>Ми вже дізнались, як позначати властивості за допомогою синтаксису ініціалізатора. Часто у коді є змінні, які ви б хотіли використати в об'єкті. Ви побачите код на зразок такого:</p>

<pre class="brush: js notranslate">let a = 'foo',
    b = 42,
    c = {};

let o = {
  a: a,
  b: b,
  c: c
}</pre>

<p>У ECMAScript 2015 є коротше позначення, яке робить те саме:</p>

<pre class="brush: js notranslate">let a = 'foo',
    b = 42,
    c = {};

// Скорочений запис імен властивостей (ES2015)
let o = {a, b, c}

// Іншими словами,
console.log((o.a === {a}.a)) // true
</pre>

<h4 id="Дублювання_імен_властивостей">Дублювання імен властивостей</h4>

<p>Якщо використовуються однакові імена властивостей, друга властивість перепише першу.</p>

<pre class="brush: js notranslate">var a = {x: 1, x: 2};
console.log(a); // {x: 2}
</pre>

<p>У строгому режимі ECMAScript 5 дублювання імен властивостей вважалося помилкою {{jsxref("SyntaxError")}}. З появою обчислюваних імен властивостей, що робило дублювання можливим під час виконання, це обмеження було прибране з ECMAScript 2015.</p>

<pre class="brush: js notranslate">function haveES2015DuplicatePropertySemantics() {
  'use strict';
  try {
    ({prop: 1, prop: 2});

    // Помилка не викидається, дублікати дозволені у строгому режимі
    return true;
  } catch(e) {
    // Помилка викидається, дублікати заборонені у строгому режимі
    return false;
  }
}</pre>

<h3 id="Визначення_методів">Визначення методів</h3>

<p>Властивість об'єкта може також посилатись на <a href="/uk/docs/Web/JavaScript/Reference/Functions">функцію</a> або <a href="/uk/docs/Web/JavaScript/Reference/Functions/get">гетер</a> чи <a href="/uk/docs/Web/JavaScript/Reference/Functions/set">сетер</a>.</p>

<pre class="brush: js notranslate">let o = {
  <var>property: function </var>([<var>parameters</var>]) {},
  get <var>property</var>() {},
  set <var>property</var>(<var>value</var>) {}
}</pre>

<p>У ECMAScript 2015 доступне скорочене позначення, тому ключове слово "<code>function</code>" більше не є обов'язковим.</p>

<pre class="brush: js notranslate">// Скорочений запис імен методів (ES2015)
let o = {
  <var>property</var>([<var>parameters</var>]) {},
}</pre>

<p>У ECMAScript 2015 є можливість стисло визначати властивості, значеннями яких є функції-генератори:</p>

<pre class="brush: js notranslate">let o = {
  *<var>generator</var>() {
    ...........
  }
};</pre>

<p>Що є еквівалентним цьому позначенню в стилі ES5 (але зауважте, що у ECMAScript 5 немає генераторів):</p>

<pre class="brush: js notranslate">let o = {
  generator<var>: function* </var>() {
    ...........
  }
}</pre>

<p>Більше інформації та прикладів щодо методів дивіться у статті <a href="/uk/docs/Web/JavaScript/Reference/Functions/Method_definitions">визначення методів</a>.</p>

<h3 id="Обчислювані_імена_властивостей">Обчислювані імена властивостей</h3>

<p>Починаючи з ECMAScript 2015, синтаксис об'єктного ініціалізатора також підтримує обчислювані імена властивостей. Це дозволяє розташувати вираз у квадратних дужках <code>[]</code>, і він буде обчислений як ім'я властивості. Цей синтаксис є аналогічним дужковій нотації у <a href="/uk/docs/Web/JavaScript/Reference/Operators/Property_Accessors">доступі до властивостей</a>, який ви вже могли використовувати, щоб читати та встановлювати властивості. Тепер ви можете використовувати такий самий синтаксис і для об'єктних літералів:</p>

<pre class="brush: js notranslate">// Обчислювані імена властивостей (ES2015)
let i = 0
let a = {
  ['foo' + ++i]: i,
  ['foo' + ++i]: i,
  ['foo' + ++i]: i
}

console.log(a.foo1) // 1
console.log(a.foo2) // 2
console.log(a.foo3) // 3

let param = 'size'
let config = {
  [param]: 12,
  ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4
}

console.log(config) // {size: 12, mobileSize: 4}</pre>

<h3 id="Розкладені_властивості">Розкладені властивості</h3>

<p>Пропозиція <a href="https://github.com/tc39/proposal-object-rest-spread">Rest/Spread Properties for ECMAScript</a> (стадія 4) додає <a href="/uk/docs/Web/JavaScript/Reference/Operators/Spread_syntax">розкладені</a> властивості до об'єктних літералів. Ця функціональність копіює особисті перелічувані властивості з наданого об'єкта у новий об'єкт.</p>

<p>Дрібне клонування (не включає <code>prototype</code>) чи злиття об'єктів тепер можливе з використанням синтаксису, коротшого, ніж {{jsxref("Object.assign()")}}.</p>

<pre class="brush: js notranslate">let obj1 = { foo: 'bar', x: 42 }
let obj2 = { foo: 'baz', y: 13 }

let clonedObj = { ...obj1 }
// Object { foo: "bar", x: 42 }

let mergedObj = { ...obj1, ...obj2 }
// Object { foo: "baz", x: 42, y: 13 }</pre>

<p>Зауважте, що {{jsxref("Object.assign()")}} запускає <a href="/uk/docs/Web/JavaScript/Reference/Functions/set">сетери</a>, а оператор розкладу ні!</p>

<h3 id="Мутація_прототипу">Мутація прототипу</h3>

<p>Визначення властивості виду <code>__proto__: value</code> чи <code>"__proto__": value</code> не створює властивість з іменем <code>__proto__</code>. Замість цього, якщо надане значення є об'єктом чи <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>, воно змінює <code>[[Prototype]]</code> створеного об'єкта на це значення. (Якщо значення не є об'єктом чи null, об'єкт не змінюється.)</p>

<pre class="brush: js notranslate">let obj1 = {};
assert(Object.getPrototypeOf(obj1) === Object.prototype);

let obj2 = {__proto__: null};
assert(Object.getPrototypeOf(obj2) === null);

let protoObj = {};
let obj3 = {'__proto__': protoObj};
assert(Object.getPrototypeOf(obj3) === protoObj);

let obj4 = {__proto__: 'не об\'єкт чи null'};
assert(Object.getPrototypeOf(obj4) === Object.prototype);
assert(!obj4.hasOwnProperty('__proto__'));
</pre>

<p>У об'єктному літералі дозволена лише одна мутація: декілька мутацій прототипу є синтаксичною помилкою.</p>

<p>Визначення властивостей, які не використовують нотацію з двокрапкою, не є мутаціями прототипу: вони є визначеннями властивостей, які поводяться ідентично до схожих визначень, що використовують будь-яке інше ім'я.</p>

<pre class="brush: js notranslate">let __proto__ = 'змінна';

let obj1 = {__proto__};
assert(Object.getPrototypeOf(obj1) === Object.prototype);
assert(obj1.hasOwnProperty('__proto__'));
assert(obj1.__proto__ === 'змінна');

let obj2 = {__proto__() { return 'привіт'; }};
assert(obj2.__proto__() === 'привіт');

let obj3 = {['__prot' + 'o__']: 17};
assert(obj3.__proto__ === 17);
</pre>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Специфікація</th>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-object-initializer', 'Object Initializer')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="Сумісність_з_веб-переглядачами">Сумісність з веб-переглядачами</h2>

<div class="hidden">
<p>The compatibility table on this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</p>
</div>

<p>{{Compat("javascript.operators.object_initializer")}}</p>

<h2 id="Див._також">Див. також</h2>

<ul>
 <li><a href="/uk/docs/Web/JavaScript/Reference/Operators/Property_Accessors">Доступ до властивостей</a></li>
 <li><code><a href="/uk/docs/Web/JavaScript/Reference/Functions/get">get</a></code> / <code><a href="/uk/docs/Web/JavaScript/Reference/Functions/set">set</a></code></li>
 <li><a href="/uk/docs/Web/JavaScript/Reference/Functions/Method_definitions">Визначення методів</a></li>
 <li><a href="/uk/docs/Web/JavaScript/Reference/Lexical_grammar">Лексична граматика</a></li>
</ul>
