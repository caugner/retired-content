---
title: Оператори порівняння
slug: Web/JavaScript/Reference/Operators/Оператори_порівняння
tags:
  - JavaScript
  - Довідка
  - Оператор
translation_of: Web/JavaScript/Reference/Operators
translation_of_original: Web/JavaScript/Reference/Operators/Comparison_Operators
---
<div>{{jsSidebar("Operators")}}</div>

<p>JavaScript має як строге порівняння, так і порівняння з перетворенням типів. Строге порівняння (<code>===</code>) є істинним лише в тому випадку, якщо операнди мають однаковий тип, а їхній зміст співпадає. Найчастіше вживане абстрактне порівняння (<code>==</code>) приводить операнди до спільного типу перед виконанням порівняння. Для абстрактних порівнянь (наприклад, <code>&lt;=</code>) операнди спочатку приводяться до простих типів, потім приводяться до спільного типу, а вже тоді порівнюються.</p>

<p>Рядки порівнюються на основі стандартного лексикографічного упорядкування, використовуючи значення Unicode.</p>

<p>{{EmbedInteractiveExample("pages/js/expressions-comparisonoperators.html")}}</p>

<div class="hidden">
<p>The source for this interactive example is stored in a GitHub repository. If you'd like to contribute to the interactive examples project, please clone <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> and send us a pull request.</p>
</div>

<p>Особливості порівнянь:</p>

<ul>
 <li>Два рядки строго рівні, якщо мають однакову послідовність символів, однакову довжину та однакові символи на відповідних позиціях.</li>
 <li>Два числа строго рівні, якщо вони чисельно рівні (мають однакове числове значення). <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/NaN" title="NaN">NaN</a> не дорівнює нічому, в тому числі NaN. Додатні та від'ємні нулі дорівнюють один одному.</li>
 <li>Два булеві операнди строго рівні, якщо обидва є <code>true</code>, або обидва є <code>false</code>.</li>
 <li>Два окремі об'єкти ніколи не є рівними ні при строгому, ні при абстрактному порівнянні.</li>
 <li>Вираз, що порівнює об'єкти, істинний лише тоді, коли операнди посилаються на один і той самий об'єкт.</li>
 <li>Типи Null та Undefined строго рівні собі та абстрактно рівні один одному.</li>
</ul>

<h2 id="Оператори_рівності">Оператори рівності</h2>

<h3 id="Рівність"><a name="Equality">Рівність (==)</a></h3>

<p>Оператор рівності перетворює операнди, якщо вони <strong>не однакового типу</strong>, і після цього застосовує строге порівняння. Якщо <strong>обидва операнди є об'єктами</strong>, JavaScript порівнює внутрішні посилання, які є рівними, якщо операнди посилаються на один і той самий об'єкт у пам'яті.</p>

<h4 id="Синтаксис">Синтаксис</h4>

<pre class="syntaxbox">x == y
</pre>

<h4 id="Приклади">Приклади</h4>

<pre class="brush: js">1    ==  1         // true
'1'  ==  1         // true
1    == '1'        // true
0    == false      // true
0    == null       // false
var object1 = {'key': 'value'}, object2 = {'key': 'value'};
object1.key == object2.key // true
0    == undefined  // false
null == undefined  // true
</pre>

<h3 id="Нерівність_!"><a name="Inequality">Нерівність (!=)</a></h3>

<p>Оператор нерівності повертає <em>true</em>,  якщо операнди не є рівними. Якщо два операнда <strong>не належать до одного типу</strong>, JavaScript намагається привести операнди до відповідного типу для порівняння. Якщо <strong>обидва операнда є об'єктами</strong>, JavaScript порівнює внутрішні посилання, які є нерівними, якщо операнди посилаються на різні об'єкти у пам'яті.</p>

<h4 id="Синтаксис_2">Синтаксис</h4>

<pre class="syntaxbox">x != y</pre>

<h4 id="Приклади_2">Приклади</h4>

<pre class="brush: js">1 !=   2     // true
1 !=  '1'    // false
1 !=  "1"    // false
1 !=  true   // false
0 !=  false  // false
</pre>

<h3 id="Ідентичність_строга_рівність"><a name="Identity">Ідентичність / строга рівність (===)</a></h3>

<p>Оператор ідентичності повертає true, якщо операнди строго рівні (див. вище) <strong>без приведення типів</strong>. </p>

<h4 id="Синтаксис_3">Синтаксис</h4>

<pre class="syntaxbox">x === y</pre>

<h4 id="Приклади_3">Приклади</h4>

<pre class="brush: js ">3 === 3   // true
3 === '3' // false
var object1 = {'key': 'value'}, object2 = {'key': 'value'};
object1 === object2 //false</pre>

<h3 id="Неідентичність_строга_нерівність_!"><a name="Nonidentity">Неідентичність / строга нерівність (!==)</a></h3>

<p>Оператор неідентичності повертає true, якщо операнди <strong>не є рівними та/або не однакового типу</strong>.</p>

<h4 id="Синтаксис_4">Синтаксис</h4>

<pre class="syntaxbox">x !== y</pre>

<h4 id="Приклади_4">Приклади</h4>

<pre class="brush: js">3 !== '3' // true
4 !== 3   // true
</pre>

<h2 id="Оператори_відношення">Оператори відношення</h2>

<p>Кожен з цих операторів буде <a href="/uk/docs/Glossary/Type_coercion">примусово приведений</a> до простої величини перед порівнянням. Якщо обидва перетворюються на рядки, вони порівнюються з використанням лексикографічного порядку, інакше вони будуть перетворені на числа для порівняння. Порівняння із <code>NaN</code> завжди поверне <code>false</code>.</p>

<h3 id="Більше_ніж_>"><a name="Greater_than_operator">Більше ніж (&gt;)</a></h3>

<p>Оператор <em>більше ніж </em>повертає true, якщо значення лівого операнда більше за значення правого операнда.</p>

<h4 id="Синтаксис_5">Синтаксис</h4>

<pre class="syntaxbox">x &gt; y</pre>

<h4 id="Приклади_5">Приклади</h4>

<pre class="brush: js">4 &gt; 3 // true
</pre>

<h3 id="Більше_чи_дорівнює_>"><a name="Greater_than_or_equal_operator">Більше чи дорівнює (&gt;=)</a></h3>

<p>Оператор <em>більше чи дорівнює</em> повертає true, якщо значення лівого операнда більше, або дорівнює значенню правого операнда.</p>

<h4 id="Синтаксис_6">Синтаксис</h4>

<pre class="syntaxbox"> x &gt;= y</pre>

<h4 id="Приклади_6">Приклади</h4>

<pre class="brush: js">4 &gt;= 3 // true
3 &gt;= 3 // true
</pre>

<h3 id="Менше_ніж_&lt;"><a name="Less_than_operator">Менше ніж (&lt;)</a></h3>

<p>Оператор <em>менше ніж</em> повертає true, якщо значення лівого операнда менше значення правого операнда.</p>

<h4 id="Синтаксис_7">Синтаксис</h4>

<pre class="syntaxbox"> x &lt; y</pre>

<h4 id="Приклади_7">Приклади</h4>

<pre class="brush: js">3 &lt; 4 // true
</pre>

<h3 id="Менше_чи_дорівнює_&lt;"><a id="Less_than_or_equal_operator" name="Less_than_or_equal_operator">Менше чи дорівнює (&lt;=)</a></h3>

<p>Оператор <em>менше чи дорівнює</em> повертає true, якщо значення лівого операнда менше або дорівнює значенню правого операнда.</p>

<h4 id="Синтаксис_8">Синтаксис</h4>

<pre class="syntaxbox"> x &lt;= y</pre>

<h4 id="Приклади_8">Приклади</h4>

<pre class="brush: js">3 &lt;= 4 // true
</pre>

<h2 id="Застосування_операторів_порівняння">Застосування операторів порівняння</h2>

<p>Стандартні оператори рівності (<code>==</code> та <code>!=</code>) використовують <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">алгоритм абстрактної рівності</a> для порівняння двох операндів. Якщо операнди належать до різних типів, алгоритм спробує привести їх до спільного типу перед порівнянням; наприклад, у виразі <code>5 == '5'</code>, рядок праворуч буде приведений до {{jsxref("Число","числа")}} перед здійсненням порівняння.</p>

<p>Оператори строгої рівності (<code>===</code> та <code>!==</code>) використовують <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6">алгоритм строгої рівності</a> та призначені для виконання перевірки рівності операндів одного типу. Якщо операнди належать до різних типів, результат завжди буде <code>false</code>, тому <code>5 !== '5'</code>.</p>

<p>Використовуйте оператори строгого порівняння, якщо операнди мають належати до вказаного типу, як і їх значення, або, якщо конкретний тип операндів має значення. Інакше, використовуйте стандартні оператори рівності, які дозволяють перевіряти ідентичність двох операндів, навіть якщо вони не належать до одного типу.</p>

<p>Коли в порівнянні застосовується перетворення типів (тобто, це не строге порівняння), JavaScript перетворює типи операндів {{jsxref ("String")}}, {{jsxref ("Число","Number")}}, {{jsxref ("Boolean" )}} або {{jsxref ("Object")}} наступним чином:</p>

<ul>
 <li>При порівнянні числа й рядка, рядок конвертується в числове значення. JavaScript намагається конвертувати число у рядковому літералі в значення типу <code>Number</code>. Спочатку математичне значення виводиться з рядкового літерала. Далі ця величина округлюється до найближчого значення типу <code>Number</code>.</li>
 <li>Якщо один з операндів належить до типу <code>Boolean</code>, цей операнд конвертується у 1, якщо він дорівнює <code>true</code>, і у +0, якщо він дорівнює <code>false</code>.</li>
 <li>Якщо об'єкт порівнюється з рядком або числом, JavaScript намагається повернути значення об'єкта за замовчуванням. Оператори намагаються перетворити об'єкти на просте значення, <font face="consolas, Liberation Mono, courier, monospace"><span style="background-color: rgba(220, 220, 220, 0.5);">рядок</span></font> або <code>число</code>, використовуючи методи об'єктів <code>valueOf</code> та <code>toString</code>. Якщо спроба перетворення була невдалою, генерується помилка виконання.</li>
 <li>Зауважте, що об'єкт перетворюється на просту величину тоді, й тільки тоді, коли порівнюється з простою величиною. Якщо обидва операнди є об'єктами, вони порівнюються як об'єкти, а тест на рівність істинний, тільки якщо вони обидва посилаються на один і той самий об'єкт.</li>
</ul>

<div class="note"><strong>Заувага:</strong> Рядкові об'єкти є об'єктами типу Object, а не String! Об'єкти типу String використовуються рідко, а отже, наведені нижче результати можуть бути несподіваними:</div>

<pre class="brush:js">// true, оскільки обидва операнди мають тип String (є рядковими примітивами):
'foo' === 'foo'

var a = new String('foo');
var b = new String('foo');

// false, оскільки a та b мають тип Object і посилаються на різні об'єкти
a == b

// false, оскільки a та b мають тип Object і посилаються на різні об'єкти
a === b

// true, оскільки a та 'foo' мають різні типи, але об'єкт (а)
// перетворюється на рядок 'foo' перед порівнянням
a == 'foo'</pre>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Специфікація</th>
   <th scope="col">Статус</th>
   <th scope="col">Коментар</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Початкове визначення. Реалізовано у JavaScript 1.0</td>
  </tr>
  <tr>
   <td>{{SpecName('ES3')}}</td>
   <td>{{Spec2('ES3')}}</td>
   <td>Додані оператори <code>===</code> та <code>!==</code> . Реалізовано у JavaScript 1.3</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-11.8')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>Дано визначення у декільках секціях специфікації: <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.8">Оператори відношення</a>, <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9">Оператори рівності</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-relational-operators')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>Дано визначення у декільках секціях специфікації: <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-relational-operators">Оператори відношення</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-equality-operators">Оператори рівності</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-relational-operators')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td>Дано визначення у декільках секціях специфікації: <a href="http://tc39.github.io/ecma262/#sec-relational-operators">Оператори відношення</a>, <a href="http://tc39.github.io/ecma262/#sec-equality-operators">Оператори рівності</a></td>
  </tr>
 </tbody>
</table>

<h2 id="Підтримка_веб-переглядачами">Підтримка веб-переглядачами</h2>



<p>{{Compat("javascript.operators.comparison")}}</p>

<h2 id="Див._також">Див. також</h2>

<ul>
 <li>{{jsxref("Object.is()")}}</li>
 <li>{{jsxref("Math.sign()")}}</li>
 <li><a href="/uk/docs/Web/JavaScript/Перевірка_на_рівність_та_однаковість">Перевірка на рівність та однаковість</a></li>
</ul>
