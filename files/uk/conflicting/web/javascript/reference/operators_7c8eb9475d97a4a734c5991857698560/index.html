---
title: Бітові оператори
slug: >-
  conflicting/Web/JavaScript/Reference/Operators_7c8eb9475d97a4a734c5991857698560
tags:
  - JavaScript
  - Довідка
  - Оператор
translation_of: Web/JavaScript/Reference/Operators
translation_of_original: Web/JavaScript/Reference/Operators/Bitwise_Operators
original_slug: Web/JavaScript/Reference/Operators/Bitwise_Operators
---
<div>{{jsSidebar("Operators")}}</div>

<p><strong>Бітові оператори</strong> опрацьовують свої операнди як послідовність 32-х бітів (нулів та одиниць), а не як десяткові, шістнадцяткові чи вісімкові <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Число">числа</a></code>. Наприклад, десяткове число дев'ять має бітове представлення 1001. Бітові оператори виконують операції над цими бітовими представленнями, але повертають стандартні числові значення JavaScript.</p>

<div>{{EmbedInteractiveExample("pages/js/expressions-bitwiseoperators.html")}}</div>



<p>Наступна таблиця наводить перелік бітових операторів JavaScript:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <th>Оператор</th>
   <th>Застосування</th>
   <th>Опис</th>
  </tr>
  <tr>
   <td><a href="#Побітове_І">Побітове І (AND)</a></td>
   <td><code>a &amp; b</code></td>
   <td>Повертає <code>1</code> на кожній позиції, де відповідні біти обох операндів дорівнюють <code>1</code>.</td>
  </tr>
  <tr>
   <td><a href="#Побітове_АБО">Побітове АБО (OR)</a></td>
   <td><code>a | b</code></td>
   <td>Повертає <code>1</code> на кожній позиції, де відповідні біти одного чи обох операндів дорівнюють <code>1</code>.</td>
  </tr>
  <tr>
   <td><a href="#Виключне_побітове_АБО">Виключне побітове АБО (XOR)</a></td>
   <td><code>a ^ b</code></td>
   <td>Повертає <code>1</code> на кожній позиції, де відповідний біт одного з двох, але не обох, операндів дорівнює <code>1</code>.</td>
  </tr>
  <tr>
   <td><a href="#Побітове_НЕ">Побітове НЕ (NOT)</a></td>
   <td><code>~ a</code></td>
   <td>Виконує інверсію бітів операнду.</td>
  </tr>
  <tr>
   <td><a href="#&lt;&lt;_Лівий_зсув">Лівий зсув</a></td>
   <td><code>a &lt;&lt; b</code></td>
   <td>Зсуває <code>a</code> у двійковому представленні на <code>b</code> (&lt; 32) бітів ліворуч, заповнюючи позиції справа нулями.</td>
  </tr>
  <tr>
   <td><a href="#>>_Правий_зсув_з_розширенням_знаку">Правий зсув з розширенням знаку</a></td>
   <td><code>a &gt;&gt; b</code></td>
   <td>Зсуває <code>a</code> у двійковому представленні на <code>b</code> (&lt; 32) бітів праворуч, відкидаючи зсунуті біти.</td>
  </tr>
  <tr>
   <td><a href="#>>>_Правий_зсув_із_заповненням_нулями">Правий зсув із заповненням нулями</a></td>
   <td><code>a &gt;&gt;&gt; b</code>  </td>
   <td>Зсуває <code>a</code> у двійковому представленні на <code>b</code> (&lt; 32) бітів праворуч, відкидаючи зсунуті біти та заповнюючи позиції зліва нулями.</td>
  </tr>
 </tbody>
</table>

<h2 id="32-бітні_цілі_числа_зі_знаком">32-бітні цілі числа зі знаком</h2>

<p>Операнди усіх бітових операторів перетворюються на 32-бітні цілі числа зі знаком у <a href="https://uk.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%B2%D0%BD%D1%8F%D0%BB%D1%8C%D0%BD%D0%B8%D0%B9_%D0%BA%D0%BE%D0%B4">форматі доповняльного коду</a>, окрім оператора правого зсуву із заповненням нулями, який повертає беззнакове ціле 32-бітне число. Формат доповняльного коду означає, що від'ємний еквівалент числа (наприклад, 5 та -5) - це інвертовані біти числа (побітове НЕ, або обернений код числа) плюс один. Для прикладу, наступний код представляє ціле число 314:</p>

<pre class="brush: js">00000000000000000000000100111010
</pre>

<p>Наступний код представляє <code>~314</code>, тобто, обернений код числа <code>314</code>:</p>

<pre class="brush: js">11111111111111111111111011000101
</pre>

<p>Нарешті, наступний код представляє доповняльний код числа <code>-314</code>:</p>

<pre class="brush: js">11111111111111111111111011000110
</pre>

<p>Доповняльний код гарантує, що лівий біт дорівнює 0, коли число є додатним, і 1, коли число є від'ємним. Тому він відомий як <em>знаковий біт</em>.</p>

<p>Число <code>0</code> є цілим числом, усі біти якого дорівнюють 0.</p>

<pre class="brush: js">0 (основа 10) = 00000000000000000000000000000000 (основа 2)
</pre>

<p>Число <code>-1</code> є цілим числом, усі біти якого дорівнюють 1.</p>

<pre class="brush: js">-1 (основа 10) = 11111111111111111111111111111111 (основа 2)
</pre>

<p>Число <code>-2147483648</code> (шістнадцяткове представлення: <code>-0x80000000</code>) є цілим числом, усі біти якого дорівнюють 0, окрім першого (старшого) біта.</p>

<pre class="brush: js">-2147483648 (основа 10) = 10000000000000000000000000000000 (основа 2)
</pre>

<p>Число <code>2147483647</code> (шістнадцяткове представлення: <code>0x7fffffff</code>) є цілим числом, усі біти якого дорівнюють 1, окрім першого (старшого) біта.</p>

<pre class="brush: js">2147483647 (основа 10) = 01111111111111111111111111111111 (основа 2)
</pre>

<p>Числа <code>-2147483648</code> та <code>2147483647</code> є мінімальним та максимальним цілими числами, які можуть бути представлені 32-бітним знаковим числом.</p>

<h2 id="Побітові_логічні_оператори">Побітові логічні оператори</h2>

<p>Концептуально побітові логічні оператори працюють наступним чином:</p>

<ul>
 <li>Операнди перетворюються на 32-бітні цілі числа та виражаються послідовністю бітів (нулів та одиниць). Числа, що мають більше 32 бітів, втрачають свої старші біти. Наприклад, наступне ціле число, що має більше 32 бітів, буде перетворено на 32-бітне ціле число:
  <pre class="brush: js">До:     11100110111110100000000000000110000000000001
Після:              10100000000000000110000000000001</pre>
 </li>
 <li>Кожен біт першого операнду ставиться у пару до відповідного біту другого операнду: перший біт до першого біту, другий біт до другого, і так далі.</li>
 <li>Оператор застосовується до кожної пари бітів, а результат будується побітово.</li>
</ul>

<h3 id="Побітове_І"><a id="Bitwise_AND" name="Bitwise_AND">&amp; (Побітове І)</a></h3>

<p>Виконує операцію І (AND) над кожною парою бітів. <code>a</code> І <code>b</code> дає 1 тільки якщо обидва, <code>a</code> та <code>b</code>, дорівнюють <code>1</code>. Таблиця істинності для операції <code>І</code> наступна:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a AND b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>0</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>1</td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">.    9 (основа 10) = 00000000000000000000000000001001 (основа 2)
    14 (основа 10) = 00000000000000000000000000001110 (основа 2)
                   --------------------------------
14 &amp; 9 (основа 10) = 00000000000000000000000000001000 (основа 2) = 8 (основа 10)
</pre>

<p>Побітове І над будь-яким числом <code>x</code> та <code>0</code> дає <code>0</code>.</p>

<h3 id="Побітове_АБО"><a id="Bitwise_OR" name="Bitwise_OR">| (Побітове АБО)</a></h3>

<p>Виконує операцію АБО (OR) над кожною парою бітів. <code>a</code> АБО <code>b</code> дає 1, якщо або <code>a</code>, або <code>b</code> дорівнює <code>1</code>. Таблиця істинності для операції <code>АБО</code> наступна:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a OR b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>1</td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">.    9 (основа 10) = 00000000000000000000000000001001 (основа 2)
    14 (основа 10) = 00000000000000000000000000001110 (основа 2)
                   --------------------------------
14 | 9 (основа 10) = 00000000000000000000000000001111 (основа 2) = 15 (основа 10)
</pre>

<p>Побітове АБО над будь-яким числом <code>x</code> та <code>0</code> дає <code>x</code>.</p>

<h3 id="Виключне_побітове_АБО"><a id="Bitwise_XOR" name="Bitwise_XOR">^ (Виключне побітове АБО)</a></h3>

<p>Виконує операцію виключного АБО (XOR) над кожною парою бітів. <code>a</code> викл. АБО <code>b</code> дає 1, якщо <code>a</code> та <code>b</code> є різними. Таблиця істинності для операції <code>XOR</code> наступна:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">b</td>
   <td class="header">a XOR b</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0</td>
   <td>0</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>1</td>
   <td>0</td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">.    9 (основа 10) = 00000000000000000000000000001001 (основа 2)
    14 (основа 10) = 00000000000000000000000000001110 (основа 2)
                   --------------------------------
14 ^ 9 (основа 10) = 00000000000000000000000000000111 (основа 2) = 7 (основа 10)
</pre>

<p>Виключне побітове АБО над будь-яким числом <code>x</code> та <code>0</code> дає x.</p>

<h3 id="Побітове_НЕ"><a id="Bitwise_NOT" name="Bitwise_NOT">~ (Побітове НЕ)</a></h3>

<p>Виконує операцію НЕ над кожним бітом. НЕ <code>a</code> повертає інвертоване значення (або обернений код) операнду <code>a</code>. Таблиця істинності для операції <code>НЕ</code> наступна:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">a</td>
   <td class="header">NOT a</td>
  </tr>
  <tr>
   <td>0</td>
   <td>1</td>
  </tr>
  <tr>
   <td>1</td>
   <td>0</td>
  </tr>
 </tbody>
</table>

<pre class="brush: js"> 9 (основа 10) = 00000000000000000000000000001001 (основа 2)
               --------------------------------
~9 (основа 10) = 11111111111111111111111111110110 (основа 2) = -10 (основа 10)
</pre>

<p>Побітове НЕ над будь-яким числом <code>x</code> дає <code>-(x + 1)</code>. Наприклад, <code>~-5</code> дорівнює <code>4</code>.</p>

<p>Зауважте, що через використання 32-бітного представлення чисел і <code>~-1</code>, і <code>~4294967295</code> (2<sup>32</sup>-1) повернуть <code>0</code>.</p>

<h2 id="Оператори_бітового_зсуву">Оператори бітового зсуву</h2>

<p>Оператори бітового зсуву приймають два операнди: перший є величиною, в якій треба виконати зсув, а другий вказує кількість бітових позицій для зсуву. Напрямок операції зсуву контролюється застосованим оператором.</p>

<p>Оператори зсуву перетворюють свої операнди на 32-бітні цілі числа у порядку від старшого до молодшого байту та повертають результат того самого типу, до якого належить лівий операнд. Лише молодші п'ять бітів правого операнду будуть використані.</p>

<h3 id="&lt;&lt;_Лівий_зсув"><a id="Left_shift" name="Left_shift">&lt;&lt; (Лівий зсув)</a></h3>

<p>Цей оператор виконує зсув першого операнду на вказану кількість бітів ліворуч. Надлишкові біти, зсунуті ліворуч, відкидаються. Біти, додані справа, заповнюються нулями.</p>

<p>Наприклад, <code>9 &lt;&lt; 2</code> дорівнює 36:</p>

<pre class="brush: js">.    9 (основа 10): 00000000000000000000000000001001 (основа 2)
                  --------------------------------
9 &lt;&lt; 2 (основа 10): 00000000000000000000000000100100 (основа 2) = 36 (основа 10)
</pre>

<p>Бітовий зсув будь-якого числа <code>x</code> ліворуч на <code>y</code> бітів дорівнює <code>x * 2 ** y</code>.<br>
 Отже, для прикладу: <code>9 &lt;&lt; 3</code> можна перекласти як: <code>9 * (2 ** 3) = 9 * (8) =</code><code> 72</code>.</p>

<h3 id=">>_Правий_зсув_з_розширенням_знаку"><a id="Right_shift" name="Right_shift">&gt;&gt; (Правий зсув з розширенням знаку)</a></h3>

<p>Цей оператор виконує зсув першого операнду на вказану кількість бітів праворуч. Надлишкові біти, зсунуті праворуч, відкидаються. Біти, додані зліва, заповнюються значенням старшого біта. Оскільки новий старший біт матиме те саме значення, що й попередній старший біт, знаковий (старший) біт не змінюється. Звідси назва "з розширенням знаку".</p>

<p>Наприклад, <code>9 &gt;&gt; 2</code> дорівнює 2:</p>

<pre class="brush: js">.    9 (основа 10): 00000000000000000000000000001001 (основа 2)
                  --------------------------------
9 &gt;&gt; 2 (основа 10): 00000000000000000000000000000010 (основа 2) = 2 (основа 10)
</pre>

<p>Аналогічно, <code>-9 &gt;&gt; 2</code> дорівнює <code>-3</code>, оскільки знак зберігається:</p>

<pre class="brush: js">.    -9 (основа 10): 11111111111111111111111111110111 (основа 2)
                   --------------------------------
-9 &gt;&gt; 2 (основа 10): 11111111111111111111111111111101 (основа 2) = -3 (основа 10)
</pre>

<h3 id=">>>_Правий_зсув_із_заповненням_нулями"><a id="Unsigned_right_shift" name="Unsigned_right_shift">&gt;&gt;&gt; (Правий зсув із заповненням нулями)</a></h3>

<p>Цей оператор виконує зсув першого операнду на вказану кількість бітів праворуч. Надлишкові біти, зсунуті праворуч, відкидаються. Біти, додані зліва, заповнюються нулями. Знаковий біт отримує значення 0, а отже, результат завжди невід'ємний. На відміну від інших бітових операторів, правий зсув із заповненням нулями повертає беззнакове ціле 32-бітне число.</p>

<p>Для невід'ємних чисел, правий зсув із заповненням нулями та правий зсув з розширенням знаку дають однаковий результат. Наприклад, <code>9 &gt;&gt;&gt; 2</code> дорівнює 2, так само, як <code>9 &gt;&gt; 2</code>:</p>

<pre class="brush: js">.     9 (основа 10): 00000000000000000000000000001001 (основа 2)
                   --------------------------------
9 &gt;&gt;&gt; 2 (основа 10): 00000000000000000000000000000010 (основа 2) = 2 (основа 10)
</pre>

<p>Однак, це не одне й те саме для від'ємних чисел. Наприклад, <code>-9 &gt;&gt;&gt; 2</code> поверне 1073741821, що відрізняється від <code>-9 &gt;&gt; 2</code> (що дорівнює <code>-3</code>):</p>

<pre class="brush: js">.     -9 (основа 10): 11111111111111111111111111110111 (основа 2)
                    --------------------------------
-9 &gt;&gt;&gt; 2 (основа 10): 00111111111111111111111111111101 (основа 2) = 1073741821 (основа 10)
</pre>

<h2 id="Приклади">Приклади</h2>

<h3 id="Прапори_та_бітові_маски">Прапори та бітові маски</h3>

<p>Побітові логічні оператори часто використовуються для створення, маніпулювання та читання послідовностей <em>прапорів</em>, які грають роль двійкових змінних. Замість цих послідовностей можуть використовуватись зміні, але двійкові прапори займають набагато менше пам'яті (у 32 рази).</p>

<p>Припустимо, є 4 прапори:</p>

<ul>
 <li>прапор A: ми маємо проблему з мурахами</li>
 <li>прапор B: ми маємо кажана</li>
 <li>прапор C: ми маємо кота</li>
 <li>прапор D: ми маємо качку</li>
</ul>

<p>Ці прапори представлені послідовністю бітів: DCBA. Коли прапор <em>встановлений</em>, він має значення 1. Коли прапор <em>очищений</em>, він має значення 0. Припустимо, змінна <code>flags</code> має двійкове значення 0101:</p>

<pre class="brush: js">var flags = 5;   // двійкове значення 0101
</pre>

<p>Це значення вказує:</p>

<ul>
 <li>прапор A дорівнює true (ми маємо проблему з мурахами);</li>
 <li>прапор B дорівнює false (ми не маємо кажана);</li>
 <li>прапор C дорівнює true (ми маємо кота);</li>
 <li>прапор D дорівнює false (ми не маємо качки);</li>
</ul>

<p>Оскільки бітові операнди 32-бітні, 0101 насправді дорівнює 00000000000000000000000000000101, але нулями попереду можна знехтувати, оскільки вони не містять корисної інформації.</p>

<p><em>Бітова маска</em> - це послідовність бітів, які можуть маніпулювати прапорами та/або читати їх. Зазвичай, визначається "примітивна" бітова маска для кожного прапора:</p>

<pre class="brush: js">var FLAG_A = 1; // 0001
var FLAG_B = 2; // 0010
var FLAG_C = 4; // 0100
var FLAG_D = 8; // 1000
</pre>

<p>Нові бітові маски можуть створюватись застовуванням побітових логічних операторів до цих примітивних бітових масок. Наприклад, бітова маска 1011 може бути створена операцією АБО з прапорів FLAG_A, FLAG_B та FLAG_D:</p>

<pre class="brush: js">var mask = FLAG_A | FLAG_B | FLAG_D; // 0001 | 0010 | 1000 =&gt; 1011
</pre>

<p>Індивідуальні значення прапорів можна витягнути застосуванням операції І до них та бітової маски, де кожний біт, що має значення один, "витягне" відповідний прапор. Бітова маска <em>маскує</em> невідповідні прапори, об'єднуючи їх операцією І з нулями (звідси термін "бітова маска"). Наприклад, бітову маску 0100 можна використати, щоб побачити, чи встановлений прапор C:</p>

<pre class="brush: js">// якщо ми маємо кота
if (flags &amp; FLAG_C) { // 0101 &amp; 0100 =&gt; 0100 =&gt; true
   // зробити щось
}
</pre>

<p>Бітова маска з кількома встановленими прапорами діє як "або/або". Для прикладу, наступні два фрагменти еквівалентні:</p>

<pre class="brush: js">// якщо ми маємо кажана або ми маємо кота
// (0101 &amp; 0010) || (0101 &amp; 0100) =&gt; 0000 || 0100 =&gt; true
if ((flags &amp; FLAG_B) || (flags &amp; FLAG_C)) {
   // зробити щось
}
</pre>

<pre class="brush: js">// якщо ми маємо кажана або кота
var mask = FLAG_B | FLAG_C; // 0010 | 0100 =&gt; 0110
if (flags &amp; mask) { // 0101 &amp; 0110 =&gt; 0100 =&gt; true
   // зробити щось
}
</pre>

<p>Прапори можна встановити, об'єднавши їх операцією АБО з бітовою маскою, де кожний біт, що має значення один, встановить відповідний прапор, якщо прапор ще не встановлений. Наприклад, бітову маску 1100 можна використати, щоб встановити прапори C та D:</p>

<pre class="brush: js">// так, ми маємо кота та качку
var mask = FLAG_C | FLAG_D; // 0100 | 1000 =&gt; 1100
flags |= mask;   // 0101 | 1100 =&gt; 1101
</pre>

<p>Прапори можна очистити, об'єднавши їх операцією І з бітовою маскою, де кожний біт, що має значення нуль, очистить відповідний прапор, якщо він ще не очищений. Ця бітова маска може бути створена застосуванням операції НЕ до примітивних бітових масок. Наприклад, бітову маску 1010 можна використати, щоб очистити прапори A та C:</p>

<pre class="brush: js">// ні, ми не маємо проблеми з мурахами або кота
var mask = ~(FLAG_A | FLAG_C); // ~0101 =&gt; 1010
flags &amp;= mask;   // 1101 &amp; 1010 =&gt; 1000
</pre>

<p>Маску також можна створити за допомогою <code>~FLAG_A &amp; ~FLAG_C</code> (правило де Моргана):</p>

<pre class="brush: js">// ні, ми не маємо проблеми з мурахами і ми не маємо кота
var mask = ~FLAG_A &amp; ~FLAG_C;
flags &amp;= mask;   // 1101 &amp; 1010 =&gt; 1000
</pre>

<p>Прапори можна перемикати, об'єднуючи їх операцією виключне АБО з бітовою маскою, де кожний біт, що має значення один, переключить відповідний прапор. Наприклад, бітову маску 0110 можна використати, щоб переключити прапори B та C:</p>

<pre class="brush: js">// якщо ми не мали кажана, тепер ми його маємо,
// а якщо він в нас був, бувай, кажанчику
// те саме для котів
var mask = FLAG_B | FLAG_C;
flags = flags ^ mask;   // 1100 ^ 0110 =&gt; 1010
</pre>

<p>Нарешті, усі прапори можна перевернути оператором НЕ:</p>

<pre class="brush: js">// входимо у паралельний всесвіт...
flags = ~flags;    // ~1010 =&gt; 0101
</pre>

<h3 id="Перетворення_типів">Перетворення типів</h3>

<p>Перетворити двійковий <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/String">рядок</a></code> на десяткове <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Число">число</a></code>:</p>

<pre class="brush: js">var sBinString = '1011';
var nMyNumber = parseInt(sBinString, 2);
alert(nMyNumber); // виводить 11, тобто 1011
</pre>

<p>Перетворити десяткове <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Число">число</a></code> на двійковий <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/String">рядок</a></code>:</p>

<pre class="brush: js">var nMyNumber = 11;
var sBinString = nMyNumber.toString(2);
alert(sBinString); // виводить 1011, тобто 11
</pre>

<h3 id="Автоматизація_створення_маски">Автоматизація створення маски</h3>

<p>Ви можете створювати маски з набору <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Boolean">булевих</a></code> значень наступним чином:</p>

<pre class="brush: js">function createMask() {
  var nMask = 0, nFlag = 0, nLen = arguments.length &gt; 32 ? 32 : arguments.length;
  for (nFlag; nFlag &lt; nLen; nMask |= arguments[nFlag] &lt;&lt; nFlag++);
  return nMask;
}
var mask1 = createMask(true, true, false, true); // 11, тобто: 1011
var mask2 = createMask(false, false, true); // 4, тобто: 0100
var mask3 = createMask(true); // 1, тобто: 0001
// і т.д.

alert(mask1); // виводить 11, тобто: 1011
</pre>

<h3 id="Зворотний_алгоритм_отримання_масиву_булевих_значень_з_маски">Зворотний алгоритм: отримання масиву булевих значень з маски</h3>

<p>Якщо ви бажаєте створити <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Array">масив</a></code> <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Boolean">булевих значень</a></code> з маски, можете скористатись цим кодом:</p>

<pre class="brush: js">function arrayFromMask(nMask) {
  // Значенння nMask має бути між -2147483648 та 2147483647
  if (nMask &gt; 0x7fffffff || nMask &lt; -0x80000000) {
    throw new TypeError('arrayFromMask - out of range');
  }
  for (var nShifted = nMask, aFromMask = []; nShifted;
       aFromMask.push(Boolean(nShifted &amp; 1)), nShifted &gt;&gt;&gt;= 1);
  return aFromMask;
}

var array1 = arrayFromMask(11);
var array2 = arrayFromMask(4);
var array3 = arrayFromMask(1);

alert('[' + array1.join(', ') + ']');
// виводить "[true, true, false, true]", тобто: 11, тобто: 1011
</pre>

<p>Ви можете перевірити обидва алгоритми одночасно…</p>

<pre class="brush: js">var nTest = 19; // наша користувацька маска
var nResult = createMask.apply(this, arrayFromMask(nTest));

alert(nResult); // 19
</pre>

<p>Суто з навчальною метою (оскільки існує метод <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Number/toString">Number.toString(2)</a></code>) ми показуємо, як можна модифікувати алгоритм <code>arrayFromMask</code> для створення <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/String">рядка</a></code>, що містить двійкове представлення <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Число">числа</a></code>, а не <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Array">масиву</a></code> <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Boolean">булевих значень</a></code>:</p>

<pre class="brush: js">function createBinaryString(nMask) {
  // Значення nMask має бути між -2147483648 та 2147483647
  for (var nFlag = 0, nShifted = nMask, sMask = ''; nFlag &lt; 32;
       nFlag++, sMask += String(nShifted &gt;&gt;&gt; 31), nShifted &lt;&lt;= 1);
  return sMask;
}

var string1 = createBinaryString(11);
var string2 = createBinaryString(4);
var string3 = createBinaryString(1);

alert(string1);
// виводить 00000000000000000000000000001011, тобто 11
</pre>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Специфікація</th>
   <th scope="col">Статус</th>
   <th scope="col">Коментар</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Початкове визначення.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-11.7')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>Визначені у кількох розділах специфікації: <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.4.8">Побітовий оператор НЕ</a>, <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.7">Бітові оператори зсуву</a>, <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.10">Двійкові побітові оператори</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-bitwise-shift-operators')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>Визначені у кількох розділах специфікації: <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-bitwise-not-operator">Побітовий оператор НЕ</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-bitwise-shift-operators">Бітові оператори зсуву</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-binary-bitwise-operators">Двійкові побітові оператори</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-bitwise-shift-operators')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td>Визначені у кількох розділах специфікації: <a href="http://tc39.github.io/ecma262/#sec-bitwise-not-operator">Побітовий оператор НЕ</a>, <a href="http://tc39.github.io/ecma262/#sec-bitwise-shift-operators">Бітові оператори зсуву</a>, <a href="http://tc39.github.io/ecma262/#sec-binary-bitwise-operators">Двійкові побітові оператори</a></td>
  </tr>
 </tbody>
</table>

<h2 id="Сумісність_з_веб-переглядачами">Сумісність з веб-переглядачами</h2>

<div class="hidden">
<p>The compatibility table on this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</p>
</div>

<p>{{Compat("javascript.operators.bitwise")}}</p>

<h2 id="Див._також">Див. також</h2>

<ul>
 <li><a href="/uk/docs/Web/JavaScript/Reference/Operators/Logical_Operators">Логічні оператори</a></li>
</ul>
